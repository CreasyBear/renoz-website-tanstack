import { A as createServerRpc, B as createServerFn, a as reactExports, o as jsxRuntimeExports, y as getAugmentedNamespace, z as commonjsGlobal } from "./server.mjs";
import { c as createClient } from "./index-BHtk7koP.mjs";
import require$$0$3 from "node:crypto";
import console$1 from "console";
import { Writable } from "node:stream";
import { o as objectType, b as booleanType, a as arrayType, s as stringType } from "./types-CBhy9KzI.mjs";
import "node:async_hooks";
import "util";
import "crypto";
import "async_hooks";
import "stream";
import "node:stream/web";
const marginProperties = [
  "margin",
  "marginTop",
  "marginBottom",
  "marginRight",
  "marginLeft",
  "marginInline",
  "marginBlock",
  "marginBlockStart",
  "marginBlockEnd",
  "marginInlineStart",
  "marginInlineEnd"
];
const Body = reactExports.forwardRef(({ children, style, ...props }, ref) => {
  const bodyStyle = {
    background: style?.background,
    backgroundColor: style?.backgroundColor
  };
  if (style) for (const property of marginProperties) bodyStyle[property] = style[property] !== void 0 ? 0 : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("body", {
    ...props,
    style: bodyStyle,
    ref,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("table", {
      border: 0,
      width: "100%",
      cellPadding: "0",
      cellSpacing: "0",
      role: "presentation",
      align: "center",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("td", {
        style,
        children
      }) }) })
    })
  });
});
Body.displayName = "Body";
function convertToPx(value) {
  let px = 0;
  if (!value) return px;
  if (typeof value === "number") return value;
  const matches = /^([\d.]+)(px|em|rem|%)$/.exec(value);
  if (matches && matches.length === 3) {
    const numValue = Number.parseFloat(matches[1]);
    switch (matches[2]) {
      case "px":
        return numValue;
      case "em":
      case "rem":
        px = numValue * 16;
        return px;
      case "%":
        px = numValue / 100 * 600;
        return px;
      default:
        return numValue;
    }
  }
  return 0;
}
function parsePaddingValue(value) {
  if (typeof value === "number") return {
    paddingTop: value,
    paddingBottom: value,
    paddingLeft: value,
    paddingRight: value
  };
  if (typeof value === "string") {
    const values = value.toString().trim().split(/\s+/);
    if (values.length === 1) return {
      paddingTop: values[0],
      paddingBottom: values[0],
      paddingLeft: values[0],
      paddingRight: values[0]
    };
    if (values.length === 2) return {
      paddingTop: values[0],
      paddingRight: values[1],
      paddingBottom: values[0],
      paddingLeft: values[1]
    };
    if (values.length === 3) return {
      paddingTop: values[0],
      paddingRight: values[1],
      paddingBottom: values[2],
      paddingLeft: values[1]
    };
    if (values.length === 4) return {
      paddingTop: values[0],
      paddingRight: values[1],
      paddingBottom: values[2],
      paddingLeft: values[3]
    };
  }
  return {
    paddingTop: void 0,
    paddingBottom: void 0,
    paddingLeft: void 0,
    paddingRight: void 0
  };
}
function parsePadding(properties) {
  let paddingTop;
  let paddingRight;
  let paddingBottom;
  let paddingLeft;
  for (const [key, value] of Object.entries(properties)) if (key === "padding") ({ paddingTop, paddingBottom, paddingLeft, paddingRight } = parsePaddingValue(value));
  else if (key === "paddingTop") paddingTop = value;
  else if (key === "paddingRight") paddingRight = value;
  else if (key === "paddingBottom") paddingBottom = value;
  else if (key === "paddingLeft") paddingLeft = value;
  return {
    paddingTop: paddingTop ? convertToPx(paddingTop) : void 0,
    paddingRight: paddingRight ? convertToPx(paddingRight) : void 0,
    paddingBottom: paddingBottom ? convertToPx(paddingBottom) : void 0,
    paddingLeft: paddingLeft ? convertToPx(paddingLeft) : void 0
  };
}
const pxToPt = (px) => typeof px === "number" && !Number.isNaN(Number(px)) ? px * 3 / 4 : void 0;
const maxFontWidth = 5;
function computeFontWidthAndSpaceCount(expectedWidth) {
  if (expectedWidth === 0) return [0, 0];
  let smallestSpaceCount = 0;
  const computeRequiredFontWidth = () => {
    if (smallestSpaceCount > 0) return expectedWidth / smallestSpaceCount / 2;
    return Number.POSITIVE_INFINITY;
  };
  while (computeRequiredFontWidth() > maxFontWidth) smallestSpaceCount++;
  return [computeRequiredFontWidth(), smallestSpaceCount];
}
const Button = reactExports.forwardRef(({ children, style, target: target2 = "_blank", ...props }, ref) => {
  const { paddingTop, paddingRight, paddingBottom, paddingLeft } = parsePadding(style ?? {});
  const textRaise = pxToPt((paddingTop ?? 0) + (paddingBottom ?? 0));
  const [plFontWidth, plSpaceCount] = computeFontWidthAndSpaceCount(paddingLeft ?? 0);
  const [prFontWidth, prSpaceCount] = computeFontWidthAndSpaceCount(paddingRight ?? 0);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("a", {
    ...props,
    ref,
    style: {
      lineHeight: "100%",
      textDecoration: "none",
      display: "inline-block",
      maxWidth: "100%",
      msoPaddingAlt: "0px",
      ...style,
      paddingTop,
      paddingRight,
      paddingBottom,
      paddingLeft
    },
    target: target2,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { dangerouslySetInnerHTML: { __html: `<!--[if mso]><i style="mso-font-width:${plFontWidth * 100}%;mso-text-raise:${textRaise}" hidden>${"&#8202;".repeat(plSpaceCount)}</i><![endif]-->` } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        style: {
          maxWidth: "100%",
          display: "inline-block",
          lineHeight: "120%",
          msoPaddingAlt: "0px",
          msoTextRaise: pxToPt(paddingBottom)
        },
        children
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { dangerouslySetInnerHTML: { __html: `<!--[if mso]><i style="mso-font-width:${prFontWidth * 100}%" hidden>${"&#8202;".repeat(prSpaceCount)}&#8203;</i><![endif]-->` } })
    ]
  });
});
Button.displayName = "Button";
const Column = reactExports.forwardRef(({ children, style, ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("td", {
    ...props,
    "data-id": "__react-email-column",
    ref,
    style,
    children
  });
});
Column.displayName = "Column";
const Container = reactExports.forwardRef(({ children, style, ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("table", {
    align: "center",
    width: "100%",
    ...props,
    border: 0,
    cellPadding: "0",
    cellSpacing: "0",
    ref,
    role: "presentation",
    style: {
      maxWidth: "37.5em",
      ...style
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("tr", {
      style: { width: "100%" },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children })
    }) })
  });
});
Container.displayName = "Container";
const Head = reactExports.forwardRef(({ children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs("head", {
  ...props,
  ref,
  children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", {
      content: "text/html; charset=UTF-8",
      httpEquiv: "Content-Type"
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "x-apple-disable-message-reformatting" }),
    children
  ]
}));
Head.displayName = "Head";
const withMargin = (props) => {
  const candidates = [
    withSpace(props.m, ["margin"]),
    withSpace(props.mx, ["marginLeft", "marginRight"]),
    withSpace(props.my, ["marginTop", "marginBottom"]),
    withSpace(props.mt, ["marginTop"]),
    withSpace(props.mr, ["marginRight"]),
    withSpace(props.mb, ["marginBottom"]),
    withSpace(props.ml, ["marginLeft"])
  ];
  const mergedStyles = {};
  for (const style of candidates) if (Object.keys(style).length > 0) Object.assign(mergedStyles, style);
  return mergedStyles;
};
const withSpace = (value, properties) => {
  const styles2 = {};
  if (value === void 0) return styles2;
  if (Number.isNaN(Number.parseFloat(String(value)))) return styles2;
  for (const property of properties) styles2[property] = `${value}px`;
  return styles2;
};
const Heading = reactExports.forwardRef(({ as: Tag = "h1", children, style, m, mx, my, mt: mt2, mr: mr2, mb, ml: ml2, ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, {
    ...props,
    ref,
    style: {
      ...withMargin({
        m,
        mx,
        my,
        mt: mt2,
        mr: mr2,
        mb,
        ml: ml2
      }),
      ...style
    },
    children
  });
});
Heading.displayName = "Heading";
const Hr$1 = reactExports.forwardRef(({ style, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {
  ...props,
  ref,
  style: {
    width: "100%",
    border: "none",
    borderTop: "1px solid #eaeaea",
    ...style
  }
}));
Hr$1.displayName = "Hr";
const Html = reactExports.forwardRef(({ children, lang: lang2 = "en", dir = "ltr", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("html", {
  ...props,
  dir,
  lang: lang2,
  ref,
  children
}));
Html.displayName = "Html";
const Img = reactExports.forwardRef(({ alt, src, width, height, style, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
  ...props,
  alt,
  height,
  ref,
  src,
  style: {
    display: "block",
    outline: "none",
    border: "none",
    textDecoration: "none",
    ...style
  },
  width
}));
Img.displayName = "Img";
const Link = reactExports.forwardRef(({ target: target2 = "_blank", style, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("a", {
  ...props,
  ref,
  style: {
    color: "#067df7",
    textDecorationLine: "none",
    ...style
  },
  target: target2,
  children: props.children
}));
Link.displayName = "Link";
const PREVIEW_MAX_LENGTH = 150;
const Preview = reactExports.forwardRef(({ children = "", ...props }, ref) => {
  const text = (Array.isArray(children) ? children.join("") : children).substring(0, PREVIEW_MAX_LENGTH);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    style: {
      display: "none",
      overflow: "hidden",
      lineHeight: "1px",
      opacity: 0,
      maxHeight: 0,
      maxWidth: 0
    },
    "data-skip-in-text": true,
    ...props,
    ref,
    children: [text, renderWhiteSpace(text)]
  });
});
Preview.displayName = "Preview";
const whiteSpaceCodes = " ‌​‍‎‏\uFEFF";
const renderWhiteSpace = (text) => {
  if (text.length >= PREVIEW_MAX_LENGTH) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: whiteSpaceCodes.repeat(PREVIEW_MAX_LENGTH - text.length) });
};
var Jr$1 = Object.defineProperty;
var Zr$1 = (e) => {
  throw TypeError(e);
};
var ks = (e, t, r) => t in e ? Jr$1(e, t, { enumerable: true, configurable: true, writable: true, value: r }) : e[t] = r;
var en$1 = (e, t) => {
  for (var r in t) Jr$1(e, r, { get: t[r], enumerable: true });
};
var ir$1 = (e, t, r) => ks(e, typeof t != "symbol" ? t + "" : t, r), As = (e, t, r) => t.has(e) || Zr$1("Cannot " + r);
var $e = (e, t, r) => (As(e, t, "read from private field"), r ? r.call(e) : t.get(e)), tn$1 = (e, t, r) => t.has(e) ? Zr$1("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r);
var ws$1 = {};
en$1(ws$1, { languages: () => ms, options: () => ds, parsers: () => Qr$1, printers: () => xl });
var Ae$1 = (e, t) => (r, n, ...i) => r | 1 && n == null ? void 0 : (t.call(n) ?? n[e]).apply(n, i);
var ys = String.prototype.replaceAll ?? function(e, t) {
  return e.global ? this.replace(e, t) : this.split(e).join(t);
}, xs = Ae$1("replaceAll", function() {
  if (typeof this == "string") return ys;
}), w$1 = xs;
function Ns(e) {
  return this[e < 0 ? this.length + e : e];
}
var Ls = Ae$1("at", function() {
  if (Array.isArray(this) || typeof this == "string") return Ns;
}), F = Ls;
var Ps = () => {
}, ze$1 = Ps;
var Ye$1 = "string", je$1 = "array", _t = "cursor", ye$1 = "indent", xe$1 = "align", St = "trim", Ne$1 = "group", Le$1 = "fill", Pe$1 = "if-break", Oe$1 = "indent-if-break", Et$1 = "line-suffix", Ct$1 = "line-suffix-boundary", Y$1 = "line", vt = "label", De$1 = "break-parent", Tt = /* @__PURE__ */ new Set([_t, ye$1, xe$1, St, Ne$1, Le$1, Pe$1, Oe$1, Et$1, Ct$1, Y$1, vt, De$1]);
function Os(e) {
  if (typeof e == "string") return Ye$1;
  if (Array.isArray(e)) return je$1;
  if (!e) return;
  let { type: t } = e;
  if (Tt.has(t)) return t;
}
var bt = Os;
var Ds = (e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e);
function Rs(e) {
  let t = e === null ? "null" : typeof e;
  if (t !== "string" && t !== "object") return `Unexpected doc '${t}', 
Expected it to be 'string' or 'object'.`;
  if (bt(e)) throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(e);
  if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
  let n = Ds([...Tt].map((i) => `'${i}'`));
  return `Unexpected doc.type '${e.type}'.
Expected it to be ${n}.`;
}
var sr$1 = class sr extends Error {
  name = "InvalidDocError";
  constructor(t) {
    super(Rs(t)), this.doc = t;
  }
}, rn$1 = sr$1;
function ar$1(e, t) {
  if (typeof e == "string") return t(e);
  let r = /* @__PURE__ */ new Map();
  return n(e);
  function n(s) {
    if (r.has(s)) return r.get(s);
    let a = i(s);
    return r.set(s, a), a;
  }
  function i(s) {
    switch (bt(s)) {
      case je$1:
        return t(s.map(n));
      case Le$1:
        return t({ ...s, parts: s.parts.map(n) });
      case Pe$1:
        return t({ ...s, breakContents: n(s.breakContents), flatContents: n(s.flatContents) });
      case Ne$1: {
        let { expandedStates: a, contents: o } = s;
        return a ? (a = a.map(n), o = a[0]) : o = n(o), t({ ...s, contents: o, expandedStates: a });
      }
      case xe$1:
      case ye$1:
      case Oe$1:
      case vt:
      case Et$1:
        return t({ ...s, contents: n(s.contents) });
      case Ye$1:
      case _t:
      case St:
      case Ct$1:
      case Y$1:
      case De$1:
        return t(s);
      default:
        throw new rn$1(s);
    }
  }
}
function L$1(e, t = nn$1) {
  return ar$1(e, (r) => typeof r == "string" ? q$1(t, r.split(`
`)) : r);
}
var wt = ze$1;
function y(e) {
  return { type: ye$1, contents: e };
}
function Is(e, t) {
  return { type: xe$1, contents: t, n: e };
}
function on$1(e) {
  return Is(Number.NEGATIVE_INFINITY, e);
}
var j$1 = { type: De$1 };
function kt$1(e) {
  return { type: Le$1, parts: e };
}
function C(e, t = {}) {
  return wt(t.expandedStates), { type: Ne$1, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
}
function X$1(e, t = "", r = {}) {
  return { type: Pe$1, breakContents: e, flatContents: t, groupId: r.groupId };
}
function ln(e, t) {
  return { type: Oe$1, contents: e, groupId: t.groupId, negate: t.negate };
}
function q$1(e, t) {
  let r = [];
  for (let n = 0; n < t.length; n++) n !== 0 && r.push(e), r.push(t[n]);
  return r;
}
var _$1 = { type: Y$1 }, k$1 = { type: Y$1, soft: true }, Ms = { type: Y$1, hard: true }, v$1 = [Ms, j$1], Bs = { type: Y$1, hard: true, literal: true }, nn$1 = [Bs, j$1];
var cn = Object.freeze({ character: "'", codePoint: 39 }), un$1 = Object.freeze({ character: '"', codePoint: 34 }), Fs = Object.freeze({ preferred: cn, alternate: un$1 }), qs = Object.freeze({ preferred: un$1, alternate: cn });
function Hs(e, t) {
  let { preferred: r, alternate: n } = t === true || t === "'" ? Fs : qs, { length: i } = e, s = 0, a = 0;
  for (let o = 0; o < i; o++) {
    let c = e.charCodeAt(o);
    c === r.codePoint ? s++ : c === n.codePoint && a++;
  }
  return (s > a ? n : r).character;
}
var pn = Hs;
function or$2(e) {
  if (typeof e != "string") throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var lr$1 = class lr {
  #e;
  constructor(t) {
    this.#e = new Set(t);
  }
  getLeadingWhitespaceCount(t) {
    let r = this.#e, n = 0;
    for (let i = 0; i < t.length && r.has(t.charAt(i)); i++) n++;
    return n;
  }
  getTrailingWhitespaceCount(t) {
    let r = this.#e, n = 0;
    for (let i = t.length - 1; i >= 0 && r.has(t.charAt(i)); i--) n++;
    return n;
  }
  getLeadingWhitespace(t) {
    let r = this.getLeadingWhitespaceCount(t);
    return t.slice(0, r);
  }
  getTrailingWhitespace(t) {
    let r = this.getTrailingWhitespaceCount(t);
    return t.slice(t.length - r);
  }
  hasLeadingWhitespace(t) {
    return this.#e.has(t.charAt(0));
  }
  hasTrailingWhitespace(t) {
    return this.#e.has(F(0, t, -1));
  }
  trimStart(t) {
    let r = this.getLeadingWhitespaceCount(t);
    return t.slice(r);
  }
  trimEnd(t) {
    let r = this.getTrailingWhitespaceCount(t);
    return t.slice(0, t.length - r);
  }
  trim(t) {
    return this.trimEnd(this.trimStart(t));
  }
  split(t, r = false) {
    let n = `[${or$2([...this.#e].join(""))}]+`, i = new RegExp(r ? `(${n})` : n, "u");
    return t.split(i);
  }
  hasWhitespaceCharacter(t) {
    let r = this.#e;
    return Array.prototype.some.call(t, (n) => r.has(n));
  }
  hasNonWhitespaceCharacter(t) {
    let r = this.#e;
    return Array.prototype.some.call(t, (n) => !r.has(n));
  }
  isWhitespaceOnly(t) {
    let r = this.#e;
    return Array.prototype.every.call(t, (n) => r.has(n));
  }
  #t(t) {
    let r = Number.POSITIVE_INFINITY;
    for (let n of t.split(`
`)) {
      if (n.length === 0) continue;
      let i = this.getLeadingWhitespaceCount(n);
      if (i === 0) return 0;
      n.length !== i && i < r && (r = i);
    }
    return r === Number.POSITIVE_INFINITY ? 0 : r;
  }
  dedentString(t) {
    let r = this.#t(t);
    return r === 0 ? t : t.split(`
`).map((n) => n.slice(r)).join(`
`);
  }
}, hn$1 = lr$1;
var Vs = ["	", `
`, "\f", "\r", " "], Us = new hn$1(Vs), x$1 = Us;
var cr$1 = class cr extends Error {
  name = "UnexpectedNodeError";
  constructor(t, r, n = "type") {
    super(`Unexpected ${r} node ${n}: ${JSON.stringify(t[n])}.`), this.node = t;
  }
}, mn$1 = cr$1;
var Ws = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]), Gs = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function fn(e, t, r) {
  if (e.kind === "text" || e.kind === "comment") return null;
  if (e.kind === "yaml" && delete t.value, e.kind === "attribute") {
    let { fullName: n, value: i } = e;
    n === "style" || n === "class" || n === "srcset" && (r.fullName === "img" || r.fullName === "source") || n === "allow" && r.fullName === "iframe" || n.startsWith("on") || n.startsWith("@") || n.startsWith(":") || n.startsWith(".") || n.startsWith("#") || n.startsWith("v-") || n === "vars" && r.fullName === "style" || (n === "setup" || n === "generic") && r.fullName === "script" || n === "slot-scope" || n.startsWith("(") || n.startsWith("[") || n.startsWith("*") || n.startsWith("bind") || n.startsWith("i18n") || n.startsWith("on-") || n.startsWith("ng-") || i?.includes("{{") ? delete t.value : i && (t.value = w$1(0, i, /'|&quot;|&apos;/gu, '"'));
  }
  if (e.kind === "docType" && (t.value = w$1(0, e.value.toLowerCase(), /\s+/gu, " ")), e.kind === "angularControlFlowBlock" && e.parameters?.children) for (let n of t.parameters.children) Gs.has(e.name) ? delete n.expression : n.expression = n.expression.trim();
  e.kind === "angularIcuExpression" && (t.switchValue = e.switchValue.trim()), e.kind === "angularLetDeclarationInitializer" && delete t.value, e.kind === "element" && e.isVoid && !e.isSelfClosing && (t.isSelfClosing = true);
}
fn.ignoredProperties = Ws;
var dn$1 = fn;
function K$1(e, t = true) {
  return [y([k$1, e]), t ? k$1 : ""];
}
function W$1(e, t) {
  let r = e.type === "NGRoot" ? e.node.type === "NGMicrosyntax" && e.node.body.length === 1 && e.node.body[0].type === "NGMicrosyntaxExpression" ? e.node.body[0].expression : e.node : e.type === "JsExpressionRoot" ? e.node : e;
  return r && (r.type === "ObjectExpression" || r.type === "ArrayExpression" || (t.parser === "__vue_expression" || t.parser === "__vue_ts_expression") && (r.type === "TemplateLiteral" || r.type === "StringLiteral"));
}
async function A(e, t, r, n) {
  r = { __isInHtmlAttribute: true, __embeddedInHtml: true, ...r };
  let i = true;
  n && (r.__onHtmlBindingRoot = (a, o) => {
    i = n(a, o);
  });
  let s = await t(e, r, t);
  return i ? C(s) : K$1(s);
}
function $s(e, t, r, n) {
  let { node: i } = r, s = n.originalText.slice(i.sourceSpan.start.offset, i.sourceSpan.end.offset);
  return /^\s*$/u.test(s) ? "" : A(s, e, { parser: "__ng_directive", __isInHtmlAttribute: false }, W$1);
}
var gn$1 = $s;
var zs = Array.prototype.toReversed ?? function() {
  return [...this].reverse();
}, Ys = Ae$1("toReversed", function() {
  if (Array.isArray(this)) return zs;
}), _n$1 = Ys;
function js() {
  let e = globalThis, t = e.Deno?.build?.os;
  return typeof t == "string" ? t === "windows" : e.navigator?.platform?.startsWith("Win") ?? e.process?.platform?.startsWith("win") ?? false;
}
var Xs = js();
function Sn$1(e) {
  if (e = e instanceof URL ? e : new URL(e), e.protocol !== "file:") throw new TypeError(`URL must be a file URL: received "${e.protocol}"`);
  return e;
}
function Ks(e) {
  return e = Sn$1(e), decodeURIComponent(e.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function Qs(e) {
  e = Sn$1(e);
  let t = decodeURIComponent(e.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return e.hostname !== "" && (t = `\\\\${e.hostname}${t}`), t;
}
function ur$1(e) {
  return Xs ? Qs(e) : Ks(e);
}
var En$1 = (e) => String(e).split(/[/\\]/u).pop(), Cn$1 = (e) => String(e).startsWith("file:");
function Js(e) {
  return Array.isArray(e) && e.length > 0;
}
var Re$2 = Js;
function vn$1(e, t) {
  if (!t) return;
  let r = En$1(t).toLowerCase();
  return e.find(({ filenames: n }) => n?.some((i) => i.toLowerCase() === r)) ?? e.find(({ extensions: n }) => n?.some((i) => r.endsWith(i)));
}
function Zs(e, t) {
  if (t) return e.find(({ name: r }) => r.toLowerCase() === t) ?? e.find(({ aliases: r }) => r?.includes(t)) ?? e.find(({ extensions: r }) => r?.includes(`.${t}`));
}
var ea$1 = void 0;
function Tn$1(e, t) {
  if (t) {
    if (Cn$1(t)) try {
      t = ur$1(t);
    } catch {
      return;
    }
    if (typeof t == "string") return e.find(({ isSupported: r }) => r?.({ filepath: t }));
  }
}
function ta$1(e, t) {
  let r = _n$1(0, e.plugins).flatMap((i) => i.languages ?? []);
  return (Zs(r, t.language) ?? vn$1(r, t.physicalFile) ?? vn$1(r, t.file) ?? Tn$1(r, t.physicalFile) ?? Tn$1(r, t.file) ?? ea$1?.(r, t.physicalFile))?.parsers[0];
}
var At = ta$1;
var yt = /* @__PURE__ */ Symbol.for("PRETTIER_IS_FRONT_MATTER");
function ra$1(e) {
  return !!e?.[yt];
}
var le$2 = ra$1;
var Xe$1 = 3;
function na$1(e) {
  let t = e.slice(0, Xe$1);
  if (t !== "---" && t !== "+++") return;
  let r = e.indexOf(`
`, Xe$1);
  if (r === -1) return;
  let n = e.slice(Xe$1, r).trim(), i = e.indexOf(`
${t}`, r), s = n;
  if (s || (s = t === "+++" ? "toml" : "yaml"), i === -1 && t === "---" && s === "yaml" && (i = e.indexOf(`
...`, r)), i === -1) return;
  let a = i + 1 + Xe$1, o = e.charAt(a + 1);
  if (!/\s?/u.test(o)) return;
  let c = e.slice(0, a), u;
  return { language: s, explicitLanguage: n || null, value: e.slice(r + 1, i), startDelimiter: t, endDelimiter: c.slice(-Xe$1), raw: c, start: { line: 1, column: 0, index: 0 }, end: { index: c.length, get line() {
    return u ?? (u = c.split(`
`)), u.length;
  }, get column() {
    return u ?? (u = c.split(`
`)), F(0, u, -1).length;
  } }, [yt]: true };
}
function ia$1(e) {
  let t = na$1(e);
  return t ? { frontMatter: t, get content() {
    let { raw: r } = t;
    return w$1(0, r, /[^\n]/gu, " ") + e.slice(r.length);
  } } : { content: e };
}
var pr$2 = ia$1;
var bn$1 = "inline", hr$1 = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", details: "block", summary: "block", marquee: "inline-block", select: "inline-block", source: "block", track: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", option: "block", optgroup: "block" }, wn$1 = "normal", mr$1 = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
function sa$1(e) {
  return e.kind === "element" && !e.hasExplicitNamespace && !["html", "svg"].includes(e.namespace);
}
var ce$1 = sa$1;
var aa = (e) => w$1(0, e, /^[\t\f\r ]*\n/gu, ""), fr$1 = (e) => aa(x$1.trimEnd(e)), kn$1 = (e) => {
  let t = e, r = x$1.getLeadingWhitespace(t);
  r && (t = t.slice(r.length));
  let n = x$1.getTrailingWhitespace(t);
  return n && (t = t.slice(0, -n.length)), { leadingWhitespace: r, trailingWhitespace: n, text: t };
};
function xt(e, t) {
  return !!(e.kind === "ieConditionalComment" && e.lastChild && !e.lastChild.isSelfClosing && !e.lastChild.endSourceSpan || e.kind === "ieConditionalComment" && !e.complete || ue$1(e) && e.children.some((r) => r.kind !== "text" && r.kind !== "interpolation") || Pt(e, t) && !H$1(e, t) && e.kind !== "interpolation");
}
function pe(e) {
  return e.kind === "attribute" || !e.parent || !e.prev ? false : oa$1(e.prev);
}
function oa$1(e) {
  return e.kind === "comment" && e.value.trim() === "prettier-ignore";
}
function O$1(e) {
  return e.kind === "text" || e.kind === "comment";
}
function H$1(e, t) {
  return e.kind === "element" && (e.fullName === "script" || e.fullName === "style" || e.fullName === "svg:style" || e.fullName === "svg:script" || e.fullName === "mj-style" && t.parser === "mjml" || ce$1(e) && (e.name === "script" || e.name === "style"));
}
function An$1(e, t) {
  return e.children && !H$1(e, t);
}
function yn$1(e, t) {
  return H$1(e, t) || e.kind === "interpolation" || dr$1(e);
}
function dr$1(e) {
  return Fn$1(e).startsWith("pre");
}
function xn$1(e, t) {
  let r = n();
  if (r && !e.prev && e.parent?.tagDefinition?.ignoreFirstLf) return e.kind === "interpolation";
  return r;
  function n() {
    return le$2(e) || e.kind === "angularControlFlowBlock" ? false : (e.kind === "text" || e.kind === "interpolation") && e.prev && (e.prev.kind === "text" || e.prev.kind === "interpolation") ? true : !e.parent || e.parent.cssDisplay === "none" ? false : ue$1(e.parent) ? true : !(!e.prev && (e.parent.kind === "root" || ue$1(e) && e.parent || H$1(e.parent, t) || Je$1(e.parent, t) || !ma$1(e.parent.cssDisplay)) || e.prev && !ga$1(e.prev.cssDisplay));
  }
}
function Nn$1(e, t) {
  return le$2(e) || e.kind === "angularControlFlowBlock" ? false : (e.kind === "text" || e.kind === "interpolation") && e.next && (e.next.kind === "text" || e.next.kind === "interpolation") ? true : !e.parent || e.parent.cssDisplay === "none" ? false : ue$1(e.parent) ? true : !(!e.next && (e.parent.kind === "root" || ue$1(e) && e.parent || H$1(e.parent, t) || Je$1(e.parent, t) || !fa$1(e.parent.cssDisplay)) || e.next && !da$1(e.next.cssDisplay));
}
function Ln$1(e, t) {
  return _a$1(e.cssDisplay) && !H$1(e, t);
}
function Ke(e) {
  return le$2(e) || e.next && e.sourceSpan.end && e.sourceSpan.end.line + 1 < e.next.sourceSpan.start.line;
}
function Pn$1(e) {
  return gr$1(e) || e.kind === "element" && e.children.length > 0 && (["body", "script", "style"].includes(e.name) || e.children.some((t) => ca$1(t))) || e.firstChild && e.firstChild === e.lastChild && e.firstChild.kind !== "text" && Dn$1(e.firstChild) && (!e.lastChild.isTrailingSpaceSensitive || Rn$1(e.lastChild));
}
function gr$1(e) {
  return e.kind === "element" && e.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e.name) || e.cssDisplay.startsWith("table") && e.cssDisplay !== "table-cell");
}
function Nt(e) {
  return In$1(e) || e.prev && la$1(e.prev) || On$1(e);
}
function la$1(e) {
  return In$1(e) || e.kind === "element" && e.fullName === "br" || On$1(e);
}
function On$1(e) {
  return Dn$1(e) && Rn$1(e);
}
function Dn$1(e) {
  return e.hasLeadingSpaces && (e.prev ? e.prev.sourceSpan.end.line < e.sourceSpan.start.line : e.parent.kind === "root" || e.parent.startSourceSpan.end.line < e.sourceSpan.start.line);
}
function Rn$1(e) {
  return e.hasTrailingSpaces && (e.next ? e.next.sourceSpan.start.line > e.sourceSpan.end.line : e.parent.kind === "root" || e.parent.endSourceSpan && e.parent.endSourceSpan.start.line > e.sourceSpan.end.line);
}
function In$1(e) {
  switch (e.kind) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return true;
    case "element":
      return ["script", "select"].includes(e.name);
  }
  return false;
}
function Lt$1(e) {
  return e.lastChild ? Lt$1(e.lastChild) : e;
}
function ca$1(e) {
  return e.children?.some((t) => t.kind !== "text");
}
function Mn$1(e) {
  if (e) switch (e) {
    case "module":
    case "text/javascript":
    case "text/babel":
    case "text/jsx":
    case "application/javascript":
      return "babel";
    case "application/x-typescript":
      return "typescript";
    case "text/markdown":
      return "markdown";
    case "text/html":
      return "html";
    case "text/x-handlebars-template":
      return "glimmer";
    default:
      if (e.endsWith("json") || e.endsWith("importmap") || e === "speculationrules") return "json";
  }
}
function ua$1(e, t) {
  let { name: r, attrMap: n } = e;
  if (r !== "script" || Object.prototype.hasOwnProperty.call(n, "src")) return;
  let { type: i, lang: s } = e.attrMap;
  return !s && !i ? "babel" : At(t, { language: s }) ?? Mn$1(i);
}
function pa$1(e, t) {
  if (!Pt(e, t)) return;
  let { attrMap: r } = e;
  if (Object.prototype.hasOwnProperty.call(r, "src")) return;
  let { type: n, lang: i } = r;
  return At(t, { language: i }) ?? Mn$1(n);
}
function ha$1(e, t) {
  if (e.name === "style") {
    let { lang: r } = e.attrMap;
    return r ? At(t, { language: r }) : "css";
  }
  if (e.name === "mj-style" && t.parser === "mjml") return "css";
}
function _r$1(e, t) {
  return ua$1(e, t) ?? ha$1(e, t) ?? pa$1(e, t);
}
function Qe$1(e) {
  return e === "block" || e === "list-item" || e.startsWith("table");
}
function ma$1(e) {
  return !Qe$1(e) && e !== "inline-block";
}
function fa$1(e) {
  return !Qe$1(e) && e !== "inline-block";
}
function da$1(e) {
  return !Qe$1(e);
}
function ga$1(e) {
  return !Qe$1(e);
}
function _a$1(e) {
  return !Qe$1(e) && e !== "inline-block";
}
function ue$1(e) {
  return Fn$1(e).startsWith("pre");
}
function Sa$1(e, t) {
  let r = e;
  for (; r; ) {
    if (t(r)) return true;
    r = r.parent;
  }
  return false;
}
function Bn$1(e, t) {
  if (he$3(e, t)) return "block";
  if (e.prev?.kind === "comment") {
    let n = e.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/u);
    if (n) return n[1];
  }
  let r = false;
  if (e.kind === "element" && e.namespace === "svg") if (Sa$1(e, (n) => n.fullName === "svg:foreignObject")) r = true;
  else return e.name === "svg" ? "inline-block" : "block";
  switch (t.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      if (e.kind === "element" && (!e.namespace || r || ce$1(e)) && Object.prototype.hasOwnProperty.call(hr$1, e.name)) return hr$1[e.name];
  }
  return bn$1;
}
function Fn$1(e) {
  return e.kind === "element" && (!e.namespace || ce$1(e)) && Object.prototype.hasOwnProperty.call(mr$1, e.name) ? mr$1[e.name] : wn$1;
}
function Sr$1(e) {
  return w$1(0, w$1(0, e, "&apos;", "'"), "&quot;", '"');
}
function b$1(e) {
  return Sr$1(e.value);
}
var Ea$1 = /* @__PURE__ */ new Set(["template", "style", "script"]);
function Je$1(e, t) {
  return he$3(e, t) && !Ea$1.has(e.fullName);
}
function he$3(e, t) {
  return t.parser === "vue" && e.kind === "element" && e.parent.kind === "root" && e.fullName.toLowerCase() !== "html";
}
function Pt(e, t) {
  return he$3(e, t) && (Je$1(e, t) || e.attrMap.lang && e.attrMap.lang !== "html");
}
function qn(e) {
  let t = e.fullName;
  return t.charAt(0) === "#" || t === "slot-scope" || t === "v-slot" || t.startsWith("v-slot:");
}
function Hn$1(e, t) {
  let r = e.parent;
  if (!he$3(r, t)) return false;
  let n = r.fullName, i = e.fullName;
  return n === "script" && i === "setup" || n === "style" && i === "vars";
}
function Ot(e, t = e.value) {
  return e.parent.isWhitespaceSensitive ? e.parent.isIndentationSensitive ? L$1(t) : L$1(x$1.dedentString(fr$1(t)), v$1) : q$1(_$1, x$1.split(t));
}
function Dt$1(e, t) {
  return he$3(e, t) && e.name === "script";
}
function Ca$1(e) {
  let { valueSpan: t, value: r } = e;
  return t.end.offset - t.start.offset === r.length + 2;
}
function Rt(e, t) {
  if (Ca$1(e)) return false;
  let { value: r } = e;
  return /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(r) || t.parser === "lwc" && r.startsWith("{") && r.endsWith("}");
}
var Vn$1 = /\{\{(.+?)\}\}/su, Un$1 = ({ node: { value: e } }) => Vn$1.test(e);
async function Wn$1(e, t, r) {
  let n = b$1(r.node), i = [];
  for (let [s, a] of n.split(Vn$1).entries()) if (s % 2 === 0) i.push(L$1(a));
  else try {
    i.push(C(["{{", y([_$1, await A(a, e, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), _$1, "}}"]));
  } catch {
    i.push("{{", L$1(a), "}}");
  }
  return i;
}
var Er$1 = (e) => (t, r, n) => A(b$1(n.node), t, { parser: e }, W$1), va$1 = [{ test(e) {
  let t = e.node.fullName;
  return t.startsWith("(") && t.endsWith(")") || t.startsWith("on-");
}, print: Er$1("__ng_action") }, { test(e) {
  let t = e.node.fullName;
  return t.startsWith("[") && t.endsWith("]") || /^bind(?:on)?-/u.test(t) || /^ng-(?:if|show|hide|class|style)$/u.test(t);
}, print: Er$1("__ng_binding") }, { test: (e) => e.node.fullName.startsWith("*"), print: Er$1("__ng_directive") }, { test: (e) => /^i18n(?:-.+)?$/u.test(e.node.fullName), print: Ta$1 }, { test: Un$1, print: Wn$1 }].map(({ test: e, print: t }) => ({ test: (r, n) => n.parser === "angular" && e(r), print: t }));
function Ta$1(e, t, { node: r }) {
  let n = b$1(r);
  return K$1(kt$1(Ot(r, n.trim())), !n.includes("@@"));
}
var Gn$1 = va$1;
var $n$1 = ({ node: e }, t) => !t.parentParser && e.fullName === "class" && !e.value.includes("{{"), zn$1 = (e, t, r) => b$1(r.node).trim().split(/\s+/u).join(" ");
var Cr$1 = ["onabort", "onafterprint", "onauxclick", "onbeforeinput", "onbeforematch", "onbeforeprint", "onbeforetoggle", "onbeforeunload", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncommand", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onformdata", "onhashchange", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onlanguagechange", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onmessage", "onmessageerror", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onoffline", "ononline", "onpagehide", "onpagereveal", "onpageshow", "onpageswap", "onpaste", "onpause", "onplay", "onplaying", "onpopstate", "onprogress", "onratechange", "onrejectionhandled", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onslotchange", "onstalled", "onstorage", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "onunhandledrejection", "onunload", "onvolumechange", "onwaiting", "onwheel"];
var wa$1 = new Set(Cr$1), Yn$1 = ({ node: e }, t) => wa$1.has(e.fullName) && !t.parentParser && !e.value.includes("{{"), jn$1 = (e, t, r) => A(b$1(r.node), e, { parser: "babel", __isHtmlInlineEventHandler: true }, () => false);
function ka$1(e) {
  let t = [];
  for (let r of e.split(";")) {
    if (r = x$1.trim(r), !r) continue;
    let [n, ...i] = x$1.split(r);
    t.push({ name: n, value: i });
  }
  return t;
}
var Xn = ka$1;
var Kn$1 = ({ node: e }, t) => e.fullName === "allow" && !t.parentParser && e.parent.fullName === "iframe" && !e.value.includes("{{");
function Qn(e, t, r) {
  let { node: n } = r, i = Xn(b$1(n));
  return i.length === 0 ? [""] : K$1(i.map(({ name: s, value: a }, o) => [[s, ...a].join(" "), o === i.length - 1 ? X$1(";") : [";", _$1]]));
}
function Jn$1(e) {
  return e === "	" || e === `
` || e === "\f" || e === "\r" || e === " ";
}
var Aa = /^[ \t\n\r\u000c]+/, ya$1 = /^[, \t\n\r\u000c]+/, xa$1 = /^[^ \t\n\r\u000c]+/, Na$1 = /[,]+$/, Zn$1 = /^\d+$/, La$1 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
function Pa$1(e) {
  let t = e.length, r, n, i, s, a, o = 0, c;
  function u(m) {
    let g, E = m.exec(e.substring(o));
    if (E) return [g] = E, o += g.length, g;
  }
  let p = [];
  for (; ; ) {
    if (u(ya$1), o >= t) {
      if (p.length === 0) throw new Error("Must contain one or more image candidate strings.");
      return p;
    }
    c = o, r = u(xa$1), n = [], r.slice(-1) === "," ? (r = r.replace(Na$1, ""), S2()) : d();
  }
  function d() {
    for (u(Aa), i = "", s = "in descriptor"; ; ) {
      if (a = e.charAt(o), s === "in descriptor") if (Jn$1(a)) i && (n.push(i), i = "", s = "after descriptor");
      else if (a === ",") {
        o += 1, i && n.push(i), S2();
        return;
      } else if (a === "(") i += a, s = "in parens";
      else if (a === "") {
        i && n.push(i), S2();
        return;
      } else i += a;
      else if (s === "in parens") if (a === ")") i += a, s = "in descriptor";
      else if (a === "") {
        n.push(i), S2();
        return;
      } else i += a;
      else if (s === "after descriptor" && !Jn$1(a)) if (a === "") {
        S2();
        return;
      } else s = "in descriptor", o -= 1;
      o += 1;
    }
  }
  function S2() {
    let m = false, g, E, P2, z2, oe2 = {}, ee2, gt3, ke2, Ge2, nr2;
    for (z2 = 0; z2 < n.length; z2++) ee2 = n[z2], gt3 = ee2[ee2.length - 1], ke2 = ee2.substring(0, ee2.length - 1), Ge2 = parseInt(ke2, 10), nr2 = parseFloat(ke2), Zn$1.test(ke2) && gt3 === "w" ? ((g || E) && (m = true), Ge2 === 0 ? m = true : g = Ge2) : La$1.test(ke2) && gt3 === "x" ? ((g || E || P2) && (m = true), nr2 < 0 ? m = true : E = nr2) : Zn$1.test(ke2) && gt3 === "h" ? ((P2 || E) && (m = true), Ge2 === 0 ? m = true : P2 = Ge2) : m = true;
    if (!m) oe2.source = { value: r, startOffset: c }, g && (oe2.width = { value: g }), E && (oe2.density = { value: E }), P2 && (oe2.height = { value: P2 }), p.push(oe2);
    else throw new Error(`Invalid srcset descriptor found in "${e}" at "${ee2}".`);
  }
}
var ei$1 = Pa$1;
var ti$1 = (e) => e.node.fullName === "srcset" && (e.parent.fullName === "img" || e.parent.fullName === "source"), ri$1 = { width: "w", height: "h", density: "x" }, Oa$1 = Object.keys(ri$1);
function ni$2(e, t, r) {
  let n = b$1(r.node), i = ei$1(n), s = Oa$1.filter((m) => i.some((g) => Object.prototype.hasOwnProperty.call(g, m)));
  if (s.length > 1) throw new Error("Mixed descriptor in srcset is not supported");
  let [a] = s, o = ri$1[a], c = i.map((m) => m.source.value), u = Math.max(...c.map((m) => m.length)), p = i.map((m) => m[a] ? String(m[a].value) : ""), d = p.map((m) => {
    let g = m.indexOf(".");
    return g === -1 ? m.length : g;
  }), S2 = Math.max(...d);
  return K$1(q$1([",", _$1], c.map((m, g) => {
    let E = [m], P2 = p[g];
    if (P2) {
      let z2 = u - m.length + 1, oe2 = S2 - d[g], ee2 = " ".repeat(z2 + oe2);
      E.push(X$1(ee2, " "), P2 + o);
    }
    return E;
  })));
}
var ii$2 = ({ node: e }, t) => e.fullName === "style" && !t.parentParser && !e.value.includes("{{"), si$1 = async (e, t, r) => K$1(await e(b$1(r.node), { parser: "css", __isHTMLStyleAttribute: true }));
var vr$1 = /* @__PURE__ */ new WeakMap();
function Da$1(e, t) {
  let { root: r } = e;
  return vr$1.has(r) || vr$1.set(r, r.children.some((n) => Dt$1(n, t) && ["ts", "typescript"].includes(n.attrMap.lang))), vr$1.get(r);
}
var G$1 = Da$1;
function ai$1(e, t, r) {
  let n = b$1(r.node);
  return A(`type T<${n}> = any`, e, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: true }, W$1);
}
function oi$1(e, t, r, n) {
  let i = b$1(r.node), s = G$1(r, n) ? "babel-ts" : "babel";
  return A(`function _(${i}) {}`, e, { parser: s, __isVueBindings: true });
}
async function li$1(e, t, r, n) {
  let i = b$1(r.node), { left: s, operator: a, right: o } = Ra$1(i), c = G$1(r, n);
  return [C(await A(`function _(${s}) {}`, e, { parser: c ? "babel-ts" : "babel", __isVueForBindingLeft: true })), " ", a, " ", await A(o, e, { parser: c ? "__ts_expression" : "__js_expression" })];
}
function Ra$1(e) {
  let t = /(.*?)\s+(in|of)\s+(.*)/su, r = /,([^,\]}]*)(?:,([^,\]}]*))?$/u, n = /^\(|\)$/gu, i = e.match(t);
  if (!i) return;
  let s = { for: i[3].trim() };
  if (!s.for) return;
  let a = w$1(0, i[1].trim(), n, ""), o = a.match(r);
  o ? (s.alias = a.replace(r, ""), s.iterator1 = o[1].trim(), o[2] && (s.iterator2 = o[2].trim())) : s.alias = a;
  let c = [s.alias, s.iterator1, s.iterator2];
  if (!c.some((u, p) => !u && (p === 0 || c.slice(p + 1).some(Boolean)))) return { left: c.filter(Boolean).join(","), operator: i[2], right: s.for };
}
var Ia$1 = [{ test: (e) => e.node.fullName === "v-for", print: li$1 }, { test: (e, t) => e.node.fullName === "generic" && Dt$1(e.parent, t), print: ai$1 }, { test: ({ node: e }, t) => qn(e) || Hn$1(e, t), print: oi$1 }, { test(e) {
  let t = e.node.fullName;
  return t.startsWith("@") || t.startsWith("v-on:");
}, print: Ma$1 }, { test(e) {
  let t = e.node.fullName;
  return t.startsWith(":") || t.startsWith(".") || t.startsWith("v-bind:");
}, print: Ba$1 }, { test: (e) => e.node.fullName.startsWith("v-"), print: ci$1 }].map(({ test: e, print: t }) => ({ test: (r, n) => n.parser === "vue" && e(r, n), print: t }));
async function Ma$1(e, t, r, n) {
  try {
    return await ci$1(e, t, r, n);
  } catch (a) {
    if (a.cause?.code !== "BABEL_PARSER_SYNTAX_ERROR") throw a;
  }
  let i = b$1(r.node), s = G$1(r, n) ? "__vue_ts_event_binding" : "__vue_event_binding";
  return A(i, e, { parser: s }, W$1);
}
function Ba$1(e, t, r, n) {
  let i = b$1(r.node), s = G$1(r, n) ? "__vue_ts_expression" : "__vue_expression";
  return A(i, e, { parser: s }, W$1);
}
function ci$1(e, t, r, n) {
  let i = b$1(r.node), s = G$1(r, n) ? "__ts_expression" : "__js_expression";
  return A(i, e, { parser: s }, W$1);
}
var ui$1 = Ia$1;
var Fa$1 = [{ test: ti$1, print: ni$2 }, { test: ii$2, print: si$1 }, { test: Yn$1, print: jn$1 }, { test: $n$1, print: zn$1 }, { test: Kn$1, print: Qn }, ...ui$1, ...Gn$1].map(({ test: e, print: t }) => ({ test: e, print: Ha$1(t) }));
function qa$1(e, t) {
  let { node: r } = e, { value: n } = r;
  if (n) return Rt(r, t) ? [r.rawName, "=", n] : Fa$1.find(({ test: i }) => i(e, t))?.print;
}
function Ha$1(e) {
  return async (t, r, n, i) => {
    let s = await e(t, r, n, i);
    if (s) return s = ar$1(s, (a) => typeof a == "string" ? w$1(0, a, '"', "&quot;") : a), [n.node.rawName, '="', C(s), '"'];
  };
}
var pi$1 = qa$1;
var Q = (e) => e.sourceSpan.start.offset, te$1 = (e) => e.sourceSpan.end.offset;
function Ze$1(e, t) {
  return [e.isSelfClosing ? "" : Va$1(e, t), me$1(e, t)];
}
function Va$1(e, t) {
  return e.lastChild && ge$2(e.lastChild) ? "" : [Ua(e, t), It$1(e, t)];
}
function me$1(e, t) {
  return (e.next ? $$1(e.next) : de$1(e.parent)) ? "" : [fe$1(e, t), V$1(e, t)];
}
function Ua(e, t) {
  return de$1(e) ? fe$1(e.lastChild, t) : "";
}
function V$1(e, t) {
  return ge$2(e) ? It$1(e.parent, t) : et$1(e) ? Mt$1(e.next, t) : "";
}
function It$1(e, t) {
  if (mi(e, t)) return "";
  switch (e.kind) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (e.hasHtmComponentClosingTag) return "<//";
    default:
      return `</${e.rawName}`;
  }
}
function fe$1(e, t) {
  if (mi(e, t)) return "";
  switch (e.kind) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "angularIcuExpression":
      return "}";
    case "element":
      if (e.isSelfClosing) return "/>";
    default:
      return ">";
  }
}
function mi(e, t) {
  return !e.isSelfClosing && !e.endSourceSpan && (pe(e) || xt(e.parent, t));
}
function $$1(e) {
  return e.prev && e.prev.kind !== "docType" && e.kind !== "angularControlFlowBlock" && !O$1(e.prev) && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces;
}
function de$1(e) {
  return e.lastChild?.isTrailingSpaceSensitive && !e.lastChild.hasTrailingSpaces && !O$1(Lt$1(e.lastChild)) && !ue$1(e);
}
function ge$2(e) {
  return !e.next && !e.hasTrailingSpaces && e.isTrailingSpaceSensitive && O$1(Lt$1(e));
}
function et$1(e) {
  return e.next && !O$1(e.next) && O$1(e) && e.isTrailingSpaceSensitive && !e.hasTrailingSpaces;
}
function Wa$1(e) {
  let t = e.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/su);
  return t ? t[1] ? t[1].split(/\s+/u) : true : false;
}
function tt$1(e) {
  return !e.prev && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces;
}
function Ga$1(e, t, r) {
  let { node: n } = e;
  if (!Re$2(n.attrs)) return n.isSelfClosing ? " " : "";
  let i = n.prev?.kind === "comment" && Wa$1(n.prev.value), s = typeof i == "boolean" ? () => i : Array.isArray(i) ? (d) => i.includes(d.rawName) : () => false, a = e.map(({ node: d }) => s(d) ? L$1(t.originalText.slice(Q(d), te$1(d))) : r(), "attrs"), o = n.kind === "element" && n.fullName === "script" && n.attrs.length === 1 && n.attrs[0].fullName === "src" && n.children.length === 0, u = t.singleAttributePerLine && n.attrs.length > 1 && !he$3(n, t) ? v$1 : _$1, p = [y([o ? " " : _$1, q$1(u, a)])];
  return n.firstChild && tt$1(n.firstChild) || n.isSelfClosing && de$1(n.parent) || o ? p.push(n.isSelfClosing ? " " : "") : p.push(t.bracketSameLine ? n.isSelfClosing ? " " : "" : n.isSelfClosing ? _$1 : k$1), p;
}
function $a$1(e) {
  return e.firstChild && tt$1(e.firstChild) ? "" : Bt(e);
}
function rt$1(e, t, r) {
  let { node: n } = e;
  return [_e$1(n, t), Ga$1(e, t, r), n.isSelfClosing ? "" : $a$1(n)];
}
function _e$1(e, t) {
  return e.prev && et$1(e.prev) ? "" : [U$1(e, t), Mt$1(e, t)];
}
function U$1(e, t) {
  return tt$1(e) ? Bt(e.parent) : $$1(e) ? fe$1(e.prev, t) : "";
}
var hi = "<!doctype";
function Mt$1(e, t) {
  switch (e.kind) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${e.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType": {
      if (e.value === "html") {
        let { filepath: n } = t;
        if (n && /\.html?$/u.test(n)) return hi;
      }
      let r = Q(e);
      return t.originalText.slice(r, r + hi.length);
    }
    case "angularIcuExpression":
      return "{";
    case "element":
      if (e.condition) return `<!--[if ${e.condition}]><!--><${e.rawName}`;
    default:
      return `<${e.rawName}`;
  }
}
function Bt(e) {
  switch (e.kind) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (e.condition) return "><!--<![endif]-->";
    default:
      return ">";
  }
}
function za$1(e, t) {
  if (!e.endSourceSpan) return "";
  let r = e.startSourceSpan.end.offset;
  e.firstChild && tt$1(e.firstChild) && (r -= Bt(e).length);
  let n = e.endSourceSpan.start.offset;
  return e.lastChild && ge$2(e.lastChild) ? n += It$1(e, t).length : de$1(e) && (n -= fe$1(e.lastChild, t).length), t.originalText.slice(r, n);
}
var Ft$1 = za$1;
var Ya$1 = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function ja$1(e, t) {
  let { node: r } = e;
  switch (r.kind) {
    case "element":
      if (H$1(r, t) || r.kind === "interpolation") return;
      if (!r.isSelfClosing && Pt(r, t)) {
        let n = _r$1(r, t);
        return n ? async (i, s) => {
          let a = Ft$1(r, t), o = /^\s*$/u.test(a), c = "";
          return o || (c = await i(fr$1(a), { parser: n, __embeddedInHtml: true }), o = c === ""), [U$1(r, t), C(rt$1(e, t, s)), o ? "" : v$1, c, o ? "" : v$1, Ze$1(r, t), V$1(r, t)];
        } : void 0;
      }
      break;
    case "text":
      if (H$1(r.parent, t)) {
        let n = _r$1(r.parent, t);
        if (n) return async (i) => {
          let s = n === "markdown" ? x$1.dedentString(r.value.replace(/^[^\S\n]*\n/u, "")) : r.value, a = { parser: n, __embeddedInHtml: true };
          if (t.parser === "html" && n === "babel") {
            let o = "script", { attrMap: c } = r.parent;
            c && (c.type === "module" || (c.type === "text/babel" || c.type === "text/jsx") && c["data-type"] === "module") && (o = "module"), a.__babelSourceType = o;
          }
          return [j$1, U$1(r, t), await i(s, a), V$1(r, t)];
        };
      } else if (r.parent.kind === "interpolation") return async (n) => {
        let i = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
        return t.parser === "angular" ? i.parser = "__ng_interpolation" : t.parser === "vue" ? i.parser = G$1(e, t) ? "__vue_ts_expression" : "__vue_expression" : i.parser = "__js_expression", [y([_$1, await n(r.value, i)]), r.parent.next && $$1(r.parent.next) ? " " : _$1];
      };
      break;
    case "attribute":
      return pi$1(e, t);
    case "angularControlFlowBlockParameters":
      return Ya$1.has(e.parent.name) ? gn$1 : void 0;
    case "angularLetDeclarationInitializer":
      return (n) => A(r.value, n, { parser: "__ng_binding", __isInHtmlAttribute: false });
  }
}
var fi$1 = ja$1;
var nt$1 = null;
function it$2(e) {
  if (nt$1 !== null && typeof nt$1.property) {
    let t = nt$1;
    return nt$1 = it$2.prototype = null, t;
  }
  return nt$1 = it$2.prototype = e ?? /* @__PURE__ */ Object.create(null), new it$2();
}
var Xa$1 = 10;
for (let e = 0; e <= Xa$1; e++) it$2();
function Tr$1(e) {
  return it$2(e);
}
function Ka$1(e, t = "type") {
  Tr$1(e);
  function r(n) {
    let i = n[t], s = e[i];
    if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: n });
    return s;
  }
  return r;
}
var di = Ka$1;
var R$1 = [["children"], []], gi = { root: R$1[0], element: ["attrs", "children"], ieConditionalComment: R$1[0], ieConditionalStartComment: R$1[1], ieConditionalEndComment: R$1[1], interpolation: R$1[0], text: R$1[0], docType: R$1[1], comment: R$1[1], attribute: R$1[1], cdata: R$1[1], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: R$1[0], angularControlFlowBlockParameter: R$1[1], angularLetDeclaration: ["init"], angularLetDeclarationInitializer: R$1[1], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] };
var Qa$1 = di(gi, "kind"), _i = Qa$1;
var Si = "format";
var Ei = /^\s*<!--\s*@(?:noformat|noprettier)\s*-->/u, Ci = /^\s*<!--\s*@(?:format|prettier)\s*-->/u;
var vi = (e) => Ci.test(e), Ti = (e) => Ei.test(e), bi = (e) => `<!-- @${Si} -->

${e}`;
var wi = /* @__PURE__ */ new Map([["if", /* @__PURE__ */ new Set(["else if", "else"])], ["else if", /* @__PURE__ */ new Set(["else if", "else"])], ["for", /* @__PURE__ */ new Set(["empty"])], ["defer", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["placeholder", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["error", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["loading", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])]]);
function ki(e) {
  let t = te$1(e);
  return e.kind === "element" && !e.endSourceSpan && Re$2(e.children) ? Math.max(t, ki(F(0, e.children, -1))) : t;
}
function st$1(e, t, r) {
  let n = e.node;
  if (pe(n)) {
    let i = ki(n);
    return [U$1(n, t), L$1(x$1.trimEnd(t.originalText.slice(Q(n) + (n.prev && et$1(n.prev) ? Mt$1(n).length : 0), i - (n.next && $$1(n.next) ? fe$1(n, t).length : 0)))), V$1(n, t)];
  }
  return r();
}
function qt$1(e, t) {
  return O$1(e) && O$1(t) ? e.isTrailingSpaceSensitive ? e.hasTrailingSpaces ? Nt(t) ? v$1 : _$1 : "" : Nt(t) ? v$1 : k$1 : et$1(e) && (pe(t) || t.firstChild || t.isSelfClosing || t.kind === "element" && t.attrs.length > 0) || e.kind === "element" && e.isSelfClosing && $$1(t) ? "" : !t.isLeadingSpaceSensitive || Nt(t) || $$1(t) && e.lastChild && ge$2(e.lastChild) && e.lastChild.lastChild && ge$2(e.lastChild.lastChild) ? v$1 : t.hasLeadingSpaces ? _$1 : k$1;
}
function Ie$1(e, t, r) {
  let { node: n } = e;
  if (gr$1(n)) return [j$1, ...e.map(() => {
    let s = e.node, a = s.prev ? qt$1(s.prev, s) : "";
    return [a ? [a, Ke(s.prev) ? v$1 : ""] : "", st$1(e, t, r)];
  }, "children")];
  let i = n.children.map(() => /* @__PURE__ */ Symbol(""));
  return e.map(({ node: s, index: a }) => {
    if (O$1(s)) {
      if (s.prev && O$1(s.prev)) {
        let m = qt$1(s.prev, s);
        if (m) return Ke(s.prev) ? [v$1, v$1, st$1(e, t, r)] : [m, st$1(e, t, r)];
      }
      return st$1(e, t, r);
    }
    let o = [], c = [], u = [], p = [], d = s.prev ? qt$1(s.prev, s) : "", S2 = s.next ? qt$1(s, s.next) : "";
    return d && (Ke(s.prev) ? o.push(v$1, v$1) : d === v$1 ? o.push(v$1) : O$1(s.prev) ? c.push(d) : c.push(X$1("", k$1, { groupId: i[a - 1] }))), S2 && (Ke(s) ? O$1(s.next) && p.push(v$1, v$1) : S2 === v$1 ? O$1(s.next) && p.push(v$1) : u.push(S2)), [...o, C([...c, C([st$1(e, t, r), ...u], { id: i[a] })]), ...p];
  }, "children");
}
function Ai(e, t, r) {
  let { node: n } = e, i = [];
  Ja$1(e) && i.push("} "), i.push("@", n.name), n.parameters && i.push(" (", C(r("parameters")), ")"), i.push(" {");
  let s = yi(n);
  return n.children.length > 0 ? (n.firstChild.hasLeadingSpaces = true, n.lastChild.hasTrailingSpaces = true, i.push(y([v$1, Ie$1(e, t, r)])), s && i.push(v$1, "}")) : s && i.push("}"), C(i, { shouldBreak: true });
}
function yi(e) {
  return !(e.next?.kind === "angularControlFlowBlock" && wi.get(e.name)?.has(e.next.name));
}
function Ja$1(e) {
  let { previous: t } = e;
  return t?.kind === "angularControlFlowBlock" && !pe(t) && !yi(t);
}
function xi$1(e, t, r) {
  return [y([k$1, q$1([";", _$1], e.map(r, "children"))]), k$1];
}
function Ni(e, t, r) {
  let { node: n } = e;
  return [_e$1(n, t), C([n.switchValue.trim(), ", ", n.type, n.cases.length > 0 ? [",", y([_$1, q$1(_$1, e.map(r, "cases"))])] : "", k$1]), me$1(n, t)];
}
function Li(e, t, r) {
  let { node: n } = e;
  return [n.value, " {", C([y([k$1, e.map(({ node: i, isLast: s }) => {
    let a = [r()];
    return i.kind === "text" && (i.hasLeadingSpaces && a.unshift(_$1), i.hasTrailingSpaces && !s && a.push(_$1)), a;
  }, "expression")]), k$1]), "}"];
}
function Pi$1(e, t, r) {
  let { node: n } = e;
  if (xt(n, t)) return [U$1(n, t), C(rt$1(e, t, r)), L$1(Ft$1(n, t)), ...Ze$1(n, t), V$1(n, t)];
  let i = n.children.length === 1 && (n.firstChild.kind === "interpolation" || n.firstChild.kind === "angularIcuExpression") && n.firstChild.isLeadingSpaceSensitive && !n.firstChild.hasLeadingSpaces && n.lastChild.isTrailingSpaceSensitive && !n.lastChild.hasTrailingSpaces, s = /* @__PURE__ */ Symbol("element-attr-group-id"), a = (p) => C([C(rt$1(e, t, r), { id: s }), p, Ze$1(n, t)]), o = (p) => i ? ln(p, { groupId: s }) : (H$1(n, t) || Je$1(n, t)) && n.parent.kind === "root" && t.parser === "vue" && !t.vueIndentScriptAndStyle ? p : y(p), c = () => i ? X$1(k$1, "", { groupId: s }) : n.firstChild.hasLeadingSpaces && n.firstChild.isLeadingSpaceSensitive ? _$1 : n.firstChild.kind === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive ? on$1(k$1) : k$1, u = () => (n.next ? $$1(n.next) : de$1(n.parent)) ? n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? " " : "" : i ? X$1(k$1, "", { groupId: s }) : n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? _$1 : (n.lastChild.kind === "comment" || n.lastChild.kind === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${t.tabWidth * (e.ancestors.length - 1)}}$`, "u").test(n.lastChild.value) ? "" : k$1;
  return n.children.length === 0 ? a(n.hasDanglingSpaces && n.isDanglingSpaceSensitive ? _$1 : "") : a([Pn$1(n) ? j$1 : "", o([c(), Ie$1(e, t, r)]), u()]);
}
var I$1 = (function(e) {
  return e[e.RAW_TEXT = 0] = "RAW_TEXT", e[e.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", e[e.PARSABLE_DATA = 2] = "PARSABLE_DATA", e;
})({});
function at$1(e, t = true) {
  if (e[0] != ":") return [null, e];
  let r = e.indexOf(":", 1);
  if (r === -1) {
    if (t) throw new Error(`Unsupported format "${e}" expecting ":namespace:name"`);
    return [null, e];
  }
  return [e.slice(1, r), e.slice(r + 1)];
}
function br$1(e) {
  return at$1(e)[1] === "ng-container";
}
function wr$2(e) {
  return at$1(e)[1] === "ng-content";
}
function Me$1(e) {
  return e === null ? null : at$1(e)[0];
}
function Se$1(e, t) {
  return e ? `:${e}:${t}` : t;
}
var kr$1 = { name: "custom-elements" }, Ar$1 = { name: "no-errors-schema" }, Ee$1 = (function(e) {
  return e[e.NONE = 0] = "NONE", e[e.HTML = 1] = "HTML", e[e.STYLE = 2] = "STYLE", e[e.SCRIPT = 3] = "SCRIPT", e[e.URL = 4] = "URL", e[e.RESOURCE_URL = 5] = "RESOURCE_URL", e;
})({});
var Za$1 = /-+([a-z0-9])/g;
function Oi(e) {
  return e.replace(Za$1, (...t) => t[1].toUpperCase());
}
var Vt$1;
function yr$1() {
  return Vt$1 || (Vt$1 = {}, Ht$1(Ee$1.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), Ht$1(Ee$1.STYLE, ["*|style"]), Ht$1(Ee$1.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), Ht$1(Ee$1.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), Vt$1;
}
function Ht$1(e, t) {
  for (let r of t) Vt$1[r.toLowerCase()] = e;
}
var Di$1 = class Di {
};
var eo$1 = "boolean", to$1 = "number", ro$1 = "string", no$1 = "object", io$1 = ["[Element]|textContent,%ariaActiveDescendantElement,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColIndexText,%ariaColSpan,%ariaControlsElements,%ariaCurrent,%ariaDescribedByElements,%ariaDescription,%ariaDetailsElements,%ariaDisabled,%ariaErrorMessageElements,%ariaExpanded,%ariaFlowToElements,%ariaHasPopup,%ariaHidden,%ariaInvalid,%ariaKeyShortcuts,%ariaLabel,%ariaLabelledByElements,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaOwnsElements,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowIndexText,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,search,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "selectedcontent^[HTMLElement]|", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "search^[HTMLELement]|", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|", ":math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":math:math^:math:|", ":math:maction^:math:|", ":math:menclose^:math:|", ":math:merror^:math:|", ":math:mfenced^:math:|", ":math:mfrac^:math:|", ":math:mi^:math:|", ":math:mmultiscripts^:math:|", ":math:mn^:math:|", ":math:mo^:math:|", ":math:mover^:math:|", ":math:mpadded^:math:|", ":math:mphantom^:math:|", ":math:mroot^:math:|", ":math:mrow^:math:|", ":math:ms^:math:|", ":math:mspace^:math:|", ":math:msqrt^:math:|", ":math:mstyle^:math:|", ":math:msub^:math:|", ":math:msubsup^:math:|", ":math:msup^:math:|", ":math:mtable^:math:|", ":math:mtd^:math:|", ":math:mtext^:math:|", ":math:mtr^:math:|", ":math:munder^:math:|", ":math:munderover^:math:|", ":math:semantics^:math:|"], Ri = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex", "aria-activedescendant": "ariaActiveDescendantElement", "aria-atomic": "ariaAtomic", "aria-autocomplete": "ariaAutoComplete", "aria-busy": "ariaBusy", "aria-checked": "ariaChecked", "aria-colcount": "ariaColCount", "aria-colindex": "ariaColIndex", "aria-colindextext": "ariaColIndexText", "aria-colspan": "ariaColSpan", "aria-controls": "ariaControlsElements", "aria-current": "ariaCurrent", "aria-describedby": "ariaDescribedByElements", "aria-description": "ariaDescription", "aria-details": "ariaDetailsElements", "aria-disabled": "ariaDisabled", "aria-errormessage": "ariaErrorMessageElements", "aria-expanded": "ariaExpanded", "aria-flowto": "ariaFlowToElements", "aria-haspopup": "ariaHasPopup", "aria-hidden": "ariaHidden", "aria-invalid": "ariaInvalid", "aria-keyshortcuts": "ariaKeyShortcuts", "aria-label": "ariaLabel", "aria-labelledby": "ariaLabelledByElements", "aria-level": "ariaLevel", "aria-live": "ariaLive", "aria-modal": "ariaModal", "aria-multiline": "ariaMultiLine", "aria-multiselectable": "ariaMultiSelectable", "aria-orientation": "ariaOrientation", "aria-owns": "ariaOwnsElements", "aria-placeholder": "ariaPlaceholder", "aria-posinset": "ariaPosInSet", "aria-pressed": "ariaPressed", "aria-readonly": "ariaReadOnly", "aria-required": "ariaRequired", "aria-roledescription": "ariaRoleDescription", "aria-rowcount": "ariaRowCount", "aria-rowindex": "ariaRowIndex", "aria-rowindextext": "ariaRowIndexText", "aria-rowspan": "ariaRowSpan", "aria-selected": "ariaSelected", "aria-setsize": "ariaSetSize", "aria-sort": "ariaSort", "aria-valuemax": "ariaValueMax", "aria-valuemin": "ariaValueMin", "aria-valuenow": "ariaValueNow", "aria-valuetext": "ariaValueText" })), so$1 = Array.from(Ri).reduce((e, [t, r]) => (e.set(t, r), e), /* @__PURE__ */ new Map()), Ii = class extends Di$1 {
  constructor() {
    super(), this._schema = /* @__PURE__ */ new Map(), this._eventSchema = /* @__PURE__ */ new Map(), io$1.forEach((e) => {
      let t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), [n, i] = e.split("|"), s = i.split(","), [a, o] = n.split("^");
      a.split(",").forEach((u) => {
        this._schema.set(u.toLowerCase(), t), this._eventSchema.set(u.toLowerCase(), r);
      });
      let c = o && this._schema.get(o.toLowerCase());
      if (c) {
        for (let [u, p] of c) t.set(u, p);
        for (let u of this._eventSchema.get(o.toLowerCase())) r.add(u);
      }
      s.forEach((u) => {
        if (u.length > 0) switch (u[0]) {
          case "*":
            r.add(u.substring(1));
            break;
          case "!":
            t.set(u.substring(1), eo$1);
            break;
          case "#":
            t.set(u.substring(1), to$1);
            break;
          case "%":
            t.set(u.substring(1), no$1);
            break;
          default:
            t.set(u, ro$1);
        }
      });
    });
  }
  hasProperty(e, t, r) {
    if (r.some((n) => n.name === Ar$1.name)) return true;
    if (e.indexOf("-") > -1) {
      if (br$1(e) || wr$2(e)) return false;
      if (r.some((n) => n.name === kr$1.name)) return true;
    }
    return (this._schema.get(e.toLowerCase()) || this._schema.get("unknown")).has(t);
  }
  hasElement(e, t) {
    return t.some((r) => r.name === Ar$1.name) || e.indexOf("-") > -1 && (br$1(e) || wr$2(e) || t.some((r) => r.name === kr$1.name)) ? true : this._schema.has(e.toLowerCase());
  }
  securityContext(e, t, r) {
    r && (t = this.getMappedPropName(t)), e = e.toLowerCase(), t = t.toLowerCase();
    let n = yr$1()[e + "|" + t];
    return n || (n = yr$1()["*|" + t], n || Ee$1.NONE);
  }
  getMappedPropName(e) {
    return Ri.get(e) ?? e;
  }
  getDefaultComponentElementName() {
    return "ng-component";
  }
  validateProperty(e) {
    return e.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...
If '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: false };
  }
  validateAttribute(e) {
    return e.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: false };
  }
  allKnownElementNames() {
    return Array.from(this._schema.keys());
  }
  allKnownAttributesOfElement(e) {
    let t = this._schema.get(e.toLowerCase()) || this._schema.get("unknown");
    return Array.from(t.keys()).map((r) => so$1.get(r) ?? r);
  }
  allKnownEventsOfElement(e) {
    return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []);
  }
  normalizeAnimationStyleProperty(e) {
    return Oi(e);
  }
  normalizeAnimationStyleValue(e, t, r) {
    let n = "", i = r.toString().trim(), s = null;
    if (ao$1(e) && r !== 0 && r !== "0") if (typeof r == "number") n = "px";
    else {
      let a = r.match(/^[+-]?[\d\.]+([a-z]*)$/);
      a && a[1].length == 0 && (s = `Please provide a CSS unit value for ${t}:${r}`);
    }
    return { error: s, value: i + n };
  }
};
function ao$1(e) {
  switch (e) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent":
      return true;
    default:
      return false;
  }
}
var f = class {
  constructor({ closedByChildren: e, implicitNamespacePrefix: t, contentType: r = I$1.PARSABLE_DATA, closedByParent: n = false, isVoid: i = false, ignoreFirstLf: s = false, preventNamespaceInheritance: a = false, canSelfClose: o = false } = {}) {
    this.closedByChildren = {}, this.closedByParent = false, e && e.length > 0 && e.forEach((c) => this.closedByChildren[c] = true), this.isVoid = i, this.closedByParent = n || i, this.implicitNamespacePrefix = t || null, this.contentType = r, this.ignoreFirstLf = s, this.preventNamespaceInheritance = a, this.canSelfClose = o ?? i;
  }
  isClosedByChild(e) {
    return this.isVoid || e.toLowerCase() in this.closedByChildren;
  }
  getContentType(e) {
    return typeof this.contentType == "object" ? (e === void 0 ? void 0 : this.contentType[e]) ?? this.contentType.default : this.contentType;
  }
}, Mi, ot$1;
function Be$1(e) {
  return ot$1 || (Mi = new f({ canSelfClose: true }), ot$1 = Object.assign(/* @__PURE__ */ Object.create(null), { base: new f({ isVoid: true }), meta: new f({ isVoid: true }), area: new f({ isVoid: true }), embed: new f({ isVoid: true }), link: new f({ isVoid: true }), img: new f({ isVoid: true }), input: new f({ isVoid: true }), param: new f({ isVoid: true }), hr: new f({ isVoid: true }), br: new f({ isVoid: true }), source: new f({ isVoid: true }), track: new f({ isVoid: true }), wbr: new f({ isVoid: true }), p: new f({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true }), thead: new f({ closedByChildren: ["tbody", "tfoot"] }), tbody: new f({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }), tfoot: new f({ closedByChildren: ["tbody"], closedByParent: true }), tr: new f({ closedByChildren: ["tr"], closedByParent: true }), td: new f({ closedByChildren: ["td", "th"], closedByParent: true }), th: new f({ closedByChildren: ["td", "th"], closedByParent: true }), col: new f({ isVoid: true }), svg: new f({ implicitNamespacePrefix: "svg" }), foreignObject: new f({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: true }), math: new f({ implicitNamespacePrefix: "math" }), li: new f({ closedByChildren: ["li"], closedByParent: true }), dt: new f({ closedByChildren: ["dt", "dd"] }), dd: new f({ closedByChildren: ["dt", "dd"], closedByParent: true }), rb: new f({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rt: new f({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rtc: new f({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }), rp: new f({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), optgroup: new f({ closedByChildren: ["optgroup"], closedByParent: true }), option: new f({ closedByChildren: ["option", "optgroup"], closedByParent: true }), pre: new f({ ignoreFirstLf: true }), listing: new f({ ignoreFirstLf: true }), style: new f({ contentType: I$1.RAW_TEXT }), script: new f({ contentType: I$1.RAW_TEXT }), title: new f({ contentType: { default: I$1.ESCAPABLE_RAW_TEXT, svg: I$1.PARSABLE_DATA } }), textarea: new f({ contentType: I$1.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }) }), new Ii().allKnownElementNames().forEach((t) => {
    !ot$1[t] && Me$1(t) === null && (ot$1[t] = new f({ canSelfClose: false }));
  })), ot$1[e] ?? Mi;
}
function lt$4(e) {
  return e >= 9 && e <= 32 || e == 160;
}
function ct$1(e) {
  return 48 <= e && e <= 57;
}
function Fe$1(e) {
  return e >= 97 && e <= 122 || e >= 65 && e <= 90;
}
function Bi(e) {
  return e >= 97 && e <= 102 || e >= 65 && e <= 70 || ct$1(e);
}
function ut$1(e) {
  return e === 10 || e === 13;
}
function xr$1(e) {
  return 48 <= e && e <= 55;
}
function Ut$1(e) {
  return e === 39 || e === 34 || e === 96;
}
var qe$1 = class qi {
  constructor(t, r, n, i) {
    this.file = t, this.offset = r, this.line = n, this.col = i;
  }
  toString() {
    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
  }
  moveBy(t) {
    let r = this.file.content, n = r.length, i = this.offset, s = this.line, a = this.col;
    for (; i > 0 && t < 0; ) if (i--, t++, r.charCodeAt(i) == 10) {
      s--;
      let o = r.substring(0, i - 1).lastIndexOf(String.fromCharCode(10));
      a = o > 0 ? i - o : i;
    } else a--;
    for (; i < n && t > 0; ) {
      let o = r.charCodeAt(i);
      i++, t--, o == 10 ? (s++, a = 0) : a++;
    }
    return new qi(this.file, i, s, a);
  }
  getContext(t, r) {
    let n = this.file.content, i = this.offset;
    if (i != null) {
      i > n.length - 1 && (i = n.length - 1);
      let s = i, a = 0, o = 0;
      for (; a < t && i > 0 && (i--, a++, !(n[i] == `
` && ++o == r)); ) ;
      for (a = 0, o = 0; a < t && s < n.length - 1 && (s++, a++, !(n[s] == `
` && ++o == r)); ) ;
      return { before: n.substring(i, this.offset), after: n.substring(this.offset, s + 1) };
    }
    return null;
  }
}, ht$1 = class ht {
  constructor(e, t) {
    this.content = e, this.url = t;
  }
}, h = class {
  constructor(e, t, r = e, n = null) {
    this.start = e, this.end = t, this.fullStart = r, this.details = n;
  }
  toString() {
    return this.start.file.content.substring(this.start.offset, this.end.offset);
  }
}, Fi = (function(e) {
  return e[e.WARNING = 0] = "WARNING", e[e.ERROR = 1] = "ERROR", e;
})({}), re = class extends Error {
  constructor(e, t, r = Fi.ERROR, n) {
    super(t), this.span = e, this.msg = t, this.level = r, this.relatedError = n, Object.setPrototypeOf(this, new.target.prototype);
  }
  contextualMessage() {
    let e = this.span.start.getContext(100, 3);
    return e ? `${this.msg} ("${e.before}[${Fi[this.level]} ->]${e.after}")` : this.msg;
  }
  toString() {
    let e = this.span.details ? `, ${this.span.details}` : "";
    return `${this.contextualMessage()}: ${this.span.start}${e}`;
  }
};
var Ce$1 = class Ce {
  constructor(e, t) {
    this.sourceSpan = e, this.i18n = t;
  }
}, Hi = class extends Ce$1 {
  constructor(e, t, r, n) {
    super(t, n), this.value = e, this.tokens = r, this.kind = "text";
  }
  visit(e, t) {
    return e.visitText(this, t);
  }
}, Vi = class extends Ce$1 {
  constructor(e, t, r, n) {
    super(t, n), this.value = e, this.tokens = r, this.kind = "cdata";
  }
  visit(e, t) {
    return e.visitCdata(this, t);
  }
}, Ui = class extends Ce$1 {
  constructor(e, t, r, n, i, s) {
    super(n, s), this.switchValue = e, this.type = t, this.cases = r, this.switchValueSourceSpan = i, this.kind = "expansion";
  }
  visit(e, t) {
    return e.visitExpansion(this, t);
  }
}, Wi = class {
  constructor(e, t, r, n, i) {
    this.value = e, this.expression = t, this.sourceSpan = r, this.valueSourceSpan = n, this.expSourceSpan = i, this.kind = "expansionCase";
  }
  visit(e, t) {
    return e.visitExpansionCase(this, t);
  }
}, Gi = class extends Ce$1 {
  constructor(e, t, r, n, i, s, a) {
    super(r, a), this.name = e, this.value = t, this.keySpan = n, this.valueSpan = i, this.valueTokens = s, this.kind = "attribute";
  }
  visit(e, t) {
    return e.visitAttribute(this, t);
  }
  get nameSpan() {
    return this.keySpan;
  }
}, ne$1 = class ne extends Ce$1 {
  constructor(e, t, r, n, i, s, a, o = null, c = null, u, p) {
    super(s, p), this.name = e, this.attrs = t, this.directives = r, this.children = n, this.isSelfClosing = i, this.startSourceSpan = a, this.endSourceSpan = o, this.nameSpan = c, this.isVoid = u, this.kind = "element";
  }
  visit(e, t) {
    return e.visitElement(this, t);
  }
}, $i = class {
  constructor(e, t) {
    this.value = e, this.sourceSpan = t, this.kind = "comment";
  }
  visit(e, t) {
    return e.visitComment(this, t);
  }
}, zi = class {
  constructor(e, t) {
    this.value = e, this.sourceSpan = t, this.kind = "docType";
  }
  visit(e, t) {
    return e.visitDocType(this, t);
  }
}, ve$1 = class ve extends Ce$1 {
  constructor(e, t, r, n, i, s, a = null, o) {
    super(n, o), this.name = e, this.parameters = t, this.children = r, this.nameSpan = i, this.startSourceSpan = s, this.endSourceSpan = a, this.kind = "block";
  }
  visit(e, t) {
    return e.visitBlock(this, t);
  }
}, J = class extends Ce$1 {
  constructor(e, t, r, n, i, s, a, o, c, u = null, p) {
    super(o, p), this.componentName = e, this.tagName = t, this.fullName = r, this.attrs = n, this.directives = i, this.children = s, this.isSelfClosing = a, this.startSourceSpan = c, this.endSourceSpan = u, this.kind = "component";
  }
  visit(e, t) {
    return e.visitComponent(this, t);
  }
}, Yi = class {
  constructor(e, t, r, n, i = null) {
    this.name = e, this.attrs = t, this.sourceSpan = r, this.startSourceSpan = n, this.endSourceSpan = i, this.kind = "directive";
  }
  visit(e, t) {
    return e.visitDirective(this, t);
  }
}, Nr = class {
  constructor(e, t) {
    this.expression = e, this.sourceSpan = t, this.kind = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e, t) {
    return e.visitBlockParameter(this, t);
  }
}, Lr$1 = class Lr {
  constructor(e, t, r, n, i) {
    this.name = e, this.value = t, this.sourceSpan = r, this.nameSpan = n, this.valueSpan = i, this.kind = "letDeclaration", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e, t) {
    return e.visitLetDeclaration(this, t);
  }
};
function Wt$1(e, t, r = null) {
  let n = [], i = e.visit ? (s) => e.visit(s, r) || s.visit(e, r) : (s) => s.visit(e, r);
  return t.forEach((s) => {
    let a = i(s);
    a && n.push(a);
  }), n;
}
var Pr$2 = class Pr {
  constructor() {
  }
  visitElement(e, t) {
    this.visitChildren(t, (r) => {
      r(e.attrs), r(e.directives), r(e.children);
    });
  }
  visitAttribute(e, t) {
  }
  visitText(e, t) {
  }
  visitCdata(e, t) {
  }
  visitComment(e, t) {
  }
  visitDocType(e, t) {
  }
  visitExpansion(e, t) {
    return this.visitChildren(t, (r) => {
      r(e.cases);
    });
  }
  visitExpansionCase(e, t) {
  }
  visitBlock(e, t) {
    this.visitChildren(t, (r) => {
      r(e.parameters), r(e.children);
    });
  }
  visitBlockParameter(e, t) {
  }
  visitLetDeclaration(e, t) {
  }
  visitComponent(e, t) {
    this.visitChildren(t, (r) => {
      r(e.attrs), r(e.children);
    });
  }
  visitDirective(e, t) {
    this.visitChildren(t, (r) => {
      r(e.attrs);
    });
  }
  visitChildren(e, t) {
    let r = [], n = this;
    function i(s) {
      s && r.push(Wt$1(n, s, e));
    }
    return t(i), Array.prototype.concat.apply([], r);
  }
};
var Te = { AElig: "Æ", AMP: "&", amp: "&", Aacute: "Á", Abreve: "Ă", Acirc: "Â", Acy: "А", Afr: "𝔄", Agrave: "À", Alpha: "Α", Amacr: "Ā", And: "⩓", Aogon: "Ą", Aopf: "𝔸", ApplyFunction: "⁡", af: "⁡", Aring: "Å", angst: "Å", Ascr: "𝒜", Assign: "≔", colone: "≔", coloneq: "≔", Atilde: "Ã", Auml: "Ä", Backslash: "∖", setminus: "∖", setmn: "∖", smallsetminus: "∖", ssetmn: "∖", Barv: "⫧", Barwed: "⌆", doublebarwedge: "⌆", Bcy: "Б", Because: "∵", becaus: "∵", because: "∵", Bernoullis: "ℬ", Bscr: "ℬ", bernou: "ℬ", Beta: "Β", Bfr: "𝔅", Bopf: "𝔹", Breve: "˘", breve: "˘", Bumpeq: "≎", HumpDownHump: "≎", bump: "≎", CHcy: "Ч", COPY: "©", copy: "©", Cacute: "Ć", Cap: "⋒", CapitalDifferentialD: "ⅅ", DD: "ⅅ", Cayleys: "ℭ", Cfr: "ℭ", Ccaron: "Č", Ccedil: "Ç", Ccirc: "Ĉ", Cconint: "∰", Cdot: "Ċ", Cedilla: "¸", cedil: "¸", CenterDot: "·", centerdot: "·", middot: "·", Chi: "Χ", CircleDot: "⊙", odot: "⊙", CircleMinus: "⊖", ominus: "⊖", CirclePlus: "⊕", oplus: "⊕", CircleTimes: "⊗", otimes: "⊗", ClockwiseContourIntegral: "∲", cwconint: "∲", CloseCurlyDoubleQuote: "”", rdquo: "”", rdquor: "”", CloseCurlyQuote: "’", rsquo: "’", rsquor: "’", Colon: "∷", Proportion: "∷", Colone: "⩴", Congruent: "≡", equiv: "≡", Conint: "∯", DoubleContourIntegral: "∯", ContourIntegral: "∮", conint: "∮", oint: "∮", Copf: "ℂ", complexes: "ℂ", Coproduct: "∐", coprod: "∐", CounterClockwiseContourIntegral: "∳", awconint: "∳", Cross: "⨯", Cscr: "𝒞", Cup: "⋓", CupCap: "≍", asympeq: "≍", DDotrahd: "⤑", DJcy: "Ђ", DScy: "Ѕ", DZcy: "Џ", Dagger: "‡", ddagger: "‡", Darr: "↡", Dashv: "⫤", DoubleLeftTee: "⫤", Dcaron: "Ď", Dcy: "Д", Del: "∇", nabla: "∇", Delta: "Δ", Dfr: "𝔇", DiacriticalAcute: "´", acute: "´", DiacriticalDot: "˙", dot: "˙", DiacriticalDoubleAcute: "˝", dblac: "˝", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "˜", tilde: "˜", Diamond: "⋄", diam: "⋄", diamond: "⋄", DifferentialD: "ⅆ", dd: "ⅆ", Dopf: "𝔻", Dot: "¨", DoubleDot: "¨", die: "¨", uml: "¨", DotDot: "⃜", DotEqual: "≐", doteq: "≐", esdot: "≐", DoubleDownArrow: "⇓", Downarrow: "⇓", dArr: "⇓", DoubleLeftArrow: "⇐", Leftarrow: "⇐", lArr: "⇐", DoubleLeftRightArrow: "⇔", Leftrightarrow: "⇔", hArr: "⇔", iff: "⇔", DoubleLongLeftArrow: "⟸", Longleftarrow: "⟸", xlArr: "⟸", DoubleLongLeftRightArrow: "⟺", Longleftrightarrow: "⟺", xhArr: "⟺", DoubleLongRightArrow: "⟹", Longrightarrow: "⟹", xrArr: "⟹", DoubleRightArrow: "⇒", Implies: "⇒", Rightarrow: "⇒", rArr: "⇒", DoubleRightTee: "⊨", vDash: "⊨", DoubleUpArrow: "⇑", Uparrow: "⇑", uArr: "⇑", DoubleUpDownArrow: "⇕", Updownarrow: "⇕", vArr: "⇕", DoubleVerticalBar: "∥", par: "∥", parallel: "∥", shortparallel: "∥", spar: "∥", DownArrow: "↓", ShortDownArrow: "↓", darr: "↓", downarrow: "↓", DownArrowBar: "⤓", DownArrowUpArrow: "⇵", duarr: "⇵", DownBreve: "̑", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVector: "↽", leftharpoondown: "↽", lhard: "↽", DownLeftVectorBar: "⥖", DownRightTeeVector: "⥟", DownRightVector: "⇁", rhard: "⇁", rightharpoondown: "⇁", DownRightVectorBar: "⥗", DownTee: "⊤", top: "⊤", DownTeeArrow: "↧", mapstodown: "↧", Dscr: "𝒟", Dstrok: "Đ", ENG: "Ŋ", ETH: "Ð", Eacute: "É", Ecaron: "Ě", Ecirc: "Ê", Ecy: "Э", Edot: "Ė", Efr: "𝔈", Egrave: "È", Element: "∈", in: "∈", isin: "∈", isinv: "∈", Emacr: "Ē", EmptySmallSquare: "◻", EmptyVerySmallSquare: "▫", Eogon: "Ę", Eopf: "𝔼", Epsilon: "Ε", Equal: "⩵", EqualTilde: "≂", eqsim: "≂", esim: "≂", Equilibrium: "⇌", rightleftharpoons: "⇌", rlhar: "⇌", Escr: "ℰ", expectation: "ℰ", Esim: "⩳", Eta: "Η", Euml: "Ë", Exists: "∃", exist: "∃", ExponentialE: "ⅇ", ee: "ⅇ", exponentiale: "ⅇ", Fcy: "Ф", Ffr: "𝔉", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", blacksquare: "▪", squarf: "▪", squf: "▪", Fopf: "𝔽", ForAll: "∀", forall: "∀", Fouriertrf: "ℱ", Fscr: "ℱ", GJcy: "Ѓ", GT: ">", gt: ">", Gamma: "Γ", Gammad: "Ϝ", Gbreve: "Ğ", Gcedil: "Ģ", Gcirc: "Ĝ", Gcy: "Г", Gdot: "Ġ", Gfr: "𝔊", Gg: "⋙", ggg: "⋙", Gopf: "𝔾", GreaterEqual: "≥", ge: "≥", geq: "≥", GreaterEqualLess: "⋛", gel: "⋛", gtreqless: "⋛", GreaterFullEqual: "≧", gE: "≧", geqq: "≧", GreaterGreater: "⪢", GreaterLess: "≷", gl: "≷", gtrless: "≷", GreaterSlantEqual: "⩾", geqslant: "⩾", ges: "⩾", GreaterTilde: "≳", gsim: "≳", gtrsim: "≳", Gscr: "𝒢", Gt: "≫", NestedGreaterGreater: "≫", gg: "≫", HARDcy: "Ъ", Hacek: "ˇ", caron: "ˇ", Hat: "^", Hcirc: "Ĥ", Hfr: "ℌ", Poincareplane: "ℌ", HilbertSpace: "ℋ", Hscr: "ℋ", hamilt: "ℋ", Hopf: "ℍ", quaternions: "ℍ", HorizontalLine: "─", boxh: "─", Hstrok: "Ħ", HumpEqual: "≏", bumpe: "≏", bumpeq: "≏", IEcy: "Е", IJlig: "Ĳ", IOcy: "Ё", Iacute: "Í", Icirc: "Î", Icy: "И", Idot: "İ", Ifr: "ℑ", Im: "ℑ", image: "ℑ", imagpart: "ℑ", Igrave: "Ì", Imacr: "Ī", ImaginaryI: "ⅈ", ii: "ⅈ", Int: "∬", Integral: "∫", int: "∫", Intersection: "⋂", bigcap: "⋂", xcap: "⋂", InvisibleComma: "⁣", ic: "⁣", InvisibleTimes: "⁢", it: "⁢", Iogon: "Į", Iopf: "𝕀", Iota: "Ι", Iscr: "ℐ", imagline: "ℐ", Itilde: "Ĩ", Iukcy: "І", Iuml: "Ï", Jcirc: "Ĵ", Jcy: "Й", Jfr: "𝔍", Jopf: "𝕁", Jscr: "𝒥", Jsercy: "Ј", Jukcy: "Є", KHcy: "Х", KJcy: "Ќ", Kappa: "Κ", Kcedil: "Ķ", Kcy: "К", Kfr: "𝔎", Kopf: "𝕂", Kscr: "𝒦", LJcy: "Љ", LT: "<", lt: "<", Lacute: "Ĺ", Lambda: "Λ", Lang: "⟪", Laplacetrf: "ℒ", Lscr: "ℒ", lagran: "ℒ", Larr: "↞", twoheadleftarrow: "↞", Lcaron: "Ľ", Lcedil: "Ļ", Lcy: "Л", LeftAngleBracket: "⟨", lang: "⟨", langle: "⟨", LeftArrow: "←", ShortLeftArrow: "←", larr: "←", leftarrow: "←", slarr: "←", LeftArrowBar: "⇤", larrb: "⇤", LeftArrowRightArrow: "⇆", leftrightarrows: "⇆", lrarr: "⇆", LeftCeiling: "⌈", lceil: "⌈", LeftDoubleBracket: "⟦", lobrk: "⟦", LeftDownTeeVector: "⥡", LeftDownVector: "⇃", dharl: "⇃", downharpoonleft: "⇃", LeftDownVectorBar: "⥙", LeftFloor: "⌊", lfloor: "⌊", LeftRightArrow: "↔", harr: "↔", leftrightarrow: "↔", LeftRightVector: "⥎", LeftTee: "⊣", dashv: "⊣", LeftTeeArrow: "↤", mapstoleft: "↤", LeftTeeVector: "⥚", LeftTriangle: "⊲", vartriangleleft: "⊲", vltri: "⊲", LeftTriangleBar: "⧏", LeftTriangleEqual: "⊴", ltrie: "⊴", trianglelefteq: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVector: "↿", uharl: "↿", upharpoonleft: "↿", LeftUpVectorBar: "⥘", LeftVector: "↼", leftharpoonup: "↼", lharu: "↼", LeftVectorBar: "⥒", LessEqualGreater: "⋚", leg: "⋚", lesseqgtr: "⋚", LessFullEqual: "≦", lE: "≦", leqq: "≦", LessGreater: "≶", lessgtr: "≶", lg: "≶", LessLess: "⪡", LessSlantEqual: "⩽", leqslant: "⩽", les: "⩽", LessTilde: "≲", lesssim: "≲", lsim: "≲", Lfr: "𝔏", Ll: "⋘", Lleftarrow: "⇚", lAarr: "⇚", Lmidot: "Ŀ", LongLeftArrow: "⟵", longleftarrow: "⟵", xlarr: "⟵", LongLeftRightArrow: "⟷", longleftrightarrow: "⟷", xharr: "⟷", LongRightArrow: "⟶", longrightarrow: "⟶", xrarr: "⟶", Lopf: "𝕃", LowerLeftArrow: "↙", swarr: "↙", swarrow: "↙", LowerRightArrow: "↘", searr: "↘", searrow: "↘", Lsh: "↰", lsh: "↰", Lstrok: "Ł", Lt: "≪", NestedLessLess: "≪", ll: "≪", Map: "⤅", Mcy: "М", MediumSpace: " ", Mellintrf: "ℳ", Mscr: "ℳ", phmmat: "ℳ", Mfr: "𝔐", MinusPlus: "∓", mnplus: "∓", mp: "∓", Mopf: "𝕄", Mu: "Μ", NJcy: "Њ", Nacute: "Ń", Ncaron: "Ň", Ncedil: "Ņ", Ncy: "Н", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", ZeroWidthSpace: "​", NewLine: `
`, Nfr: "𝔑", NoBreak: "⁠", NonBreakingSpace: " ", nbsp: " ", Nopf: "ℕ", naturals: "ℕ", Not: "⫬", NotCongruent: "≢", nequiv: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", npar: "∦", nparallel: "∦", nshortparallel: "∦", nspar: "∦", NotElement: "∉", notin: "∉", notinva: "∉", NotEqual: "≠", ne: "≠", NotEqualTilde: "≂̸", nesim: "≂̸", NotExists: "∄", nexist: "∄", nexists: "∄", NotGreater: "≯", ngt: "≯", ngtr: "≯", NotGreaterEqual: "≱", nge: "≱", ngeq: "≱", NotGreaterFullEqual: "≧̸", ngE: "≧̸", ngeqq: "≧̸", NotGreaterGreater: "≫̸", nGtv: "≫̸", NotGreaterLess: "≹", ntgl: "≹", NotGreaterSlantEqual: "⩾̸", ngeqslant: "⩾̸", nges: "⩾̸", NotGreaterTilde: "≵", ngsim: "≵", NotHumpDownHump: "≎̸", nbump: "≎̸", NotHumpEqual: "≏̸", nbumpe: "≏̸", NotLeftTriangle: "⋪", nltri: "⋪", ntriangleleft: "⋪", NotLeftTriangleBar: "⧏̸", NotLeftTriangleEqual: "⋬", nltrie: "⋬", ntrianglelefteq: "⋬", NotLess: "≮", nless: "≮", nlt: "≮", NotLessEqual: "≰", nle: "≰", nleq: "≰", NotLessGreater: "≸", ntlg: "≸", NotLessLess: "≪̸", nLtv: "≪̸", NotLessSlantEqual: "⩽̸", nleqslant: "⩽̸", nles: "⩽̸", NotLessTilde: "≴", nlsim: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", NotPrecedes: "⊀", npr: "⊀", nprec: "⊀", NotPrecedesEqual: "⪯̸", npre: "⪯̸", npreceq: "⪯̸", NotPrecedesSlantEqual: "⋠", nprcue: "⋠", NotReverseElement: "∌", notni: "∌", notniva: "∌", NotRightTriangle: "⋫", nrtri: "⋫", ntriangleright: "⋫", NotRightTriangleBar: "⧐̸", NotRightTriangleEqual: "⋭", nrtrie: "⋭", ntrianglerighteq: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", nsqsube: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", nsqsupe: "⋣", NotSubset: "⊂⃒", nsubset: "⊂⃒", vnsub: "⊂⃒", NotSubsetEqual: "⊈", nsube: "⊈", nsubseteq: "⊈", NotSucceeds: "⊁", nsc: "⊁", nsucc: "⊁", NotSucceedsEqual: "⪰̸", nsce: "⪰̸", nsucceq: "⪰̸", NotSucceedsSlantEqual: "⋡", nsccue: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", nsupset: "⊃⃒", vnsup: "⊃⃒", NotSupersetEqual: "⊉", nsupe: "⊉", nsupseteq: "⊉", NotTilde: "≁", nsim: "≁", NotTildeEqual: "≄", nsime: "≄", nsimeq: "≄", NotTildeFullEqual: "≇", ncong: "≇", NotTildeTilde: "≉", nap: "≉", napprox: "≉", NotVerticalBar: "∤", nmid: "∤", nshortmid: "∤", nsmid: "∤", Nscr: "𝒩", Ntilde: "Ñ", Nu: "Ν", OElig: "Œ", Oacute: "Ó", Ocirc: "Ô", Ocy: "О", Odblac: "Ő", Ofr: "𝔒", Ograve: "Ò", Omacr: "Ō", Omega: "Ω", ohm: "Ω", Omicron: "Ο", Oopf: "𝕆", OpenCurlyDoubleQuote: "“", ldquo: "“", OpenCurlyQuote: "‘", lsquo: "‘", Or: "⩔", Oscr: "𝒪", Oslash: "Ø", Otilde: "Õ", Otimes: "⨷", Ouml: "Ö", OverBar: "‾", oline: "‾", OverBrace: "⏞", OverBracket: "⎴", tbrk: "⎴", OverParenthesis: "⏜", PartialD: "∂", part: "∂", Pcy: "П", Pfr: "𝔓", Phi: "Φ", Pi: "Π", PlusMinus: "±", plusmn: "±", pm: "±", Popf: "ℙ", primes: "ℙ", Pr: "⪻", Precedes: "≺", pr: "≺", prec: "≺", PrecedesEqual: "⪯", pre: "⪯", preceq: "⪯", PrecedesSlantEqual: "≼", prcue: "≼", preccurlyeq: "≼", PrecedesTilde: "≾", precsim: "≾", prsim: "≾", Prime: "″", Product: "∏", prod: "∏", Proportional: "∝", prop: "∝", propto: "∝", varpropto: "∝", vprop: "∝", Pscr: "𝒫", Psi: "Ψ", QUOT: '"', quot: '"', Qfr: "𝔔", Qopf: "ℚ", rationals: "ℚ", Qscr: "𝒬", RBarr: "⤐", drbkarow: "⤐", REG: "®", circledR: "®", reg: "®", Racute: "Ŕ", Rang: "⟫", Rarr: "↠", twoheadrightarrow: "↠", Rarrtl: "⤖", Rcaron: "Ř", Rcedil: "Ŗ", Rcy: "Р", Re: "ℜ", Rfr: "ℜ", real: "ℜ", realpart: "ℜ", ReverseElement: "∋", SuchThat: "∋", ni: "∋", niv: "∋", ReverseEquilibrium: "⇋", leftrightharpoons: "⇋", lrhar: "⇋", ReverseUpEquilibrium: "⥯", duhar: "⥯", Rho: "Ρ", RightAngleBracket: "⟩", rang: "⟩", rangle: "⟩", RightArrow: "→", ShortRightArrow: "→", rarr: "→", rightarrow: "→", srarr: "→", RightArrowBar: "⇥", rarrb: "⇥", RightArrowLeftArrow: "⇄", rightleftarrows: "⇄", rlarr: "⇄", RightCeiling: "⌉", rceil: "⌉", RightDoubleBracket: "⟧", robrk: "⟧", RightDownTeeVector: "⥝", RightDownVector: "⇂", dharr: "⇂", downharpoonright: "⇂", RightDownVectorBar: "⥕", RightFloor: "⌋", rfloor: "⌋", RightTee: "⊢", vdash: "⊢", RightTeeArrow: "↦", map: "↦", mapsto: "↦", RightTeeVector: "⥛", RightTriangle: "⊳", vartriangleright: "⊳", vrtri: "⊳", RightTriangleBar: "⧐", RightTriangleEqual: "⊵", rtrie: "⊵", trianglerighteq: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVector: "↾", uharr: "↾", upharpoonright: "↾", RightUpVectorBar: "⥔", RightVector: "⇀", rharu: "⇀", rightharpoonup: "⇀", RightVectorBar: "⥓", Ropf: "ℝ", reals: "ℝ", RoundImplies: "⥰", Rrightarrow: "⇛", rAarr: "⇛", Rscr: "ℛ", realine: "ℛ", Rsh: "↱", rsh: "↱", RuleDelayed: "⧴", SHCHcy: "Щ", SHcy: "Ш", SOFTcy: "Ь", Sacute: "Ś", Sc: "⪼", Scaron: "Š", Scedil: "Ş", Scirc: "Ŝ", Scy: "С", Sfr: "𝔖", ShortUpArrow: "↑", UpArrow: "↑", uarr: "↑", uparrow: "↑", Sigma: "Σ", SmallCircle: "∘", compfn: "∘", Sopf: "𝕊", Sqrt: "√", radic: "√", Square: "□", squ: "□", square: "□", SquareIntersection: "⊓", sqcap: "⊓", SquareSubset: "⊏", sqsub: "⊏", sqsubset: "⊏", SquareSubsetEqual: "⊑", sqsube: "⊑", sqsubseteq: "⊑", SquareSuperset: "⊐", sqsup: "⊐", sqsupset: "⊐", SquareSupersetEqual: "⊒", sqsupe: "⊒", sqsupseteq: "⊒", SquareUnion: "⊔", sqcup: "⊔", Sscr: "𝒮", Star: "⋆", sstarf: "⋆", Sub: "⋐", Subset: "⋐", SubsetEqual: "⊆", sube: "⊆", subseteq: "⊆", Succeeds: "≻", sc: "≻", succ: "≻", SucceedsEqual: "⪰", sce: "⪰", succeq: "⪰", SucceedsSlantEqual: "≽", sccue: "≽", succcurlyeq: "≽", SucceedsTilde: "≿", scsim: "≿", succsim: "≿", Sum: "∑", sum: "∑", Sup: "⋑", Supset: "⋑", Superset: "⊃", sup: "⊃", supset: "⊃", SupersetEqual: "⊇", supe: "⊇", supseteq: "⊇", THORN: "Þ", TRADE: "™", trade: "™", TSHcy: "Ћ", TScy: "Ц", Tab: "	", Tau: "Τ", Tcaron: "Ť", Tcedil: "Ţ", Tcy: "Т", Tfr: "𝔗", Therefore: "∴", there4: "∴", therefore: "∴", Theta: "Θ", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", Tilde: "∼", sim: "∼", thicksim: "∼", thksim: "∼", TildeEqual: "≃", sime: "≃", simeq: "≃", TildeFullEqual: "≅", cong: "≅", TildeTilde: "≈", ap: "≈", approx: "≈", asymp: "≈", thickapprox: "≈", thkap: "≈", Topf: "𝕋", TripleDot: "⃛", tdot: "⃛", Tscr: "𝒯", Tstrok: "Ŧ", Uacute: "Ú", Uarr: "↟", Uarrocir: "⥉", Ubrcy: "Ў", Ubreve: "Ŭ", Ucirc: "Û", Ucy: "У", Udblac: "Ű", Ufr: "𝔘", Ugrave: "Ù", Umacr: "Ū", UnderBar: "_", lowbar: "_", UnderBrace: "⏟", UnderBracket: "⎵", bbrk: "⎵", UnderParenthesis: "⏝", Union: "⋃", bigcup: "⋃", xcup: "⋃", UnionPlus: "⊎", uplus: "⊎", Uogon: "Ų", Uopf: "𝕌", UpArrowBar: "⤒", UpArrowDownArrow: "⇅", udarr: "⇅", UpDownArrow: "↕", updownarrow: "↕", varr: "↕", UpEquilibrium: "⥮", udhar: "⥮", UpTee: "⊥", bot: "⊥", bottom: "⊥", perp: "⊥", UpTeeArrow: "↥", mapstoup: "↥", UpperLeftArrow: "↖", nwarr: "↖", nwarrow: "↖", UpperRightArrow: "↗", nearr: "↗", nearrow: "↗", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", Uring: "Ů", Uscr: "𝒰", Utilde: "Ũ", Uuml: "Ü", VDash: "⊫", Vbar: "⫫", Vcy: "В", Vdash: "⊩", Vdashl: "⫦", Vee: "⋁", bigvee: "⋁", xvee: "⋁", Verbar: "‖", Vert: "‖", VerticalBar: "∣", mid: "∣", shortmid: "∣", smid: "∣", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "❘", VerticalTilde: "≀", wr: "≀", wreath: "≀", VeryThinSpace: " ", hairsp: " ", Vfr: "𝔙", Vopf: "𝕍", Vscr: "𝒱", Vvdash: "⊪", Wcirc: "Ŵ", Wedge: "⋀", bigwedge: "⋀", xwedge: "⋀", Wfr: "𝔚", Wopf: "𝕎", Wscr: "𝒲", Xfr: "𝔛", Xi: "Ξ", Xopf: "𝕏", Xscr: "𝒳", YAcy: "Я", YIcy: "Ї", YUcy: "Ю", Yacute: "Ý", Ycirc: "Ŷ", Ycy: "Ы", Yfr: "𝔜", Yopf: "𝕐", Yscr: "𝒴", Yuml: "Ÿ", ZHcy: "Ж", Zacute: "Ź", Zcaron: "Ž", Zcy: "З", Zdot: "Ż", Zeta: "Ζ", Zfr: "ℨ", zeetrf: "ℨ", Zopf: "ℤ", integers: "ℤ", Zscr: "𝒵", aacute: "á", abreve: "ă", ac: "∾", mstpos: "∾", acE: "∾̳", acd: "∿", acirc: "â", acy: "а", aelig: "æ", afr: "𝔞", agrave: "à", alefsym: "ℵ", aleph: "ℵ", alpha: "α", amacr: "ā", amalg: "⨿", and: "∧", wedge: "∧", andand: "⩕", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", angle: "∠", ange: "⦤", angmsd: "∡", measuredangle: "∡", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angzarr: "⍼", aogon: "ą", aopf: "𝕒", apE: "⩰", apacir: "⩯", ape: "≊", approxeq: "≊", apid: "≋", apos: "'", aring: "å", ascr: "𝒶", ast: "*", midast: "*", atilde: "ã", auml: "ä", awint: "⨑", bNot: "⫭", backcong: "≌", bcong: "≌", backepsilon: "϶", bepsi: "϶", backprime: "‵", bprime: "‵", backsim: "∽", bsim: "∽", backsimeq: "⋍", bsime: "⋍", barvee: "⊽", barwed: "⌅", barwedge: "⌅", bbrktbrk: "⎶", bcy: "б", bdquo: "„", ldquor: "„", bemptyv: "⦰", beta: "β", beth: "ℶ", between: "≬", twixt: "≬", bfr: "𝔟", bigcirc: "◯", xcirc: "◯", bigodot: "⨀", xodot: "⨀", bigoplus: "⨁", xoplus: "⨁", bigotimes: "⨂", xotime: "⨂", bigsqcup: "⨆", xsqcup: "⨆", bigstar: "★", starf: "★", bigtriangledown: "▽", xdtri: "▽", bigtriangleup: "△", xutri: "△", biguplus: "⨄", xuplus: "⨄", bkarow: "⤍", rbarr: "⤍", blacklozenge: "⧫", lozf: "⧫", blacktriangle: "▴", utrif: "▴", blacktriangledown: "▾", dtrif: "▾", blacktriangleleft: "◂", ltrif: "◂", blacktriangleright: "▸", rtrif: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bnot: "⌐", bopf: "𝕓", bowtie: "⋈", boxDL: "╗", boxDR: "╔", boxDl: "╖", boxDr: "╓", boxH: "═", boxHD: "╦", boxHU: "╩", boxHd: "╤", boxHu: "╧", boxUL: "╝", boxUR: "╚", boxUl: "╜", boxUr: "╙", boxV: "║", boxVH: "╬", boxVL: "╣", boxVR: "╠", boxVh: "╫", boxVl: "╢", boxVr: "╟", boxbox: "⧉", boxdL: "╕", boxdR: "╒", boxdl: "┐", boxdr: "┌", boxhD: "╥", boxhU: "╨", boxhd: "┬", boxhu: "┴", boxminus: "⊟", minusb: "⊟", boxplus: "⊞", plusb: "⊞", boxtimes: "⊠", timesb: "⊠", boxuL: "╛", boxuR: "╘", boxul: "┘", boxur: "└", boxv: "│", boxvH: "╪", boxvL: "╡", boxvR: "╞", boxvh: "┼", boxvl: "┤", boxvr: "├", brvbar: "¦", bscr: "𝒷", bsemi: "⁏", bsol: "\\", bsolb: "⧅", bsolhsub: "⟈", bull: "•", bullet: "•", bumpE: "⪮", cacute: "ć", cap: "∩", capand: "⩄", capbrcup: "⩉", capcap: "⩋", capcup: "⩇", capdot: "⩀", caps: "∩︀", caret: "⁁", ccaps: "⩍", ccaron: "č", ccedil: "ç", ccirc: "ĉ", ccups: "⩌", ccupssm: "⩐", cdot: "ċ", cemptyv: "⦲", cent: "¢", cfr: "𝔠", chcy: "ч", check: "✓", checkmark: "✓", chi: "χ", cir: "○", cirE: "⧃", circ: "ˆ", circeq: "≗", cire: "≗", circlearrowleft: "↺", olarr: "↺", circlearrowright: "↻", orarr: "↻", circledS: "Ⓢ", oS: "Ⓢ", circledast: "⊛", oast: "⊛", circledcirc: "⊚", ocir: "⊚", circleddash: "⊝", odash: "⊝", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", clubs: "♣", clubsuit: "♣", colon: ":", comma: ",", commat: "@", comp: "∁", complement: "∁", congdot: "⩭", copf: "𝕔", copysr: "℗", crarr: "↵", cross: "✗", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", curlyeqprec: "⋞", cuesc: "⋟", curlyeqsucc: "⋟", cularr: "↶", curvearrowleft: "↶", cularrp: "⤽", cup: "∪", cupbrcap: "⩈", cupcap: "⩆", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curvearrowright: "↷", curarrm: "⤼", curlyvee: "⋎", cuvee: "⋎", curlywedge: "⋏", cuwed: "⋏", curren: "¤", cwint: "∱", cylcty: "⌭", dHar: "⥥", dagger: "†", daleth: "ℸ", dash: "‐", hyphen: "‐", dbkarow: "⤏", rBarr: "⤏", dcaron: "ď", dcy: "д", ddarr: "⇊", downdownarrows: "⇊", ddotseq: "⩷", eDDot: "⩷", deg: "°", delta: "δ", demptyv: "⦱", dfisht: "⥿", dfr: "𝔡", diamondsuit: "♦", diams: "♦", digamma: "ϝ", gammad: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", djcy: "ђ", dlcorn: "⌞", llcorner: "⌞", dlcrop: "⌍", dollar: "$", dopf: "𝕕", doteqdot: "≑", eDot: "≑", dotminus: "∸", minusd: "∸", dotplus: "∔", plusdo: "∔", dotsquare: "⊡", sdotb: "⊡", drcorn: "⌟", lrcorner: "⌟", drcrop: "⌌", dscr: "𝒹", dscy: "ѕ", dsol: "⧶", dstrok: "đ", dtdot: "⋱", dtri: "▿", triangledown: "▿", dwangle: "⦦", dzcy: "џ", dzigrarr: "⟿", eacute: "é", easter: "⩮", ecaron: "ě", ecir: "≖", eqcirc: "≖", ecirc: "ê", ecolon: "≕", eqcolon: "≕", ecy: "э", edot: "ė", efDot: "≒", fallingdotseq: "≒", efr: "𝔢", eg: "⪚", egrave: "è", egs: "⪖", eqslantgtr: "⪖", egsdot: "⪘", el: "⪙", elinters: "⏧", ell: "ℓ", els: "⪕", eqslantless: "⪕", elsdot: "⪗", emacr: "ē", empty: "∅", emptyset: "∅", emptyv: "∅", varnothing: "∅", emsp13: " ", emsp14: " ", emsp: " ", eng: "ŋ", ensp: " ", eogon: "ę", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", epsilon: "ε", epsiv: "ϵ", straightepsilon: "ϵ", varepsilon: "ϵ", equals: "=", equest: "≟", questeq: "≟", equivDD: "⩸", eqvparsl: "⧥", erDot: "≓", risingdotseq: "≓", erarr: "⥱", escr: "ℯ", eta: "η", eth: "ð", euml: "ë", euro: "€", excl: "!", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", ffr: "𝔣", filig: "ﬁ", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", fopf: "𝕗", fork: "⋔", pitchfork: "⋔", forkv: "⫙", fpartint: "⨍", frac12: "½", half: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", sfrown: "⌢", fscr: "𝒻", gEl: "⪌", gtreqqless: "⪌", gacute: "ǵ", gamma: "γ", gap: "⪆", gtrapprox: "⪆", gbreve: "ğ", gcirc: "ĝ", gcy: "г", gdot: "ġ", gescc: "⪩", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", gfr: "𝔤", gimel: "ℷ", gjcy: "ѓ", glE: "⪒", gla: "⪥", glj: "⪤", gnE: "≩", gneqq: "≩", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gneq: "⪈", gnsim: "⋧", gopf: "𝕘", gscr: "ℊ", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gtdot: "⋗", gtrdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrarr: "⥸", gvertneqq: "≩︀", gvnE: "≩︀", hardcy: "ъ", harrcir: "⥈", harrw: "↭", leftrightsquigarrow: "↭", hbar: "ℏ", hslash: "ℏ", planck: "ℏ", plankv: "ℏ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", mldr: "…", hercon: "⊹", hfr: "𝔥", hksearow: "⤥", searhk: "⤥", hkswarow: "⤦", swarhk: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", larrhk: "↩", hookrightarrow: "↪", rarrhk: "↪", hopf: "𝕙", horbar: "―", hscr: "𝒽", hstrok: "ħ", hybull: "⁃", iacute: "í", icirc: "î", icy: "и", iecy: "е", iexcl: "¡", ifr: "𝔦", igrave: "ì", iiiint: "⨌", qint: "⨌", iiint: "∭", tint: "∭", iinfin: "⧜", iiota: "℩", ijlig: "ĳ", imacr: "ī", imath: "ı", inodot: "ı", imof: "⊷", imped: "Ƶ", incare: "℅", infin: "∞", infintie: "⧝", intcal: "⊺", intercal: "⊺", intlarhk: "⨗", intprod: "⨼", iprod: "⨼", iocy: "ё", iogon: "į", iopf: "𝕚", iota: "ι", iquest: "¿", iscr: "𝒾", isinE: "⋹", isindot: "⋵", isins: "⋴", isinsv: "⋳", itilde: "ĩ", iukcy: "і", iuml: "ï", jcirc: "ĵ", jcy: "й", jfr: "𝔧", jmath: "ȷ", jopf: "𝕛", jscr: "𝒿", jsercy: "ј", jukcy: "є", kappa: "κ", kappav: "ϰ", varkappa: "ϰ", kcedil: "ķ", kcy: "к", kfr: "𝔨", kgreen: "ĸ", khcy: "х", kjcy: "ќ", kopf: "𝕜", kscr: "𝓀", lAtail: "⤛", lBarr: "⤎", lEg: "⪋", lesseqqgtr: "⪋", lHar: "⥢", lacute: "ĺ", laemptyv: "⦴", lambda: "λ", langd: "⦑", lap: "⪅", lessapprox: "⪅", laquo: "«", larrbfs: "⤟", larrfs: "⤝", larrlp: "↫", looparrowleft: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", leftarrowtail: "↢", lat: "⪫", latail: "⤙", late: "⪭", lates: "⪭︀", lbarr: "⤌", lbbrk: "❲", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", lcaron: "ľ", lcedil: "ļ", lcy: "л", ldca: "⤶", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", leq: "≤", leftleftarrows: "⇇", llarr: "⇇", leftthreetimes: "⋋", lthree: "⋋", lescc: "⪨", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessdot: "⋖", ltdot: "⋖", lfisht: "⥼", lfr: "𝔩", lgE: "⪑", lharul: "⥪", lhblk: "▄", ljcy: "љ", llhard: "⥫", lltri: "◺", lmidot: "ŀ", lmoust: "⎰", lmoustache: "⎰", lnE: "≨", lneqq: "≨", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lneq: "⪇", lnsim: "⋦", loang: "⟬", loarr: "⇽", longmapsto: "⟼", xmap: "⟼", looparrowright: "↬", rarrlp: "↬", lopar: "⦅", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", loz: "◊", lozenge: "◊", lpar: "(", lparlt: "⦓", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", lsime: "⪍", lsimg: "⪏", lsquor: "‚", sbquo: "‚", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltrPar: "⦖", ltri: "◃", triangleleft: "◃", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", mDDot: "∺", macr: "¯", strns: "¯", male: "♂", malt: "✠", maltese: "✠", marker: "▮", mcomma: "⨩", mcy: "м", mdash: "—", mfr: "𝔪", mho: "℧", micro: "µ", midcir: "⫰", minus: "−", minusdu: "⨪", mlcp: "⫛", models: "⊧", mopf: "𝕞", mscr: "𝓂", mu: "μ", multimap: "⊸", mumap: "⊸", nGg: "⋙̸", nGt: "≫⃒", nLeftarrow: "⇍", nlArr: "⇍", nLeftrightarrow: "⇎", nhArr: "⇎", nLl: "⋘̸", nLt: "≪⃒", nRightarrow: "⇏", nrArr: "⇏", nVDash: "⊯", nVdash: "⊮", nacute: "ń", nang: "∠⃒", napE: "⩰̸", napid: "≋̸", napos: "ŉ", natur: "♮", natural: "♮", ncap: "⩃", ncaron: "ň", ncedil: "ņ", ncongdot: "⩭̸", ncup: "⩂", ncy: "н", ndash: "–", neArr: "⇗", nearhk: "⤤", nedot: "≐̸", nesear: "⤨", toea: "⤨", nfr: "𝔫", nharr: "↮", nleftrightarrow: "↮", nhpar: "⫲", nis: "⋼", nisd: "⋺", njcy: "њ", nlE: "≦̸", nleqq: "≦̸", nlarr: "↚", nleftarrow: "↚", nldr: "‥", nopf: "𝕟", not: "¬", notinE: "⋹̸", notindot: "⋵̸", notinvb: "⋷", notinvc: "⋶", notnivb: "⋾", notnivc: "⋽", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", nrarr: "↛", nrightarrow: "↛", nrarrc: "⤳̸", nrarrw: "↝̸", nscr: "𝓃", nsub: "⊄", nsubE: "⫅̸", nsubseteqq: "⫅̸", nsup: "⊅", nsupE: "⫆̸", nsupseteqq: "⫆̸", ntilde: "ñ", nu: "ν", num: "#", numero: "№", numsp: " ", nvDash: "⊭", nvHarr: "⤄", nvap: "≍⃒", nvdash: "⊬", nvge: "≥⃒", nvgt: ">⃒", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwArr: "⇖", nwarhk: "⤣", nwnear: "⤧", oacute: "ó", ocirc: "ô", ocy: "о", odblac: "ő", odiv: "⨸", odsold: "⦼", oelig: "œ", ofcir: "⦿", ofr: "𝔬", ogon: "˛", ograve: "ò", ogt: "⧁", ohbar: "⦵", olcir: "⦾", olcross: "⦻", olt: "⧀", omacr: "ō", omega: "ω", omicron: "ο", omid: "⦶", oopf: "𝕠", opar: "⦷", operp: "⦹", or: "∨", vee: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", oscr: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oslash: "ø", osol: "⊘", otilde: "õ", otimesas: "⨶", ouml: "ö", ovbar: "⌽", para: "¶", parsim: "⫳", parsl: "⫽", pcy: "п", percnt: "%", period: ".", permil: "‰", pertenk: "‱", pfr: "𝔭", phi: "φ", phiv: "ϕ", straightphi: "ϕ", varphi: "ϕ", phone: "☎", pi: "π", piv: "ϖ", varpi: "ϖ", planckh: "ℎ", plus: "+", plusacir: "⨣", pluscir: "⨢", plusdu: "⨥", pluse: "⩲", plussim: "⨦", plustwo: "⨧", pointint: "⨕", popf: "𝕡", pound: "£", prE: "⪳", prap: "⪷", precapprox: "⪷", precnapprox: "⪹", prnap: "⪹", precneqq: "⪵", prnE: "⪵", precnsim: "⋨", prnsim: "⋨", prime: "′", profalar: "⌮", profline: "⌒", profsurf: "⌓", prurel: "⊰", pscr: "𝓅", psi: "ψ", puncsp: " ", qfr: "𝔮", qopf: "𝕢", qprime: "⁗", qscr: "𝓆", quatint: "⨖", quest: "?", rAtail: "⤜", rHar: "⥤", race: "∽̱", racute: "ŕ", raemptyv: "⦳", rangd: "⦒", range: "⦥", raquo: "»", rarrap: "⥵", rarrbfs: "⤠", rarrc: "⤳", rarrfs: "⤞", rarrpl: "⥅", rarrsim: "⥴", rarrtl: "↣", rightarrowtail: "↣", rarrw: "↝", rightsquigarrow: "↝", ratail: "⤚", ratio: "∶", rbbrk: "❳", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", rcaron: "ř", rcedil: "ŗ", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdsh: "↳", rect: "▭", rfisht: "⥽", rfr: "𝔯", rharul: "⥬", rho: "ρ", rhov: "ϱ", varrho: "ϱ", rightrightarrows: "⇉", rrarr: "⇉", rightthreetimes: "⋌", rthree: "⋌", ring: "˚", rlm: "‏", rmoust: "⎱", rmoustache: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", ropar: "⦆", ropf: "𝕣", roplus: "⨮", rotimes: "⨵", rpar: ")", rpargt: "⦔", rppolint: "⨒", rsaquo: "›", rscr: "𝓇", rtimes: "⋊", rtri: "▹", triangleright: "▹", rtriltri: "⧎", ruluhar: "⥨", rx: "℞", sacute: "ś", scE: "⪴", scap: "⪸", succapprox: "⪸", scaron: "š", scedil: "ş", scirc: "ŝ", scnE: "⪶", succneqq: "⪶", scnap: "⪺", succnapprox: "⪺", scnsim: "⋩", succnsim: "⋩", scpolint: "⨓", scy: "с", sdot: "⋅", sdote: "⩦", seArr: "⇘", sect: "§", semi: ";", seswar: "⤩", tosa: "⤩", sext: "✶", sfr: "𝔰", sharp: "♯", shchcy: "щ", shcy: "ш", shy: "­", sigma: "σ", sigmaf: "ς", sigmav: "ς", varsigma: "ς", simdot: "⩪", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", smashp: "⨳", smeparsl: "⧤", smile: "⌣", ssmile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", softcy: "ь", sol: "/", solb: "⧄", solbar: "⌿", sopf: "𝕤", spades: "♠", spadesuit: "♠", sqcaps: "⊓︀", sqcups: "⊔︀", sscr: "𝓈", star: "☆", sub: "⊂", subset: "⊂", subE: "⫅", subseteqq: "⫅", subdot: "⪽", subedot: "⫃", submult: "⫁", subnE: "⫋", subsetneqq: "⫋", subne: "⊊", subsetneq: "⊊", subplus: "⪿", subrarr: "⥹", subsim: "⫇", subsub: "⫕", subsup: "⫓", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", supE: "⫆", supseteqq: "⫆", supdot: "⪾", supdsub: "⫘", supedot: "⫄", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supsetneqq: "⫌", supne: "⊋", supsetneq: "⊋", supplus: "⫀", supsim: "⫈", supsub: "⫔", supsup: "⫖", swArr: "⇙", swnwar: "⤪", szlig: "ß", target: "⌖", tau: "τ", tcaron: "ť", tcedil: "ţ", tcy: "т", telrec: "⌕", tfr: "𝔱", theta: "θ", thetasym: "ϑ", thetav: "ϑ", vartheta: "ϑ", thorn: "þ", times: "×", timesbar: "⨱", timesd: "⨰", topbot: "⌶", topcir: "⫱", topf: "𝕥", topfork: "⫚", tprime: "‴", triangle: "▵", utri: "▵", triangleq: "≜", trie: "≜", tridot: "◬", triminus: "⨺", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", tscr: "𝓉", tscy: "ц", tshcy: "ћ", tstrok: "ŧ", uHar: "⥣", uacute: "ú", ubrcy: "ў", ubreve: "ŭ", ucirc: "û", ucy: "у", udblac: "ű", ufisht: "⥾", ufr: "𝔲", ugrave: "ù", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", umacr: "ū", uogon: "ų", uopf: "𝕦", upsi: "υ", upsilon: "υ", upuparrows: "⇈", uuarr: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", uring: "ů", urtri: "◹", uscr: "𝓊", utdot: "⋰", utilde: "ũ", uuml: "ü", uwangle: "⦧", vBar: "⫨", vBarv: "⫩", vangrt: "⦜", varsubsetneq: "⊊︀", vsubne: "⊊︀", varsubsetneqq: "⫋︀", vsubnE: "⫋︀", varsupsetneq: "⊋︀", vsupne: "⊋︀", varsupsetneqq: "⫌︀", vsupnE: "⫌︀", vcy: "в", veebar: "⊻", veeeq: "≚", vellip: "⋮", vfr: "𝔳", vopf: "𝕧", vscr: "𝓋", vzigzag: "⦚", wcirc: "ŵ", wedbar: "⩟", wedgeq: "≙", weierp: "℘", wp: "℘", wfr: "𝔴", wopf: "𝕨", wscr: "𝓌", xfr: "𝔵", xi: "ξ", xnis: "⋻", xopf: "𝕩", xscr: "𝓍", yacute: "ý", yacy: "я", ycirc: "ŷ", ycy: "ы", yen: "¥", yfr: "𝔶", yicy: "ї", yopf: "𝕪", yscr: "𝓎", yucy: "ю", yuml: "ÿ", zacute: "ź", zcaron: "ž", zcy: "з", zdot: "ż", zeta: "ζ", zfr: "𝔷", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", zscr: "𝓏", zwj: "‍", zwnj: "‌" }, oo$1 = "";
Te.ngsp = oo$1;
var l = (function(e) {
  return e[e.TAG_OPEN_START = 0] = "TAG_OPEN_START", e[e.TAG_OPEN_END = 1] = "TAG_OPEN_END", e[e.TAG_OPEN_END_VOID = 2] = "TAG_OPEN_END_VOID", e[e.TAG_CLOSE = 3] = "TAG_CLOSE", e[e.INCOMPLETE_TAG_OPEN = 4] = "INCOMPLETE_TAG_OPEN", e[e.TEXT = 5] = "TEXT", e[e.ESCAPABLE_RAW_TEXT = 6] = "ESCAPABLE_RAW_TEXT", e[e.RAW_TEXT = 7] = "RAW_TEXT", e[e.INTERPOLATION = 8] = "INTERPOLATION", e[e.ENCODED_ENTITY = 9] = "ENCODED_ENTITY", e[e.COMMENT_START = 10] = "COMMENT_START", e[e.COMMENT_END = 11] = "COMMENT_END", e[e.CDATA_START = 12] = "CDATA_START", e[e.CDATA_END = 13] = "CDATA_END", e[e.ATTR_NAME = 14] = "ATTR_NAME", e[e.ATTR_QUOTE = 15] = "ATTR_QUOTE", e[e.ATTR_VALUE_TEXT = 16] = "ATTR_VALUE_TEXT", e[e.ATTR_VALUE_INTERPOLATION = 17] = "ATTR_VALUE_INTERPOLATION", e[e.DOC_TYPE_START = 18] = "DOC_TYPE_START", e[e.DOC_TYPE_END = 19] = "DOC_TYPE_END", e[e.EXPANSION_FORM_START = 20] = "EXPANSION_FORM_START", e[e.EXPANSION_CASE_VALUE = 21] = "EXPANSION_CASE_VALUE", e[e.EXPANSION_CASE_EXP_START = 22] = "EXPANSION_CASE_EXP_START", e[e.EXPANSION_CASE_EXP_END = 23] = "EXPANSION_CASE_EXP_END", e[e.EXPANSION_FORM_END = 24] = "EXPANSION_FORM_END", e[e.BLOCK_OPEN_START = 25] = "BLOCK_OPEN_START", e[e.BLOCK_OPEN_END = 26] = "BLOCK_OPEN_END", e[e.BLOCK_CLOSE = 27] = "BLOCK_CLOSE", e[e.BLOCK_PARAMETER = 28] = "BLOCK_PARAMETER", e[e.INCOMPLETE_BLOCK_OPEN = 29] = "INCOMPLETE_BLOCK_OPEN", e[e.LET_START = 30] = "LET_START", e[e.LET_VALUE = 31] = "LET_VALUE", e[e.LET_END = 32] = "LET_END", e[e.INCOMPLETE_LET = 33] = "INCOMPLETE_LET", e[e.COMPONENT_OPEN_START = 34] = "COMPONENT_OPEN_START", e[e.COMPONENT_OPEN_END = 35] = "COMPONENT_OPEN_END", e[e.COMPONENT_OPEN_END_VOID = 36] = "COMPONENT_OPEN_END_VOID", e[e.COMPONENT_CLOSE = 37] = "COMPONENT_CLOSE", e[e.INCOMPLETE_COMPONENT_OPEN = 38] = "INCOMPLETE_COMPONENT_OPEN", e[e.DIRECTIVE_NAME = 39] = "DIRECTIVE_NAME", e[e.DIRECTIVE_OPEN = 40] = "DIRECTIVE_OPEN", e[e.DIRECTIVE_CLOSE = 41] = "DIRECTIVE_CLOSE", e[e.EOF = 42] = "EOF", e;
})({});
var xo$1 = class xo {
  constructor(e, t, r) {
    this.tokens = e, this.errors = t, this.nonNormalizedIcuExpressions = r;
  }
};
function ns(e, t, r, n = {}) {
  let i = new Oo$1(new ht$1(e, t), r, n);
  return i.tokenize(), new xo$1(qo$1(i.tokens), i.errors, i.nonNormalizedIcuExpressions);
}
var No$1 = /\r\n?/g;
function be$1(e) {
  return `Unexpected character "${e === 0 ? "EOF" : String.fromCharCode(e)}"`;
}
function Qi(e) {
  return `Unknown entity "${e}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function Lo$1(e, t) {
  return `Unable to parse entity "${t}" - ${e} character reference entities must end with ";"`;
}
var Mr$1 = (function(e) {
  return e.HEX = "hexadecimal", e.DEC = "decimal", e;
})(Mr$1 || {}), Po$1 = ["@if", "@else", "@for", "@switch", "@case", "@default", "@empty", "@defer", "@placeholder", "@loading", "@error"], mt$1 = { start: "{{", end: "}}" }, Oo$1 = class Oo {
  constructor(e, t, r) {
    this._getTagContentType = t, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._openDirectiveCount = 0, this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = r.tokenizeExpansionForms || false, this._leadingTriviaCodePoints = r.leadingTriviaChars && r.leadingTriviaChars.map((i) => i.codePointAt(0) || 0), this._canSelfClose = r.canSelfClose || false, this._allowHtmComponentClosingTags = r.allowHtmComponentClosingTags || false;
    let n = r.range || { endPos: e.content.length, startPos: 0, startLine: 0, startCol: 0 };
    this._cursor = r.escapedString ? new Ho$1(e, n) : new is(e, n), this._preserveLineEndings = r.preserveLineEndings || false, this._i18nNormalizeLineEndingsInICUs = r.i18nNormalizeLineEndingsInICUs || false, this._tokenizeBlocks = r.tokenizeBlocks ?? true, this._tokenizeLet = r.tokenizeLet ?? true, this._selectorlessEnabled = r.selectorlessEnabled ?? false;
    try {
      this._cursor.init();
    } catch (i) {
      this.handleError(i);
    }
  }
  _processCarriageReturns(e) {
    return this._preserveLineEndings ? e : e.replace(No$1, `
`);
  }
  tokenize() {
    for (; this._cursor.peek() !== 0; ) {
      let e = this._cursor.clone();
      try {
        if (this._attemptCharCode(60)) if (this._attemptCharCode(33)) this._attemptStr("[CDATA[") ? this._consumeCdata(e) : this._attemptStr("--") ? this._consumeComment(e) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e) : this._consumeBogusComment(e);
        else if (this._attemptCharCode(47)) this._consumeTagClose(e);
        else {
          let t = this._cursor.clone();
          this._attemptCharCode(63) ? (this._cursor = t, this._consumeBogusComment(e)) : this._consumeTagOpen(e);
        }
        else this._tokenizeLet && this._cursor.peek() === 64 && !this._inInterpolation && this._isLetStart() ? this._consumeLetDeclaration(e) : this._tokenizeBlocks && this._isBlockStart() ? this._consumeBlockStart(e) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(e) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(l.TEXT, l.INTERPOLATION, () => this._isTextEnd(), () => this._isTagStart());
      } catch (t) {
        this.handleError(t);
      }
    }
    this._beginToken(l.EOF), this._endToken([]);
  }
  _getBlockName() {
    let e = false, t = this._cursor.clone();
    return this._attemptCharCodeUntilFn((r) => lt$4(r) ? !e : Fo$1(r) ? (e = true, false) : true), this._cursor.getChars(t).trim();
  }
  _consumeBlockStart(e) {
    this._requireCharCode(64), this._beginToken(l.BLOCK_OPEN_START, e);
    let t = this._endToken([this._getBlockName()]);
    if (this._cursor.peek() === 40) if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(T$1), this._attemptCharCode(41)) this._attemptCharCodeUntilFn(T$1);
    else {
      t.type = l.INCOMPLETE_BLOCK_OPEN;
      return;
    }
    this._attemptCharCode(123) ? (this._beginToken(l.BLOCK_OPEN_END), this._endToken([])) : t.type = l.INCOMPLETE_BLOCK_OPEN;
  }
  _consumeBlockEnd(e) {
    this._beginToken(l.BLOCK_CLOSE, e), this._endToken([]);
  }
  _consumeBlockParameters() {
    for (this._attemptCharCodeUntilFn(Zi); this._cursor.peek() !== 41 && this._cursor.peek() !== 0; ) {
      this._beginToken(l.BLOCK_PARAMETER);
      let e = this._cursor.clone(), t = null, r = 0;
      for (; this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || t !== null; ) {
        let n = this._cursor.peek();
        if (n === 92) this._cursor.advance();
        else if (n === t) t = null;
        else if (t === null && Ut$1(n)) t = n;
        else if (n === 40 && t === null) r++;
        else if (n === 41 && t === null) {
          if (r === 0) break;
          r > 0 && r--;
        }
        this._cursor.advance();
      }
      this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(Zi);
    }
  }
  _consumeLetDeclaration(e) {
    if (this._requireStr("@let"), this._beginToken(l.LET_START, e), lt$4(this._cursor.peek())) this._attemptCharCodeUntilFn(T$1);
    else {
      let r = this._endToken([this._cursor.getChars(e)]);
      r.type = l.INCOMPLETE_LET;
      return;
    }
    let t = this._endToken([this._getLetDeclarationName()]);
    if (this._attemptCharCodeUntilFn(T$1), !this._attemptCharCode(61)) {
      t.type = l.INCOMPLETE_LET;
      return;
    }
    this._attemptCharCodeUntilFn((r) => T$1(r) && !ut$1(r)), this._consumeLetDeclarationValue(), this._cursor.peek() === 59 ? (this._beginToken(l.LET_END), this._endToken([]), this._cursor.advance()) : (t.type = l.INCOMPLETE_LET, t.sourceSpan = this._cursor.getSpan(e));
  }
  _getLetDeclarationName() {
    let e = this._cursor.clone(), t = false;
    return this._attemptCharCodeUntilFn((r) => Fe$1(r) || r === 36 || r === 95 || t && ct$1(r) ? (t = true, false) : true), this._cursor.getChars(e).trim();
  }
  _consumeLetDeclarationValue() {
    let e = this._cursor.clone();
    for (this._beginToken(l.LET_VALUE, e); this._cursor.peek() !== 0; ) {
      let t = this._cursor.peek();
      if (t === 59) break;
      Ut$1(t) && (this._cursor.advance(), this._attemptCharCodeUntilFn((r) => r === 92 ? (this._cursor.advance(), false) : r === t)), this._cursor.advance();
    }
    this._endToken([this._cursor.getChars(e)]);
  }
  _tokenizeExpansionForm() {
    if (this.isExpansionFormStart()) return this._consumeExpansionFormStart(), true;
    if (Mo$1(this._cursor.peek()) && this._isInExpansionForm()) return this._consumeExpansionCaseStart(), true;
    if (this._cursor.peek() === 125) {
      if (this._isInExpansionCase()) return this._consumeExpansionCaseEnd(), true;
      if (this._isInExpansionForm()) return this._consumeExpansionFormEnd(), true;
    }
    return false;
  }
  _beginToken(e, t = this._cursor.clone()) {
    this._currentTokenStart = t, this._currentTokenType = e;
  }
  _endToken(e, t) {
    if (this._currentTokenStart === null) throw new re(this._cursor.getSpan(t), "Programming error - attempted to end a token when there was no start to the token");
    if (this._currentTokenType === null) throw new re(this._cursor.getSpan(this._currentTokenStart), "Programming error - attempted to end a token which has no token type");
    let r = { type: this._currentTokenType, parts: e, sourceSpan: (t ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
    return this.tokens.push(r), this._currentTokenStart = null, this._currentTokenType = null, r;
  }
  _createError(e, t) {
    this._isInExpansionForm() && (e += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
    let r = new re(t, e);
    return this._currentTokenStart = null, this._currentTokenType = null, r;
  }
  handleError(e) {
    if (e instanceof Vr$1 && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), e instanceof re) this.errors.push(e);
    else throw e;
  }
  _attemptCharCode(e) {
    return this._cursor.peek() === e ? (this._cursor.advance(), true) : false;
  }
  _attemptCharCodeCaseInsensitive(e) {
    return Bo$1(this._cursor.peek(), e) ? (this._cursor.advance(), true) : false;
  }
  _requireCharCode(e) {
    let t = this._cursor.clone();
    if (!this._attemptCharCode(e)) throw this._createError(be$1(this._cursor.peek()), this._cursor.getSpan(t));
  }
  _attemptStr(e) {
    let t = e.length;
    if (this._cursor.charsLeft() < t) return false;
    let r = this._cursor.clone();
    for (let n = 0; n < t; n++) if (!this._attemptCharCode(e.charCodeAt(n))) return this._cursor = r, false;
    return true;
  }
  _attemptStrCaseInsensitive(e) {
    for (let t = 0; t < e.length; t++) if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(t))) return false;
    return true;
  }
  _requireStr(e) {
    let t = this._cursor.clone();
    if (!this._attemptStr(e)) throw this._createError(be$1(this._cursor.peek()), this._cursor.getSpan(t));
  }
  _requireStrCaseInsensitive(e) {
    let t = this._cursor.clone();
    if (!this._attemptStrCaseInsensitive(e)) throw this._createError(be$1(this._cursor.peek()), this._cursor.getSpan(t));
  }
  _attemptCharCodeUntilFn(e) {
    for (; !e(this._cursor.peek()); ) this._cursor.advance();
  }
  _requireCharCodeUntilFn(e, t) {
    let r = this._cursor.clone();
    if (this._attemptCharCodeUntilFn(e), this._cursor.diff(r) < t) throw this._createError(be$1(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptUntilChar(e) {
    for (; this._cursor.peek() !== e; ) this._cursor.advance();
  }
  _readChar() {
    let e = String.fromCodePoint(this._cursor.peek());
    return this._cursor.advance(), e;
  }
  _peekStr(e) {
    let t = e.length;
    if (this._cursor.charsLeft() < t) return false;
    let r = this._cursor.clone();
    for (let n = 0; n < t; n++) {
      if (r.peek() !== e.charCodeAt(n)) return false;
      r.advance();
    }
    return true;
  }
  _isBlockStart() {
    return this._cursor.peek() === 64 && Po$1.some((e) => this._peekStr(e));
  }
  _isLetStart() {
    return this._cursor.peek() === 64 && this._peekStr("@let");
  }
  _consumeEntity(e) {
    this._beginToken(l.ENCODED_ENTITY);
    let t = this._cursor.clone();
    if (this._cursor.advance(), this._attemptCharCode(35)) {
      let r = this._attemptCharCode(120) || this._attemptCharCode(88), n = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Ro$1), this._cursor.peek() != 59) {
        this._cursor.advance();
        let s = r ? Mr$1.HEX : Mr$1.DEC;
        throw this._createError(Lo$1(s, this._cursor.getChars(t)), this._cursor.getSpan());
      }
      let i = this._cursor.getChars(n);
      this._cursor.advance();
      try {
        let s = parseInt(i, r ? 16 : 10);
        this._endToken([String.fromCodePoint(s), this._cursor.getChars(t)]);
      } catch {
        throw this._createError(Qi(this._cursor.getChars(t)), this._cursor.getSpan());
      }
    } else {
      let r = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Io$1), this._cursor.peek() != 59) this._beginToken(e, t), this._cursor = r, this._endToken(["&"]);
      else {
        let n = this._cursor.getChars(r);
        this._cursor.advance();
        let i = Te.hasOwnProperty(n) && Te[n];
        if (!i) throw this._createError(Qi(n), this._cursor.getSpan(t));
        this._endToken([i, `&${n};`]);
      }
    }
  }
  _consumeRawText(e, t) {
    this._beginToken(e ? l.ESCAPABLE_RAW_TEXT : l.RAW_TEXT);
    let r = [];
    for (; ; ) {
      let n = this._cursor.clone(), i = t();
      if (this._cursor = n, i) break;
      e && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(r.join(""))]), r.length = 0, this._consumeEntity(l.ESCAPABLE_RAW_TEXT), this._beginToken(l.ESCAPABLE_RAW_TEXT)) : r.push(this._readChar());
    }
    this._endToken([this._processCarriageReturns(r.join(""))]);
  }
  _consumeComment(e) {
    this._beginToken(l.COMMENT_START, e), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(l.COMMENT_END), this._requireStr("-->"), this._endToken([]);
  }
  _consumeBogusComment(e) {
    this._beginToken(l.COMMENT_START, e), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(l.COMMENT_END), this._cursor.advance(), this._endToken([]);
  }
  _consumeCdata(e) {
    this._beginToken(l.CDATA_START, e), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(l.CDATA_END), this._requireStr("]]>"), this._endToken([]);
  }
  _consumeDocType(e) {
    this._beginToken(l.DOC_TYPE_START, e), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(l.DOC_TYPE_END), this._cursor.advance(), this._endToken([]);
  }
  _consumePrefixAndName(e) {
    let t = this._cursor.clone(), r = "";
    for (; this._cursor.peek() !== 58 && !Do$1(this._cursor.peek()); ) this._cursor.advance();
    let n;
    this._cursor.peek() === 58 ? (r = this._cursor.getChars(t), this._cursor.advance(), n = this._cursor.clone()) : n = t, this._requireCharCodeUntilFn(e, r === "" ? 0 : 1);
    let i = this._cursor.getChars(n);
    return [r, i];
  }
  _consumeTagOpen(e) {
    let t, r, n, i, s = [];
    try {
      if (this._selectorlessEnabled && zt$1(this._cursor.peek())) i = this._consumeComponentOpenStart(e), [n, r, t] = i.parts, r && (n += `:${r}`), t && (n += `:${t}`), this._attemptCharCodeUntilFn(T$1);
      else {
        if (!Fe$1(this._cursor.peek())) throw this._createError(be$1(this._cursor.peek()), this._cursor.getSpan(e));
        i = this._consumeTagOpenStart(e), r = i.parts[0], t = n = i.parts[1], this._attemptCharCodeUntilFn(T$1);
      }
      for (; !ts(this._cursor.peek()); ) if (this._selectorlessEnabled && this._cursor.peek() === 64) {
        let o = this._cursor.clone(), c = o.clone();
        c.advance(), zt$1(c.peek()) && this._consumeDirective(o, c);
      } else {
        let o = this._consumeAttribute();
        s.push(o);
      }
      i.type === l.COMPONENT_OPEN_START ? this._consumeComponentOpenEnd() : this._consumeTagOpenEnd();
    } catch (o) {
      if (o instanceof re) {
        i ? i.type = i.type === l.COMPONENT_OPEN_START ? l.INCOMPLETE_COMPONENT_OPEN : l.INCOMPLETE_TAG_OPEN : (this._beginToken(l.TEXT, e), this._endToken(["<"]));
        return;
      }
      throw o;
    }
    if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === l.TAG_OPEN_END_VOID) return;
    let a = this._getTagContentType(t, r, this._fullNameStack.length > 0, s);
    this._handleFullNameStackForTagOpen(r, t), a === I$1.RAW_TEXT ? this._consumeRawTextWithTagClose(r, i, n, false) : a === I$1.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(r, i, n, true);
  }
  _consumeRawTextWithTagClose(e, t, r, n) {
    this._consumeRawText(n, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(T$1), !this._attemptStrCaseInsensitive(e && t.type !== l.COMPONENT_OPEN_START ? `${e}:${r}` : r)) ? false : (this._attemptCharCodeUntilFn(T$1), this._attemptCharCode(62))), this._beginToken(t.type === l.COMPONENT_OPEN_START ? l.COMPONENT_CLOSE : l.TAG_CLOSE), this._requireCharCodeUntilFn((i) => i === 62, 3), this._cursor.advance(), this._endToken(t.parts), this._handleFullNameStackForTagClose(e, r);
  }
  _consumeTagOpenStart(e) {
    this._beginToken(l.TAG_OPEN_START, e);
    let t = this._consumePrefixAndName(we$1);
    return this._endToken(t);
  }
  _consumeComponentOpenStart(e) {
    this._beginToken(l.COMPONENT_OPEN_START, e);
    let t = this._consumeComponentName();
    return this._endToken(t);
  }
  _consumeComponentName() {
    let e = this._cursor.clone();
    for (; es(this._cursor.peek()); ) this._cursor.advance();
    let t = this._cursor.getChars(e), r = "", n = "";
    return this._cursor.peek() === 58 && (this._cursor.advance(), [r, n] = this._consumePrefixAndName(we$1)), [t, r, n];
  }
  _consumeAttribute() {
    let [e, t] = this._consumeAttributeName(), r;
    return this._attemptCharCodeUntilFn(T$1), this._attemptCharCode(61) && (this._attemptCharCodeUntilFn(T$1), r = this._consumeAttributeValue()), this._attemptCharCodeUntilFn(T$1), { prefix: e, name: t, value: r };
  }
  _consumeAttributeName() {
    let e = this._cursor.peek();
    if (e === 39 || e === 34) throw this._createError(be$1(e), this._cursor.getSpan());
    this._beginToken(l.ATTR_NAME);
    let t;
    if (this._openDirectiveCount > 0) {
      let n = 0;
      t = (i) => {
        if (this._openDirectiveCount > 0) {
          if (i === 40) n++;
          else if (i === 41) {
            if (n === 0) return true;
            n--;
          }
        }
        return we$1(i);
      };
    } else if (e === 91) {
      let n = 0;
      t = (i) => (i === 91 ? n++ : i === 93 && n--, n <= 0 ? we$1(i) : ut$1(i));
    } else t = we$1;
    let r = this._consumePrefixAndName(t);
    return this._endToken(r), r;
  }
  _consumeAttributeValue() {
    let e;
    if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
      let t = this._cursor.peek();
      this._consumeQuote(t);
      let r = () => this._cursor.peek() === t;
      e = this._consumeWithInterpolation(l.ATTR_VALUE_TEXT, l.ATTR_VALUE_INTERPOLATION, r, r), this._consumeQuote(t);
    } else {
      let t = () => we$1(this._cursor.peek());
      e = this._consumeWithInterpolation(l.ATTR_VALUE_TEXT, l.ATTR_VALUE_INTERPOLATION, t, t);
    }
    return e;
  }
  _consumeQuote(e) {
    this._beginToken(l.ATTR_QUOTE), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]);
  }
  _consumeTagOpenEnd() {
    let e = this._attemptCharCode(47) ? l.TAG_OPEN_END_VOID : l.TAG_OPEN_END;
    this._beginToken(e), this._requireCharCode(62), this._endToken([]);
  }
  _consumeComponentOpenEnd() {
    let e = this._attemptCharCode(47) ? l.COMPONENT_OPEN_END_VOID : l.COMPONENT_OPEN_END;
    this._beginToken(e), this._requireCharCode(62), this._endToken([]);
  }
  _consumeTagClose(e) {
    if (this._selectorlessEnabled) {
      let t = e.clone();
      for (; t.peek() !== 62 && !zt$1(t.peek()); ) t.advance();
      if (zt$1(t.peek())) {
        this._beginToken(l.COMPONENT_CLOSE, e);
        let r = this._consumeComponentName();
        this._attemptCharCodeUntilFn(T$1), this._requireCharCode(62), this._endToken(r);
        return;
      }
    }
    if (this._beginToken(l.TAG_CLOSE, e), this._attemptCharCodeUntilFn(T$1), this._allowHtmComponentClosingTags && this._attemptCharCode(47)) this._attemptCharCodeUntilFn(T$1), this._requireCharCode(62), this._endToken([]);
    else {
      let [t, r] = this._consumePrefixAndName(we$1);
      this._attemptCharCodeUntilFn(T$1), this._requireCharCode(62), this._endToken([t, r]), this._handleFullNameStackForTagClose(t, r);
    }
  }
  _consumeExpansionFormStart() {
    this._beginToken(l.EXPANSION_FORM_START), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(l.EXPANSION_FORM_START), this._beginToken(l.RAW_TEXT);
    let e = this._readUntil(44), t = this._processCarriageReturns(e);
    if (this._i18nNormalizeLineEndingsInICUs) this._endToken([t]);
    else {
      let n = this._endToken([e]);
      t !== e && this.nonNormalizedIcuExpressions.push(n);
    }
    this._requireCharCode(44), this._attemptCharCodeUntilFn(T$1), this._beginToken(l.RAW_TEXT);
    let r = this._readUntil(44);
    this._endToken([r]), this._requireCharCode(44), this._attemptCharCodeUntilFn(T$1);
  }
  _consumeExpansionCaseStart() {
    this._beginToken(l.EXPANSION_CASE_VALUE);
    let e = this._readUntil(123).trim();
    this._endToken([e]), this._attemptCharCodeUntilFn(T$1), this._beginToken(l.EXPANSION_CASE_EXP_START), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(T$1), this._expansionCaseStack.push(l.EXPANSION_CASE_EXP_START);
  }
  _consumeExpansionCaseEnd() {
    this._beginToken(l.EXPANSION_CASE_EXP_END), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(T$1), this._expansionCaseStack.pop();
  }
  _consumeExpansionFormEnd() {
    this._beginToken(l.EXPANSION_FORM_END), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
  }
  _consumeWithInterpolation(e, t, r, n) {
    this._beginToken(e);
    let i = [];
    for (; !r(); ) {
      let a = this._cursor.clone();
      this._attemptStr(mt$1.start) ? (this._endToken([this._processCarriageReturns(i.join(""))], a), i.length = 0, this._consumeInterpolation(t, a, n), this._beginToken(e)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(i.join(""))]), i.length = 0, this._consumeEntity(e), this._beginToken(e)) : i.push(this._readChar());
    }
    this._inInterpolation = false;
    let s = this._processCarriageReturns(i.join(""));
    return this._endToken([s]), s;
  }
  _consumeInterpolation(e, t, r) {
    let n = [];
    this._beginToken(e, t), n.push(mt$1.start);
    let i = this._cursor.clone(), s = null, a = false;
    for (; this._cursor.peek() !== 0 && (r === null || !r()); ) {
      let o = this._cursor.clone();
      if (this._isTagStart()) {
        this._cursor = o, n.push(this._getProcessedChars(i, o)), this._endToken(n);
        return;
      }
      if (s === null) if (this._attemptStr(mt$1.end)) {
        n.push(this._getProcessedChars(i, o)), n.push(mt$1.end), this._endToken(n);
        return;
      } else this._attemptStr("//") && (a = true);
      let c = this._cursor.peek();
      this._cursor.advance(), c === 92 ? this._cursor.advance() : c === s ? s = null : !a && s === null && Ut$1(c) && (s = c);
    }
    n.push(this._getProcessedChars(i, this._cursor)), this._endToken(n);
  }
  _consumeDirective(e, t) {
    for (this._requireCharCode(64), this._cursor.advance(); es(this._cursor.peek()); ) this._cursor.advance();
    this._beginToken(l.DIRECTIVE_NAME, e);
    let r = this._cursor.getChars(t);
    if (this._endToken([r]), this._attemptCharCodeUntilFn(T$1), this._cursor.peek() === 40) {
      for (this._openDirectiveCount++, this._beginToken(l.DIRECTIVE_OPEN), this._cursor.advance(), this._endToken([]), this._attemptCharCodeUntilFn(T$1); !ts(this._cursor.peek()) && this._cursor.peek() !== 41; ) this._consumeAttribute();
      if (this._attemptCharCodeUntilFn(T$1), this._openDirectiveCount--, this._cursor.peek() !== 41) {
        if (this._cursor.peek() === 62 || this._cursor.peek() === 47) return;
        throw this._createError(be$1(this._cursor.peek()), this._cursor.getSpan(e));
      }
      this._beginToken(l.DIRECTIVE_CLOSE), this._cursor.advance(), this._endToken([]), this._attemptCharCodeUntilFn(T$1);
    }
  }
  _getProcessedChars(e, t) {
    return this._processCarriageReturns(t.getChars(e));
  }
  _isTextEnd() {
    return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._isLetStart() || this._cursor.peek() === 125));
  }
  _isTagStart() {
    if (this._cursor.peek() === 60) {
      let e = this._cursor.clone();
      e.advance();
      let t = e.peek();
      if (97 <= t && t <= 122 || 65 <= t && t <= 90 || t === 47 || t === 33) return true;
    }
    return false;
  }
  _readUntil(e) {
    let t = this._cursor.clone();
    return this._attemptUntilChar(e), this._cursor.getChars(t);
  }
  _isInExpansion() {
    return this._isInExpansionCase() || this._isInExpansionForm();
  }
  _isInExpansionCase() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === l.EXPANSION_CASE_EXP_START;
  }
  _isInExpansionForm() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === l.EXPANSION_FORM_START;
  }
  isExpansionFormStart() {
    if (this._cursor.peek() !== 123) return false;
    let e = this._cursor.clone(), t = this._attemptStr(mt$1.start);
    return this._cursor = e, !t;
  }
  _handleFullNameStackForTagOpen(e, t) {
    let r = Se$1(e, t);
    (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === r) && this._fullNameStack.push(r);
  }
  _handleFullNameStackForTagClose(e, t) {
    let r = Se$1(e, t);
    this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === r && this._fullNameStack.pop();
  }
};
function T$1(e) {
  return !lt$4(e) || e === 0;
}
function we$1(e) {
  return lt$4(e) || e === 62 || e === 60 || e === 47 || e === 39 || e === 34 || e === 61 || e === 0;
}
function Do$1(e) {
  return (e < 97 || 122 < e) && (e < 65 || 90 < e) && (e < 48 || e > 57);
}
function Ro$1(e) {
  return e === 59 || e === 0 || !Bi(e);
}
function Io$1(e) {
  return e === 59 || e === 0 || !Fe$1(e);
}
function Mo$1(e) {
  return e !== 125;
}
function Bo$1(e, t) {
  return Ji(e) === Ji(t);
}
function Ji(e) {
  return e >= 97 && e <= 122 ? e - 97 + 65 : e;
}
function Fo$1(e) {
  return Fe$1(e) || ct$1(e) || e === 95;
}
function Zi(e) {
  return e !== 59 && T$1(e);
}
function zt$1(e) {
  return e === 95 || e >= 65 && e <= 90;
}
function es(e) {
  return Fe$1(e) || ct$1(e) || e === 95;
}
function ts(e) {
  return e === 47 || e === 62 || e === 60 || e === 0;
}
function qo$1(e) {
  let t = [], r;
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    r && r.type === l.TEXT && i.type === l.TEXT || r && r.type === l.ATTR_VALUE_TEXT && i.type === l.ATTR_VALUE_TEXT ? (r.parts[0] += i.parts[0], r.sourceSpan.end = i.sourceSpan.end) : (r = i, t.push(r));
  }
  return t;
}
var is = class Br {
  constructor(t, r) {
    if (t instanceof Br) {
      this.file = t.file, this.input = t.input, this.end = t.end;
      let n = t.state;
      this.state = { peek: n.peek, offset: n.offset, line: n.line, column: n.column };
    } else {
      if (!r) throw new Error("Programming error: the range argument must be provided with a file argument.");
      this.file = t, this.input = t.content, this.end = r.endPos, this.state = { peek: -1, offset: r.startPos, line: r.startLine, column: r.startCol };
    }
  }
  clone() {
    return new Br(this);
  }
  peek() {
    return this.state.peek;
  }
  charsLeft() {
    return this.end - this.state.offset;
  }
  diff(t) {
    return this.state.offset - t.state.offset;
  }
  advance() {
    this.advanceState(this.state);
  }
  init() {
    this.updatePeek(this.state);
  }
  getSpan(t, r) {
    t = t || this;
    let n = t;
    if (r) for (; this.diff(t) > 0 && r.indexOf(t.peek()) !== -1; ) n === t && (t = t.clone()), t.advance();
    let i = this.locationFromCursor(t);
    return new h(i, this.locationFromCursor(this), n !== t ? this.locationFromCursor(n) : i);
  }
  getChars(t) {
    return this.input.substring(t.state.offset, this.state.offset);
  }
  charAt(t) {
    return this.input.charCodeAt(t);
  }
  advanceState(t) {
    if (t.offset >= this.end) throw this.state = t, new Vr$1('Unexpected character "EOF"', this);
    let r = this.charAt(t.offset);
    r === 10 ? (t.line++, t.column = 0) : ut$1(r) || t.column++, t.offset++, this.updatePeek(t);
  }
  updatePeek(t) {
    t.peek = t.offset >= this.end ? 0 : this.charAt(t.offset);
  }
  locationFromCursor(t) {
    return new qe$1(t.file, t.state.offset, t.state.line, t.state.column);
  }
}, Ho$1 = class Fr extends is {
  constructor(t, r) {
    t instanceof Fr ? (super(t), this.internalState = { ...t.internalState }) : (super(t, r), this.internalState = this.state);
  }
  advance() {
    this.state = this.internalState, super.advance(), this.processEscapeSequence();
  }
  init() {
    super.init(), this.processEscapeSequence();
  }
  clone() {
    return new Fr(this);
  }
  getChars(t) {
    let r = t.clone(), n = "";
    for (; r.internalState.offset < this.internalState.offset; ) n += String.fromCodePoint(r.peek()), r.advance();
    return n;
  }
  processEscapeSequence() {
    let t = () => this.internalState.peek;
    if (t() === 92) if (this.internalState = { ...this.state }, this.advanceState(this.internalState), t() === 110) this.state.peek = 10;
    else if (t() === 114) this.state.peek = 13;
    else if (t() === 118) this.state.peek = 11;
    else if (t() === 116) this.state.peek = 9;
    else if (t() === 98) this.state.peek = 8;
    else if (t() === 102) this.state.peek = 12;
    else if (t() === 117) if (this.advanceState(this.internalState), t() === 123) {
      this.advanceState(this.internalState);
      let r = this.clone(), n = 0;
      for (; t() !== 125; ) this.advanceState(this.internalState), n++;
      this.state.peek = this.decodeHexDigits(r, n);
    } else {
      let r = this.clone();
      this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 4);
    }
    else if (t() === 120) {
      this.advanceState(this.internalState);
      let r = this.clone();
      this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 2);
    } else if (xr$1(t())) {
      let r = "", n = 0, i = this.clone();
      for (; xr$1(t()) && n < 3; ) i = this.clone(), r += String.fromCodePoint(t()), this.advanceState(this.internalState), n++;
      this.state.peek = parseInt(r, 8), this.internalState = i.internalState;
    } else ut$1(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
  }
  decodeHexDigits(t, r) {
    let n = this.input.slice(t.internalState.offset, t.internalState.offset + r), i = parseInt(n, 16);
    if (isNaN(i)) throw t.state = t.internalState, new Vr$1("Invalid hexadecimal escape sequence", t);
    return i;
  }
}, Vr$1 = class Vr extends Error {
  constructor(e, t) {
    super(e), this.msg = e, this.cursor = t, Object.setPrototypeOf(this, new.target.prototype);
  }
};
var N = class os extends re {
  static create(t, r, n) {
    return new os(t, r, n);
  }
  constructor(t, r, n) {
    super(r, n), this.elementName = t;
  }
}, Vo$1 = class Vo {
  constructor(e, t) {
    this.rootNodes = e, this.errors = t;
  }
}, ls = class {
  constructor(e) {
    this.getTagDefinition = e;
  }
  parse(e, t, r, n = false, i) {
    let s = (m) => (g, ...E) => m(g.toLowerCase(), ...E), a = n ? this.getTagDefinition : s(this.getTagDefinition), o = (m) => a(m).getContentType(), c = n ? i : s(i), u = ns(e, t, i ? (m, g, E, P2) => {
      let z2 = c(m, g, E, P2);
      return z2 !== void 0 ? z2 : o(m);
    } : o, r), p = r && r.canSelfClose || false, d = r && r.allowHtmComponentClosingTags || false, S2 = new Uo$1(u.tokens, a, p, d, n);
    return S2.build(), new Vo$1(S2.rootNodes, [...u.errors, ...S2.errors]);
  }
}, Uo$1 = class cs {
  constructor(t, r, n, i, s) {
    this.tokens = t, this.tagDefinitionResolver = r, this.canSelfClose = n, this.allowHtmComponentClosingTags = i, this.isTagNameCaseSensitive = s, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
  }
  build() {
    for (; this._peek.type !== l.EOF; ) this._peek.type === l.TAG_OPEN_START || this._peek.type === l.INCOMPLETE_TAG_OPEN ? this._consumeElementStartTag(this._advance()) : this._peek.type === l.TAG_CLOSE ? (this._closeVoidElement(), this._consumeElementEndTag(this._advance())) : this._peek.type === l.CDATA_START ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === l.COMMENT_START ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === l.TEXT || this._peek.type === l.RAW_TEXT || this._peek.type === l.ESCAPABLE_RAW_TEXT ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === l.EXPANSION_FORM_START ? this._consumeExpansion(this._advance()) : this._peek.type === l.BLOCK_OPEN_START ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === l.BLOCK_CLOSE ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === l.INCOMPLETE_BLOCK_OPEN ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === l.LET_START ? (this._closeVoidElement(), this._consumeLet(this._advance())) : this._peek.type === l.DOC_TYPE_START ? this._consumeDocType(this._advance()) : this._peek.type === l.INCOMPLETE_LET ? (this._closeVoidElement(), this._consumeIncompleteLet(this._advance())) : this._peek.type === l.COMPONENT_OPEN_START || this._peek.type === l.INCOMPLETE_COMPONENT_OPEN ? this._consumeComponentStartTag(this._advance()) : this._peek.type === l.COMPONENT_CLOSE ? this._consumeComponentEndTag(this._advance()) : this._advance();
    for (let t of this._containerStack) t instanceof ve$1 && this.errors.push(N.create(t.name, t.sourceSpan, `Unclosed block "${t.name}"`));
  }
  _advance() {
    let t = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], t;
  }
  _advanceIf(t) {
    return this._peek.type === t ? this._advance() : null;
  }
  _consumeCdata(t) {
    let r = this._advance(), n = this._getText(r), i = this._advanceIf(l.CDATA_END);
    this._addToParent(new Vi(n, new h(t.sourceSpan.start, (i || r).sourceSpan.end), [r]));
  }
  _consumeComment(t) {
    let r = this._advanceIf(l.RAW_TEXT), n = this._advanceIf(l.COMMENT_END), i = r != null ? r.parts[0].trim() : null, s = n == null ? t.sourceSpan : new h(t.sourceSpan.start, n.sourceSpan.end, t.sourceSpan.fullStart);
    this._addToParent(new $i(i, s));
  }
  _consumeDocType(t) {
    let r = this._advanceIf(l.RAW_TEXT), n = this._advanceIf(l.DOC_TYPE_END), i = r != null ? r.parts[0].trim() : null, s = new h(t.sourceSpan.start, (n || r || t).sourceSpan.end);
    this._addToParent(new zi(i, s));
  }
  _consumeExpansion(t) {
    let r = this._advance(), n = this._advance(), i = [];
    for (; this._peek.type === l.EXPANSION_CASE_VALUE; ) {
      let a = this._parseExpansionCase();
      if (!a) return;
      i.push(a);
    }
    if (this._peek.type !== l.EXPANSION_FORM_END) {
      this.errors.push(N.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      return;
    }
    let s = new h(t.sourceSpan.start, this._peek.sourceSpan.end, t.sourceSpan.fullStart);
    this._addToParent(new Ui(r.parts[0], n.parts[0], i, s, r.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    let t = this._advance();
    if (this._peek.type !== l.EXPANSION_CASE_EXP_START) return this.errors.push(N.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    let r = this._advance(), n = this._collectExpansionExpTokens(r);
    if (!n) return null;
    let i = this._advance();
    n.push({ type: l.EOF, parts: [], sourceSpan: i.sourceSpan });
    let s = new cs(n, this.tagDefinitionResolver, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
    if (s.build(), s.errors.length > 0) return this.errors = this.errors.concat(s.errors), null;
    let a = new h(t.sourceSpan.start, i.sourceSpan.end, t.sourceSpan.fullStart), o = new h(r.sourceSpan.start, i.sourceSpan.end, r.sourceSpan.fullStart);
    return new Wi(t.parts[0], s.rootNodes, a, t.sourceSpan, o);
  }
  _collectExpansionExpTokens(t) {
    let r = [], n = [l.EXPANSION_CASE_EXP_START];
    for (; ; ) {
      if ((this._peek.type === l.EXPANSION_FORM_START || this._peek.type === l.EXPANSION_CASE_EXP_START) && n.push(this._peek.type), this._peek.type === l.EXPANSION_CASE_EXP_END) if (ss(n, l.EXPANSION_CASE_EXP_START)) {
        if (n.pop(), n.length === 0) return r;
      } else return this.errors.push(N.create(null, t.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === l.EXPANSION_FORM_END) if (ss(n, l.EXPANSION_FORM_START)) n.pop();
      else return this.errors.push(N.create(null, t.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === l.EOF) return this.errors.push(N.create(null, t.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      r.push(this._advance());
    }
  }
  _getText(t) {
    let r = t.parts[0];
    if (r.length > 0 && r[0] == `
`) {
      var n;
      let i = this._getClosestElementLikeParent();
      i != null && i.children.length == 0 && (!((n = this._getTagDefinition(i)) === null || n === void 0) && n.ignoreFirstLf) && (r = r.substring(1));
    }
    return r;
  }
  _consumeText(t) {
    let r = [t], n = t.sourceSpan, i = t.parts[0];
    if (i.length > 0 && i[0] === `
`) {
      var s;
      let a = this._getContainer();
      a != null && a.children.length === 0 && (!((s = this._getTagDefinition(a)) === null || s === void 0) && s.ignoreFirstLf) && (i = i.substring(1), r[0] = { type: t.type, sourceSpan: t.sourceSpan, parts: [i] });
    }
    for (; this._peek.type === l.INTERPOLATION || this._peek.type === l.TEXT || this._peek.type === l.ENCODED_ENTITY; ) t = this._advance(), r.push(t), t.type === l.INTERPOLATION ? i += t.parts.join("").replace(/&([^;]+);/g, as) : t.type === l.ENCODED_ENTITY ? i += t.parts[0] : i += t.parts.join("");
    if (i.length > 0) {
      let a = t.sourceSpan;
      this._addToParent(new Hi(i, new h(n.start, a.end, n.fullStart, n.details), r));
    }
  }
  _closeVoidElement() {
    var t;
    let r = this._getContainer();
    r !== null && (!((t = this._getTagDefinition(r)) === null || t === void 0) && t.isVoid) && this._containerStack.pop();
  }
  _consumeElementStartTag(t) {
    var r;
    let n = [], i = [];
    this._consumeAttributesAndDirectives(n, i);
    let s = this._getElementFullName(t, this._getClosestElementLikeParent()), a = this._getTagDefinition(s), o = false;
    if (this._peek.type === l.TAG_OPEN_END_VOID) {
      this._advance(), o = true;
      let E = this._getTagDefinition(s);
      this.canSelfClose || E?.canSelfClose || Me$1(s) !== null || E?.isVoid || this.errors.push(N.create(s, t.sourceSpan, `Only void, custom and foreign elements can be self closed "${t.parts[1]}"`));
    } else this._peek.type === l.TAG_OPEN_END && (this._advance(), o = false);
    let c = this._peek.sourceSpan.fullStart, u = new h(t.sourceSpan.start, c, t.sourceSpan.fullStart), p = new h(t.sourceSpan.start, c, t.sourceSpan.fullStart), d = new h(t.sourceSpan.start.moveBy(1), t.sourceSpan.end), S2 = new ne$1(s, n, i, [], o, u, p, void 0, d, a?.isVoid ?? false), m = this._getContainer(), g = m !== null && !!(!((r = this._getTagDefinition(m)) === null || r === void 0) && r.isClosedByChild(S2.name));
    this._pushContainer(S2, g), o ? this._popContainer(s, ne$1, u) : t.type === l.INCOMPLETE_TAG_OPEN && (this._popContainer(s, ne$1, null), this.errors.push(N.create(s, u, `Opening tag "${s}" not terminated.`)));
  }
  _consumeComponentStartTag(t) {
    var r;
    let n = t.parts[0], i = [], s = [];
    this._consumeAttributesAndDirectives(i, s);
    let a = this._getClosestElementLikeParent(), o = this._getComponentTagName(t, a), c = this._getComponentFullName(t, a), u = this._peek.type === l.COMPONENT_OPEN_END_VOID;
    this._advance();
    let p = this._peek.sourceSpan.fullStart, d = new h(t.sourceSpan.start, p, t.sourceSpan.fullStart), S2 = new h(t.sourceSpan.start, p, t.sourceSpan.fullStart), m = new J(n, o, c, i, s, [], u, d, S2, void 0), g = this._getContainer(), E = g !== null && m.tagName !== null && !!(!((r = this._getTagDefinition(g)) === null || r === void 0) && r.isClosedByChild(m.tagName));
    this._pushContainer(m, E), u ? this._popContainer(c, J, d) : t.type === l.INCOMPLETE_COMPONENT_OPEN && (this._popContainer(c, J, null), this.errors.push(N.create(c, d, `Opening tag "${c}" not terminated.`)));
  }
  _consumeAttributesAndDirectives(t, r) {
    for (; this._peek.type === l.ATTR_NAME || this._peek.type === l.DIRECTIVE_NAME; ) this._peek.type === l.DIRECTIVE_NAME ? r.push(this._consumeDirective(this._peek)) : t.push(this._consumeAttr(this._advance()));
  }
  _consumeComponentEndTag(t) {
    let r = this._getComponentFullName(t, this._getClosestElementLikeParent());
    if (!this._popContainer(r, J, t.sourceSpan)) {
      let n = this._containerStack[this._containerStack.length - 1], i;
      n instanceof J && n.componentName === t.parts[0] ? i = `, did you mean "${n.fullName}"?` : i = ". It may happen when the tag has already been closed by another tag.";
      let s = `Unexpected closing tag "${r}"${i}`;
      this.errors.push(N.create(r, t.sourceSpan, s));
    }
  }
  _getTagDefinition(t) {
    return typeof t == "string" ? this.tagDefinitionResolver(t) : t instanceof ne$1 ? this.tagDefinitionResolver(t.name) : t instanceof J && t.tagName !== null ? this.tagDefinitionResolver(t.tagName) : null;
  }
  _pushContainer(t, r) {
    r && this._containerStack.pop(), this._addToParent(t), this._containerStack.push(t);
  }
  _consumeElementEndTag(t) {
    var r;
    let n = this.allowHtmComponentClosingTags && t.parts.length === 0 ? null : this._getElementFullName(t, this._getClosestElementLikeParent());
    if (n && (!((r = this._getTagDefinition(n)) === null || r === void 0) && r.isVoid)) this.errors.push(N.create(n, t.sourceSpan, `Void elements do not have end tags "${t.parts[1]}"`));
    else if (!this._popContainer(n, ne$1, t.sourceSpan)) {
      let i = `Unexpected closing tag "${n}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this.errors.push(N.create(n, t.sourceSpan, i));
    }
  }
  _popContainer(t, r, n) {
    let i = false;
    for (let a = this._containerStack.length - 1; a >= 0; a--) {
      var s;
      let o = this._containerStack[a], c = o instanceof J ? o.fullName : o.name;
      if (Me$1(c) ? c === t : (c === t || t === null) && o instanceof r) return o.endSourceSpan = n, o.sourceSpan.end = n !== null ? n.end : o.sourceSpan.end, this._containerStack.splice(a, this._containerStack.length - a), !i;
      (o instanceof ve$1 || !(!((s = this._getTagDefinition(o)) === null || s === void 0) && s.closedByParent)) && (i = true);
    }
    return false;
  }
  _consumeAttr(t) {
    let r = Se$1(t.parts[0], t.parts[1]), n = t.sourceSpan.end, i;
    this._peek.type === l.ATTR_QUOTE && (i = this._advance());
    let s = "", a = [], o, c;
    if (this._peek.type === l.ATTR_VALUE_TEXT) for (o = this._peek.sourceSpan, c = this._peek.sourceSpan.end; this._peek.type === l.ATTR_VALUE_TEXT || this._peek.type === l.ATTR_VALUE_INTERPOLATION || this._peek.type === l.ENCODED_ENTITY; ) {
      let p = this._advance();
      a.push(p), p.type === l.ATTR_VALUE_INTERPOLATION ? s += p.parts.join("").replace(/&([^;]+);/g, as) : p.type === l.ENCODED_ENTITY ? s += p.parts[0] : s += p.parts.join(""), c = n = p.sourceSpan.end;
    }
    this._peek.type === l.ATTR_QUOTE && (c = n = this._advance().sourceSpan.end);
    let u = o && c && new h(i?.sourceSpan.start ?? o.start, c, i?.sourceSpan.fullStart ?? o.fullStart);
    return new Gi(r, s, new h(t.sourceSpan.start, n, t.sourceSpan.fullStart), t.sourceSpan, u, a.length > 0 ? a : void 0, void 0);
  }
  _consumeDirective(t) {
    let r = [], n = t.sourceSpan.end, i = null;
    if (this._advance(), this._peek.type === l.DIRECTIVE_OPEN) {
      for (n = this._peek.sourceSpan.end, this._advance(); this._peek.type === l.ATTR_NAME; ) r.push(this._consumeAttr(this._advance()));
      this._peek.type === l.DIRECTIVE_CLOSE ? (i = this._peek.sourceSpan, this._advance()) : this.errors.push(N.create(null, t.sourceSpan, "Unterminated directive definition"));
    }
    let s = new h(t.sourceSpan.start, n, t.sourceSpan.fullStart), a = new h(s.start, i === null ? t.sourceSpan.end : i.end, s.fullStart);
    return new Yi(t.parts[0], r, a, s, i);
  }
  _consumeBlockOpen(t) {
    let r = [];
    for (; this._peek.type === l.BLOCK_PARAMETER; ) {
      let o = this._advance();
      r.push(new Nr(o.parts[0], o.sourceSpan));
    }
    this._peek.type === l.BLOCK_OPEN_END && this._advance();
    let n = this._peek.sourceSpan.fullStart, i = new h(t.sourceSpan.start, n, t.sourceSpan.fullStart), s = new h(t.sourceSpan.start, n, t.sourceSpan.fullStart), a = new ve$1(t.parts[0], r, [], i, t.sourceSpan, s);
    this._pushContainer(a, false);
  }
  _consumeBlockClose(t) {
    this._popContainer(null, ve$1, t.sourceSpan) || this.errors.push(N.create(null, t.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
  }
  _consumeIncompleteBlock(t) {
    let r = [];
    for (; this._peek.type === l.BLOCK_PARAMETER; ) {
      let o = this._advance();
      r.push(new Nr(o.parts[0], o.sourceSpan));
    }
    let n = this._peek.sourceSpan.fullStart, i = new h(t.sourceSpan.start, n, t.sourceSpan.fullStart), s = new h(t.sourceSpan.start, n, t.sourceSpan.fullStart), a = new ve$1(t.parts[0], r, [], i, t.sourceSpan, s);
    this._pushContainer(a, false), this._popContainer(null, ve$1, null), this.errors.push(N.create(t.parts[0], i, `Incomplete block "${t.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
  }
  _consumeLet(t) {
    let r = t.parts[0], n, i;
    if (this._peek.type !== l.LET_VALUE) {
      this.errors.push(N.create(t.parts[0], t.sourceSpan, `Invalid @let declaration "${r}". Declaration must have a value.`));
      return;
    } else n = this._advance();
    if (this._peek.type !== l.LET_END) {
      this.errors.push(N.create(t.parts[0], t.sourceSpan, `Unterminated @let declaration "${r}". Declaration must be terminated with a semicolon.`));
      return;
    } else i = this._advance();
    let s = i.sourceSpan.fullStart, a = new h(t.sourceSpan.start, s, t.sourceSpan.fullStart), o = t.sourceSpan.toString().lastIndexOf(r), c = new h(t.sourceSpan.start.moveBy(o), t.sourceSpan.end), u = new Lr$1(r, n.parts[0], a, c, n.sourceSpan);
    this._addToParent(u);
  }
  _consumeIncompleteLet(t) {
    let r = t.parts[0] ?? "", n = r ? ` "${r}"` : "";
    if (r.length > 0) {
      let i = t.sourceSpan.toString().lastIndexOf(r), s = new h(t.sourceSpan.start.moveBy(i), t.sourceSpan.end), a = new h(t.sourceSpan.start, t.sourceSpan.start.moveBy(0)), o = new Lr$1(r, "", t.sourceSpan, s, a);
      this._addToParent(o);
    }
    this.errors.push(N.create(t.parts[0], t.sourceSpan, `Incomplete @let declaration${n}. @let declarations must be written as \`@let <name> = <value>;\``));
  }
  _getContainer() {
    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
  }
  _getClosestElementLikeParent() {
    for (let t = this._containerStack.length - 1; t > -1; t--) {
      let r = this._containerStack[t];
      if (r instanceof ne$1 || r instanceof J) return r;
    }
    return null;
  }
  _addToParent(t) {
    let r = this._getContainer();
    r === null ? this.rootNodes.push(t) : r.children.push(t);
  }
  _getElementFullName(t, r) {
    return Se$1(this._getPrefix(t, r), t.parts[1]);
  }
  _getComponentFullName(t, r) {
    let n = t.parts[0], i = this._getComponentTagName(t, r);
    return i === null ? n : i.startsWith(":") ? n + i : `${n}:${i}`;
  }
  _getComponentTagName(t, r) {
    let n = this._getPrefix(t, r), i = t.parts[2];
    return !n && !i ? null : !n && i ? i : Se$1(n, i || "ng-component");
  }
  _getPrefix(t, r) {
    var n;
    let i, s;
    if (t.type === l.COMPONENT_OPEN_START || t.type === l.INCOMPLETE_COMPONENT_OPEN || t.type === l.COMPONENT_CLOSE ? (i = t.parts[1], s = t.parts[2]) : (i = t.parts[0], s = t.parts[1]), i = i || ((n = this._getTagDefinition(s)) === null || n === void 0 ? void 0 : n.implicitNamespacePrefix) || "", !i && r) {
      let a = r instanceof ne$1 ? r.name : r.tagName;
      if (a !== null) {
        let o = at$1(a)[1], c = this._getTagDefinition(o);
        c !== null && !c.preventNamespaceInheritance && (i = Me$1(a));
      }
    }
    return i;
  }
};
function ss(e, t) {
  return e.length > 0 && e[e.length - 1] === t;
}
function as(e, t) {
  return Te[t] !== void 0 ? Te[t] || e : /^#x[a-f0-9]+$/i.test(t) ? String.fromCodePoint(parseInt(t.slice(2), 16)) : /^#\d+$/.test(t) ? String.fromCodePoint(parseInt(t.slice(1), 10)) : e;
}
var us = class extends ls {
  constructor() {
    super(Be$1);
  }
  parse(e, t, r, n = false, i) {
    return super.parse(e, t, r, n, i);
  }
};
var Ur$1 = null, Wo$1 = () => (Ur$1 || (Ur$1 = new us()), Ur$1);
function Qt$1(e, t = {}) {
  let { canSelfClose: r = false, allowHtmComponentClosingTags: n = false, isTagNameCaseSensitive: i = false, getTagContentType: s, tokenizeAngularBlocks: a = false, tokenizeAngularLetDeclaration: o = false, enableAngularSelectorlessSyntax: c = false } = t;
  return Wo$1().parse(e, "angular-html-parser", { tokenizeExpansionForms: a, canSelfClose: r, allowHtmComponentClosingTags: n, tokenizeBlocks: a, tokenizeLet: o, selectorlessEnabled: c }, i, s);
}
var Go$1 = [zo$1, Yo$1, Xo$1, Qo$1, Jo$1, tl, Zo$1, el$1, rl, Ko$1];
function $o$1(e, t) {
  for (let r of Go$1) r(e, t);
  return e;
}
function zo$1(e) {
  e.walk((t) => {
    if (t.kind === "element" && t.tagDefinition.ignoreFirstLf && t.children.length > 0 && t.children[0].kind === "text" && t.children[0].value[0] === `
`) {
      let r = t.children[0];
      r.value.length === 1 ? t.removeChild(r) : r.value = r.value.slice(1);
    }
  });
}
function Yo$1(e) {
  let t = (r) => r.kind === "element" && r.prev?.kind === "ieConditionalStartComment" && r.prev.sourceSpan.end.offset === r.startSourceSpan.start.offset && r.firstChild?.kind === "ieConditionalEndComment" && r.firstChild.sourceSpan.start.offset === r.startSourceSpan.end.offset;
  e.walk((r) => {
    if (r.children) for (let n = 0; n < r.children.length; n++) {
      let i = r.children[n];
      if (!t(i)) continue;
      let s = i.prev, a = i.firstChild;
      r.removeChild(s), n--;
      let o = new h(s.sourceSpan.start, a.sourceSpan.end), c = new h(o.start, i.sourceSpan.end);
      i.condition = s.condition, i.sourceSpan = c, i.startSourceSpan = o, i.removeChild(a);
    }
  });
}
function jo$1(e, t, r) {
  e.walk((n) => {
    if (n.children) for (let i = 0; i < n.children.length; i++) {
      let s = n.children[i];
      if (s.kind !== "text" && !t(s)) continue;
      s.kind !== "text" && (s.kind = "text", s.value = r(s));
      let a = s.prev;
      !a || a.kind !== "text" || (a.value += s.value, a.sourceSpan = new h(a.sourceSpan.start, s.sourceSpan.end), n.removeChild(s), i--);
    }
  });
}
function Xo$1(e) {
  return jo$1(e, (t) => t.kind === "cdata", (t) => `<![CDATA[${t.value}]]>`);
}
function Ko$1(e) {
  let t = (r) => r.kind === "element" && r.attrs.length === 0 && r.children.length === 1 && r.firstChild.kind === "text" && !x$1.hasWhitespaceCharacter(r.children[0].value) && !r.firstChild.hasLeadingSpaces && !r.firstChild.hasTrailingSpaces && r.isLeadingSpaceSensitive && !r.hasLeadingSpaces && r.isTrailingSpaceSensitive && !r.hasTrailingSpaces && r.prev?.kind === "text" && r.next?.kind === "text";
  e.walk((r) => {
    if (r.children) for (let n = 0; n < r.children.length; n++) {
      let i = r.children[n];
      if (!t(i)) continue;
      let s = i.prev, a = i.next;
      s.value += `<${i.rawName}>` + i.firstChild.value + `</${i.rawName}>` + a.value, s.sourceSpan = new h(s.sourceSpan.start, a.sourceSpan.end), s.isTrailingSpaceSensitive = a.isTrailingSpaceSensitive, s.hasTrailingSpaces = a.hasTrailingSpaces, r.removeChild(i), n--, r.removeChild(a);
    }
  });
}
function Qo$1(e, t) {
  if (t.parser === "html") return;
  let r = /\{\{(.+?)\}\}/su;
  e.walk((n) => {
    if (An$1(n, t)) for (let i of n.children) {
      if (i.kind !== "text") continue;
      let s = i.sourceSpan.start, a = null, o = i.value.split(r);
      for (let c = 0; c < o.length; c++, s = a) {
        let u = o[c];
        if (c % 2 === 0) {
          a = s.moveBy(u.length), u.length > 0 && n.insertChildBefore(i, { kind: "text", value: u, sourceSpan: new h(s, a) });
          continue;
        }
        a = s.moveBy(u.length + 4), n.insertChildBefore(i, { kind: "interpolation", sourceSpan: new h(s, a), children: u.length === 0 ? [] : [{ kind: "text", value: u, sourceSpan: new h(s.moveBy(2), a.moveBy(-2)) }] });
      }
      n.removeChild(i);
    }
  });
}
function Jo$1(e, t) {
  e.walk((r) => {
    let n = r.$children;
    if (!n) return;
    if (n.length === 0 || n.length === 1 && n[0].kind === "text" && x$1.trim(n[0].value).length === 0) {
      r.hasDanglingSpaces = n.length > 0, r.$children = [];
      return;
    }
    let i = yn$1(r, t), s = dr$1(r);
    if (!i) for (let a = 0; a < n.length; a++) {
      let o = n[a];
      if (o.kind !== "text") continue;
      let { leadingWhitespace: c, text: u, trailingWhitespace: p } = kn$1(o.value), d = o.prev, S2 = o.next;
      u ? (o.value = u, o.sourceSpan = new h(o.sourceSpan.start.moveBy(c.length), o.sourceSpan.end.moveBy(-p.length)), c && (d && (d.hasTrailingSpaces = true), o.hasLeadingSpaces = true), p && (o.hasTrailingSpaces = true, S2 && (S2.hasLeadingSpaces = true))) : (r.removeChild(o), a--, (c || p) && (d && (d.hasTrailingSpaces = true), S2 && (S2.hasLeadingSpaces = true)));
    }
    r.isWhitespaceSensitive = i, r.isIndentationSensitive = s;
  });
}
function Zo$1(e) {
  e.walk((t) => {
    t.isSelfClosing = !t.children || t.kind === "element" && (t.tagDefinition.isVoid || t.endSourceSpan && t.startSourceSpan.start === t.endSourceSpan.start && t.startSourceSpan.end === t.endSourceSpan.end);
  });
}
function el$1(e, t) {
  e.walk((r) => {
    r.kind === "element" && (r.hasHtmComponentClosingTag = r.endSourceSpan && /^<\s*\/\s*\/\s*>$/u.test(t.originalText.slice(r.endSourceSpan.start.offset, r.endSourceSpan.end.offset)));
  });
}
function tl(e, t) {
  e.walk((r) => {
    r.cssDisplay = Bn$1(r, t);
  });
}
function rl(e, t) {
  e.walk((r) => {
    let { children: n } = r;
    if (n) {
      if (n.length === 0) {
        r.isDanglingSpaceSensitive = Ln$1(r, t);
        return;
      }
      for (let i of n) i.isLeadingSpaceSensitive = xn$1(i, t), i.isTrailingSpaceSensitive = Nn$1(i, t);
      for (let i = 0; i < n.length; i++) {
        let s = n[i];
        s.isLeadingSpaceSensitive = (i === 0 || s.prev.isTrailingSpaceSensitive) && s.isLeadingSpaceSensitive, s.isTrailingSpaceSensitive = (i === n.length - 1 || s.next.isLeadingSpaceSensitive) && s.isTrailingSpaceSensitive;
      }
    }
  });
}
var ps = $o$1;
function nl(e, t, r) {
  let { node: n } = e;
  switch (n.kind) {
    case "root":
      return t.__onHtmlRoot && t.__onHtmlRoot(n), [C(Ie$1(e, t, r)), v$1];
    case "element":
    case "ieConditionalComment":
      return Pi$1(e, t, r);
    case "angularControlFlowBlock":
      return Ai(e, t, r);
    case "angularControlFlowBlockParameters":
      return xi$1(e, t, r);
    case "angularControlFlowBlockParameter":
      return x$1.trim(n.expression);
    case "angularLetDeclaration":
      return C(["@let ", C([n.id, " =", C(y([_$1, r("init")]))]), ";"]);
    case "angularLetDeclarationInitializer":
      return n.value;
    case "angularIcuExpression":
      return Ni(e, t, r);
    case "angularIcuCase":
      return Li(e, t, r);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [_e$1(n), me$1(n)];
    case "interpolation":
      return [_e$1(n, t), ...e.map(r, "children"), me$1(n, t)];
    case "text": {
      if (n.parent.kind === "interpolation") {
        let o = /\n[^\S\n]*$/u, c = o.test(n.value), u = c ? n.value.replace(o, "") : n.value;
        return [L$1(u), c ? v$1 : ""];
      }
      let i = U$1(n, t), s = Ot(n), a = V$1(n, t);
      return s[0] = [i, s[0]], s.push([s.pop(), a]), kt$1(s);
    }
    case "docType":
      return [C([_e$1(n, t), " ", w$1(0, n.value.replace(/^html\b/iu, "html"), /\s+/gu, " ")]), me$1(n, t)];
    case "comment":
      return [U$1(n, t), L$1(t.originalText.slice(Q(n), te$1(n))), V$1(n, t)];
    case "attribute": {
      if (n.value === null) return n.rawName;
      let i = Sr$1(n.value), s = Rt(n, t) ? "" : pn(i, '"');
      return [n.rawName, "=", s, L$1(s === '"' ? w$1(0, i, '"', "&quot;") : w$1(0, i, "'", "&apos;")), s];
    }
    case "frontMatter":
    case "cdata":
    default:
      throw new mn$1(n, "HTML");
  }
}
var il = { features: { experimental_frontMatterSupport: { massageAstNode: true, embed: true, print: true } }, preprocess: ps, print: nl, insertPragma: bi, massageAstNode: dn$1, embed: fi$1, getVisitorKeys: _i }, hs = il;
var ms = [{ name: "Angular", type: "markup", aceMode: "html", extensions: [".component.html"], tmScope: "text.html.basic", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [], linguistLanguageId: 146 }, { name: "HTML", type: "markup", aceMode: "html", extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], tmScope: "text.html.basic", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["html"], vscodeLanguageIds: ["html"], linguistLanguageId: 146 }, { name: "Lightning Web Components", type: "markup", aceMode: "html", extensions: [], tmScope: "text.html.basic", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [], linguistLanguageId: 146 }, { name: "MJML", type: "markup", aceMode: "html", extensions: [".mjml"], tmScope: "text.mjml.basic", aliases: ["MJML", "mjml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["mjml"], filenames: [], vscodeLanguageIds: ["mjml"], linguistLanguageId: 146 }, { name: "Vue", type: "markup", aceMode: "vue", extensions: [".vue"], tmScope: "source.vue", codemirrorMode: "vue", codemirrorMimeType: "text/x-vue", parsers: ["vue"], vscodeLanguageIds: ["vue"], linguistLanguageId: 391 }];
var Wr$1 = { bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
var fs = "HTML", sl = { bracketSameLine: Wr$1.bracketSameLine, htmlWhitespaceSensitivity: { category: fs, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: Wr$1.singleAttributePerLine, vueIndentScriptAndStyle: { category: fs, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } }, ds = sl;
var Qr$1 = {};
en$1(Qr$1, { angular: () => kl, html: () => Tl, lwc: () => yl, mjml: () => wl, vue: () => Al });
function al(e, t) {
  let r = new SyntaxError(e + " (" + t.loc.start.line + ":" + t.loc.start.column + ")");
  return Object.assign(r, t);
}
var gs = al;
var ol = { canSelfClose: true, normalizeTagName: false, normalizeAttributeName: false, allowHtmComponentClosingTags: false, isTagNameCaseSensitive: false, shouldParseFrontMatter: true };
function Jt$1(e) {
  return { ...ol, ...e };
}
function Gr$1(e) {
  let { canSelfClose: t, allowHtmComponentClosingTags: r, isTagNameCaseSensitive: n, shouldParseAsRawText: i, tokenizeAngularBlocks: s, tokenizeAngularLetDeclaration: a } = e;
  return { canSelfClose: t, allowHtmComponentClosingTags: r, isTagNameCaseSensitive: n, getTagContentType: i ? (...o) => i(...o) ? I$1.RAW_TEXT : void 0 : void 0, tokenizeAngularBlocks: s, tokenizeAngularLetDeclaration: a };
}
var Zt$1 = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set(["accesskey", "autocapitalize", "autocorrect", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "exportparts", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "part", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate", "writingsuggestions"])], ["a", /* @__PURE__ */ new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])], ["applet", /* @__PURE__ */ new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])], ["area", /* @__PURE__ */ new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])], ["audio", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])], ["base", /* @__PURE__ */ new Set(["href", "target"])], ["basefont", /* @__PURE__ */ new Set(["color", "face", "size"])], ["blockquote", /* @__PURE__ */ new Set(["cite"])], ["body", /* @__PURE__ */ new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])], ["br", /* @__PURE__ */ new Set(["clear"])], ["button", /* @__PURE__ */ new Set(["command", "commandfor", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])], ["canvas", /* @__PURE__ */ new Set(["height", "width"])], ["caption", /* @__PURE__ */ new Set(["align"])], ["col", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["colgroup", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["data", /* @__PURE__ */ new Set(["value"])], ["del", /* @__PURE__ */ new Set(["cite", "datetime"])], ["details", /* @__PURE__ */ new Set(["name", "open"])], ["dialog", /* @__PURE__ */ new Set(["closedby", "open"])], ["dir", /* @__PURE__ */ new Set(["compact"])], ["div", /* @__PURE__ */ new Set(["align"])], ["dl", /* @__PURE__ */ new Set(["compact"])], ["embed", /* @__PURE__ */ new Set(["height", "src", "type", "width"])], ["fieldset", /* @__PURE__ */ new Set(["disabled", "form", "name"])], ["font", /* @__PURE__ */ new Set(["color", "face", "size"])], ["form", /* @__PURE__ */ new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])], ["frame", /* @__PURE__ */ new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])], ["frameset", /* @__PURE__ */ new Set(["cols", "rows"])], ["h1", /* @__PURE__ */ new Set(["align"])], ["h2", /* @__PURE__ */ new Set(["align"])], ["h3", /* @__PURE__ */ new Set(["align"])], ["h4", /* @__PURE__ */ new Set(["align"])], ["h5", /* @__PURE__ */ new Set(["align"])], ["h6", /* @__PURE__ */ new Set(["align"])], ["head", /* @__PURE__ */ new Set(["profile"])], ["hr", /* @__PURE__ */ new Set(["align", "noshade", "size", "width"])], ["html", /* @__PURE__ */ new Set(["manifest", "version"])], ["iframe", /* @__PURE__ */ new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])], ["img", /* @__PURE__ */ new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])], ["input", /* @__PURE__ */ new Set(["accept", "align", "alpha", "alt", "autocomplete", "checked", "colorspace", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])], ["ins", /* @__PURE__ */ new Set(["cite", "datetime"])], ["isindex", /* @__PURE__ */ new Set(["prompt"])], ["label", /* @__PURE__ */ new Set(["for", "form"])], ["legend", /* @__PURE__ */ new Set(["align"])], ["li", /* @__PURE__ */ new Set(["type", "value"])], ["link", /* @__PURE__ */ new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])], ["map", /* @__PURE__ */ new Set(["name"])], ["menu", /* @__PURE__ */ new Set(["compact"])], ["meta", /* @__PURE__ */ new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])], ["meter", /* @__PURE__ */ new Set(["high", "low", "max", "min", "optimum", "value"])], ["object", /* @__PURE__ */ new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])], ["ol", /* @__PURE__ */ new Set(["compact", "reversed", "start", "type"])], ["optgroup", /* @__PURE__ */ new Set(["disabled", "label"])], ["option", /* @__PURE__ */ new Set(["disabled", "label", "selected", "value"])], ["output", /* @__PURE__ */ new Set(["for", "form", "name"])], ["p", /* @__PURE__ */ new Set(["align"])], ["param", /* @__PURE__ */ new Set(["name", "type", "value", "valuetype"])], ["pre", /* @__PURE__ */ new Set(["width"])], ["progress", /* @__PURE__ */ new Set(["max", "value"])], ["q", /* @__PURE__ */ new Set(["cite"])], ["script", /* @__PURE__ */ new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])], ["select", /* @__PURE__ */ new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])], ["slot", /* @__PURE__ */ new Set(["name"])], ["source", /* @__PURE__ */ new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])], ["style", /* @__PURE__ */ new Set(["blocking", "media", "type"])], ["table", /* @__PURE__ */ new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])], ["tbody", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["td", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["template", /* @__PURE__ */ new Set(["shadowrootclonable", "shadowrootcustomelementregistry", "shadowrootdelegatesfocus", "shadowrootmode", "shadowrootserializable"])], ["textarea", /* @__PURE__ */ new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])], ["tfoot", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["th", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["thead", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["time", /* @__PURE__ */ new Set(["datetime"])], ["tr", /* @__PURE__ */ new Set(["align", "bgcolor", "char", "charoff", "valign"])], ["track", /* @__PURE__ */ new Set(["default", "kind", "label", "src", "srclang"])], ["ul", /* @__PURE__ */ new Set(["compact", "type"])], ["video", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])]]);
var _s = /* @__PURE__ */ new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "em", "embed", "fencedframe", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "selectedcontent", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
var er$1 = { attrs: true, children: true, cases: true, expression: true }, Ss = /* @__PURE__ */ new Set(["parent"]), ae$1, $r$1, zr$1, We$1 = class We {
  constructor(t = {}) {
    tn$1(this, ae$1);
    ir$1(this, "kind");
    ir$1(this, "parent");
    for (let r of /* @__PURE__ */ new Set([...Ss, ...Object.keys(t)])) this.setProperty(r, t[r]);
    if (le$2(t)) for (let r of Object.getOwnPropertySymbols(t)) this.setProperty(r, t[r]);
  }
  setProperty(t, r) {
    if (this[t] !== r) {
      if (t in er$1 && (r = r.map((n) => this.createChild(n))), !Ss.has(t)) {
        this[t] = r;
        return;
      }
      Object.defineProperty(this, t, { value: r, enumerable: false, configurable: true });
    }
  }
  map(t) {
    let r;
    for (let n in er$1) {
      let i = this[n];
      if (i) {
        let s = ll$1(i, (a) => a.map(t));
        r !== i && (r || (r = new We({ parent: this.parent })), r.setProperty(n, s));
      }
    }
    if (r) for (let n in this) n in er$1 || (r[n] = this[n]);
    return t(r || this);
  }
  walk(t) {
    for (let r in er$1) {
      let n = this[r];
      if (n) for (let i = 0; i < n.length; i++) n[i].walk(t);
    }
    t(this);
  }
  createChild(t) {
    let r = t instanceof We ? t.clone() : new We(t);
    return r.setProperty("parent", this), r;
  }
  insertChildBefore(t, r) {
    let n = this.$children;
    n.splice(n.indexOf(t), 0, this.createChild(r));
  }
  removeChild(t) {
    let r = this.$children;
    r.splice(r.indexOf(t), 1);
  }
  replaceChild(t, r) {
    let n = this.$children;
    n[n.indexOf(t)] = this.createChild(r);
  }
  clone() {
    return new We(this);
  }
  get $children() {
    return this[$e(this, ae$1, $r$1)];
  }
  set $children(t) {
    this[$e(this, ae$1, $r$1)] = t;
  }
  get firstChild() {
    return this.$children?.[0];
  }
  get lastChild() {
    return F(1, this.$children, -1);
  }
  get prev() {
    let t = $e(this, ae$1, zr$1);
    return t[t.indexOf(this) - 1];
  }
  get next() {
    let t = $e(this, ae$1, zr$1);
    return t[t.indexOf(this) + 1];
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
  get attrMap() {
    return Object.fromEntries(this.attrs.map((t) => [t.fullName, t.value]));
  }
};
ae$1 = /* @__PURE__ */ new WeakSet(), $r$1 = function() {
  return this.kind === "angularIcuCase" ? "expression" : this.kind === "angularIcuExpression" ? "cases" : "children";
}, zr$1 = function() {
  return this.parent?.$children ?? [];
};
var tr$1 = We$1;
function ll$1(e, t) {
  let r = e.map(t);
  return r.some((n, i) => n !== e[i]) ? r : e;
}
var cl = [{ regex: /^(?<openingTagSuffix>\[if(?<condition>[^\]]*)\]>)(?<data>.*?)<!\s*\[endif\]$/su, parse: ul }, { regex: /^\[if(?<condition>[^\]]*)\]><!$/u, parse: pl }, { regex: /^<!\s*\[endif\]$/u, parse: hl }];
function Es(e, t) {
  if (e.value) for (let { regex: r, parse: n } of cl) {
    let i = e.value.match(r);
    if (i) return n(e, i, t);
  }
  return null;
}
function ul(e, t, r) {
  let { openingTagSuffix: n, condition: i, data: s } = t.groups, a = 4 + n.length, o = e.sourceSpan.start.moveBy(a), c = o.moveBy(s.length), [u, p] = (() => {
    try {
      return [true, r(s, o).children];
    } catch {
      return [false, [{ kind: "text", value: s, sourceSpan: new h(o, c) }]];
    }
  })();
  return { kind: "ieConditionalComment", complete: u, children: p, condition: w$1(0, i.trim(), /\s+/gu, " "), sourceSpan: e.sourceSpan, startSourceSpan: new h(e.sourceSpan.start, o), endSourceSpan: new h(c, e.sourceSpan.end) };
}
function pl(e, t) {
  let { condition: r } = t.groups;
  return { kind: "ieConditionalStartComment", condition: w$1(0, r.trim(), /\s+/gu, " "), sourceSpan: e.sourceSpan };
}
function hl(e) {
  return { kind: "ieConditionalEndComment", sourceSpan: e.sourceSpan };
}
var Yr$1 = class Yr extends Pr$2 {
  visitExpansionCase(t, r) {
    r.parseOptions.name === "angular" && this.visitChildren(r, (n) => {
      n(t.expression);
    });
  }
  visit(t, { parseOptions: r }) {
    gl$1(t), _l(t, r), El(t, r), Sl(t);
  }
};
function Ts(e, t, r, n) {
  Wt$1(new Yr$1(), e.children, { parseOptions: r }), t && e.children.unshift(t);
  let i = new tr$1(e);
  return i.walk((s) => {
    if (s.kind === "comment") {
      let a = Es(s, n);
      a && s.parent.replaceChild(s, a);
    }
    ml(s), fl(s), dl(s);
  }), i;
}
function ml(e) {
  if (e.kind === "block") {
    if (e.name = w$1(0, e.name.toLowerCase(), /\s+/gu, " ").trim(), e.kind = "angularControlFlowBlock", !Re$2(e.parameters)) {
      delete e.parameters;
      return;
    }
    for (let t of e.parameters) t.kind = "angularControlFlowBlockParameter";
    e.parameters = { kind: "angularControlFlowBlockParameters", children: e.parameters, sourceSpan: new h(e.parameters[0].sourceSpan.start, F(0, e.parameters, -1).sourceSpan.end) };
  }
}
function fl(e) {
  e.kind === "letDeclaration" && (e.kind = "angularLetDeclaration", e.id = e.name, e.init = { kind: "angularLetDeclarationInitializer", sourceSpan: new h(e.valueSpan.start, e.valueSpan.end), value: e.value }, delete e.name, delete e.value);
}
function dl(e) {
  e.kind === "expansion" && (e.kind = "angularIcuExpression"), e.kind === "expansionCase" && (e.kind = "angularIcuCase");
}
function Cs(e, t) {
  let r = e.toLowerCase();
  return t(r) ? r : e;
}
function vs(e) {
  let t = e.name.startsWith(":") ? e.name.slice(1).split(":")[0] : null, r = e.nameSpan.toString(), n = t !== null && r.startsWith(`${t}:`), i = n ? r.slice(t.length + 1) : r;
  e.name = i, e.namespace = t, e.hasExplicitNamespace = n;
}
function gl$1(e) {
  switch (e.kind) {
    case "element":
      vs(e);
      for (let t of e.attrs) vs(t), t.valueSpan ? (t.value = t.valueSpan.toString(), /["']/u.test(t.value[0]) && (t.value = t.value.slice(1, -1))) : t.value = null;
      break;
    case "comment":
      e.value = e.sourceSpan.toString().slice(4, -3);
      break;
    case "text":
      e.value = e.sourceSpan.toString();
      break;
  }
}
function _l(e, t) {
  if (e.kind === "element") {
    let r = Be$1(t.isTagNameCaseSensitive ? e.name : e.name.toLowerCase());
    !e.namespace || e.namespace === r.implicitNamespacePrefix || ce$1(e) ? e.tagDefinition = r : e.tagDefinition = Be$1("");
  }
}
function Sl(e) {
  e.sourceSpan && e.endSourceSpan && (e.sourceSpan = new h(e.sourceSpan.start, e.endSourceSpan.end));
}
function El(e, t) {
  if (e.kind === "element" && (t.normalizeTagName && (!e.namespace || e.namespace === e.tagDefinition.implicitNamespacePrefix || ce$1(e)) && (e.name = Cs(e.name, (r) => _s.has(r))), t.normalizeAttributeName)) for (let r of e.attrs) r.namespace || (r.name = Cs(r.name, (n) => Zt$1.has(e.name) && (Zt$1.get("*").has(n) || Zt$1.get(e.name).has(n))));
}
function Xr$1(e, t) {
  let { rootNodes: r, errors: n } = Qt$1(e, Gr$1(t));
  return n.length > 0 && jr$1(n[0]), { parseOptions: t, rootNodes: r };
}
function bs(e, t) {
  let r = Gr$1(t), { rootNodes: n, errors: i } = Qt$1(e, r);
  if (n.some((u) => u.kind === "docType" && u.value === "html" || u.kind === "element" && u.name.toLowerCase() === "html")) return Xr$1(e, rr$1);
  let a, o = () => a ?? (a = Qt$1(e, { ...r, getTagContentType: void 0 })), c = (u) => {
    let { offset: p } = u.startSourceSpan.start;
    return o().rootNodes.find((d) => d.kind === "element" && d.startSourceSpan.start.offset === p) ?? u;
  };
  for (let [u, p] of n.entries()) if (p.kind === "element") {
    if (p.isVoid) i = o().errors, n[u] = c(p);
    else if (Cl(p)) {
      let { endSourceSpan: d, startSourceSpan: S2 } = p, m = o().errors.find((g) => g.span.start.offset > S2.start.offset && g.span.start.offset < d.end.offset);
      m && jr$1(m), n[u] = c(p);
    }
  }
  return i.length > 0 && jr$1(i[0]), { parseOptions: t, rootNodes: n };
}
function Cl(e) {
  if (e.kind !== "element" || e.name !== "template") return false;
  let t = e.attrs.find((r) => r.name === "lang")?.value;
  return !t || t === "html";
}
function jr$1(e) {
  let { msg: t, span: { start: r, end: n } } = e;
  throw gs(t, { loc: { start: { line: r.line + 1, column: r.col + 1 }, end: { line: n.line + 1, column: n.col + 1 } }, cause: e });
}
function vl(e, t, r, n, i, s) {
  let { offset: a } = n, o = w$1(0, t.slice(0, a), /[^\n]/gu, " ") + r, c = Kr$1(o, e, { ...i, shouldParseFrontMatter: false }, s);
  c.sourceSpan = new h(n, F(0, c.children, -1).sourceSpan.end);
  let u = c.children[0];
  return u.length === a ? c.children.shift() : (u.sourceSpan = new h(u.sourceSpan.start.moveBy(a), u.sourceSpan.end), u.value = u.value.slice(a)), c;
}
function Kr$1(e, t, r, n = {}) {
  let { frontMatter: i, content: s } = r.shouldParseFrontMatter ? pr$2(e) : { content: e }, a = new ht$1(e, n.filepath), o = new qe$1(a, 0, 0, 0), c = o.moveBy(e.length), { parseOptions: u, rootNodes: p } = t(s, r), d = { kind: "root", sourceSpan: new h(o, c), children: p }, S2;
  if (i) {
    let [g, E] = [i.start, i.end].map((P2) => new qe$1(a, P2.index, P2.line - 1, P2.column));
    S2 = { ...i, kind: "frontMatter", sourceSpan: new h(g, E) };
  }
  return Ts(d, S2, u, (g, E) => vl(t, e, g, E, u, n));
}
var rr$1 = Jt$1({ name: "html", normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true });
function dt$1(e) {
  let t = Jt$1(e), r = t.name === "vue" ? bs : Xr$1;
  return { parse: (n, i) => Kr$1(n, r, t, i), hasPragma: vi, hasIgnorePragma: Ti, astFormat: "html", locStart: Q, locEnd: te$1 };
}
var Tl = dt$1(rr$1), bl = /* @__PURE__ */ new Set(["mj-style", "mj-raw"]), wl = dt$1({ ...rr$1, name: "mjml", shouldParseAsRawText: (e) => bl.has(e) }), kl = dt$1({ name: "angular", tokenizeAngularBlocks: true, tokenizeAngularLetDeclaration: true }), Al = dt$1({ name: "vue", isTagNameCaseSensitive: true, shouldParseAsRawText(e, t, r, n) {
  return e.toLowerCase() !== "html" && !r && (e !== "template" || n.some(({ name: i, value: s }) => i === "lang" && s !== "html" && s !== "" && s !== void 0));
} }), yl = dt$1({ name: "lwc", canSelfClose: false });
var xl = { html: hs };
const html = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ws$1,
  languages: ms,
  options: ds,
  parsers: Qr$1,
  printers: xl
}, Symbol.toStringTag, { value: "Module" }));
var Zn = Object.create;
var Mt = Object.defineProperty;
var eo = Object.getOwnPropertyDescriptor;
var to = Object.getOwnPropertyNames;
var uo = Object.getPrototypeOf, ro = Object.prototype.hasOwnProperty;
var no = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Yt = (e, t) => {
  for (var u in t) Mt(e, u, { get: t[u], enumerable: true });
}, oo = (e, t, u, r) => {
  if (t && typeof t == "object" || typeof t == "function") for (let o of to(t)) !ro.call(e, o) && o !== u && Mt(e, o, { get: () => t[o], enumerable: !(r = eo(t, o)) || r.enumerable });
  return e;
};
var ao = (e, t, u) => (u = e != null ? Zn(uo(e)) : {}, oo(Mt(u, "default", { value: e, enumerable: true }), e));
var dn = no((of, ln2) => {
  var yt2, bt2, At2, _t2, xt2, $e2, bu, Ke2, Bt2, cn2, Tt2, Ve, Nt2, St2, wt2, pe2, fn2, Ot2, Pt2;
  Nt2 = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]|[^\/\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu;
  Ve = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
  yt2 = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu;
  wt2 = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y;
  Tt2 = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
  pe2 = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y;
  Pt2 = /[\t\v\f\ufeff\p{Zs}]+/yu;
  Ke2 = /\r?\n|[\r\u2028\u2029]/y;
  Bt2 = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y;
  St2 = /\/\/.*/y;
  At2 = /[<>.:={}]|\/(?![\/*])/y;
  bt2 = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu;
  _t2 = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y;
  xt2 = /[^<>{}]+/y;
  Ot2 = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
  fn2 = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
  $e2 = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
  bu = /^(?:return|throw|yield)$/;
  cn2 = RegExp(Ke2.source);
  ln2.exports = function* (e, { jsx: t = false } = {}) {
    var u, r, o, n, a, s, i, D, f2, l2, d, c, p, F2;
    for ({ length: s } = e, n = 0, a = "", F2 = [{ tag: "JS" }], u = [], d = 0, c = false; n < s; ) {
      switch (D = F2[F2.length - 1], D.tag) {
        case "JS":
        case "JSNonExpressionParen":
        case "InterpolationInTemplate":
        case "InterpolationInJSX":
          if (e[n] === "/" && (Ot2.test(a) || $e2.test(a)) && (Nt2.lastIndex = n, i = Nt2.exec(e))) {
            n = Nt2.lastIndex, a = i[0], c = true, yield { type: "RegularExpressionLiteral", value: i[0], closed: i[1] !== void 0 && i[1] !== "\\" };
            continue;
          }
          if (Ve.lastIndex = n, i = Ve.exec(e)) {
            switch (p = i[0], f2 = Ve.lastIndex, l2 = p, p) {
              case "(":
                a === "?NonExpressionParenKeyword" && F2.push({ tag: "JSNonExpressionParen", nesting: d }), d++, c = false;
                break;
              case ")":
                d--, c = true, D.tag === "JSNonExpressionParen" && d === D.nesting && (F2.pop(), l2 = "?NonExpressionParenEnd", c = false);
                break;
              case "{":
                Ve.lastIndex = 0, o = !fn2.test(a) && (Ot2.test(a) || $e2.test(a)), u.push(o), c = false;
                break;
              case "}":
                switch (D.tag) {
                  case "InterpolationInTemplate":
                    if (u.length === D.nesting) {
                      pe2.lastIndex = n, i = pe2.exec(e), n = pe2.lastIndex, a = i[0], i[1] === "${" ? (a = "?InterpolationInTemplate", c = false, yield { type: "TemplateMiddle", value: i[0] }) : (F2.pop(), c = true, yield { type: "TemplateTail", value: i[0], closed: i[1] === "`" });
                      continue;
                    }
                    break;
                  case "InterpolationInJSX":
                    if (u.length === D.nesting) {
                      F2.pop(), n += 1, a = "}", yield { type: "JSXPunctuator", value: "}" };
                      continue;
                    }
                }
                c = u.pop(), l2 = c ? "?ExpressionBraceEnd" : "}";
                break;
              case "]":
                c = true;
                break;
              case "++":
              case "--":
                l2 = c ? "?PostfixIncDec" : "?UnaryIncDec";
                break;
              case "<":
                if (t && (Ot2.test(a) || $e2.test(a))) {
                  F2.push({ tag: "JSXTag" }), n += 1, a = "<", yield { type: "JSXPunctuator", value: p };
                  continue;
                }
                c = false;
                break;
              default:
                c = false;
            }
            n = f2, a = l2, yield { type: "Punctuator", value: p };
            continue;
          }
          if (yt2.lastIndex = n, i = yt2.exec(e)) {
            switch (n = yt2.lastIndex, l2 = i[0], i[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                a !== "." && a !== "?." && (l2 = "?NonExpressionParenKeyword");
            }
            a = l2, c = !$e2.test(i[0]), yield { type: i[1] === "#" ? "PrivateIdentifier" : "IdentifierName", value: i[0] };
            continue;
          }
          if (wt2.lastIndex = n, i = wt2.exec(e)) {
            n = wt2.lastIndex, a = i[0], c = true, yield { type: "StringLiteral", value: i[0], closed: i[2] !== void 0 };
            continue;
          }
          if (Tt2.lastIndex = n, i = Tt2.exec(e)) {
            n = Tt2.lastIndex, a = i[0], c = true, yield { type: "NumericLiteral", value: i[0] };
            continue;
          }
          if (pe2.lastIndex = n, i = pe2.exec(e)) {
            n = pe2.lastIndex, a = i[0], i[1] === "${" ? (a = "?InterpolationInTemplate", F2.push({ tag: "InterpolationInTemplate", nesting: u.length }), c = false, yield { type: "TemplateHead", value: i[0] }) : (c = true, yield { type: "NoSubstitutionTemplate", value: i[0], closed: i[1] === "`" });
            continue;
          }
          break;
        case "JSXTag":
        case "JSXTagEnd":
          if (At2.lastIndex = n, i = At2.exec(e)) {
            switch (n = At2.lastIndex, l2 = i[0], i[0]) {
              case "<":
                F2.push({ tag: "JSXTag" });
                break;
              case ">":
                F2.pop(), a === "/" || D.tag === "JSXTagEnd" ? (l2 = "?JSX", c = true) : F2.push({ tag: "JSXChildren" });
                break;
              case "{":
                F2.push({ tag: "InterpolationInJSX", nesting: u.length }), l2 = "?InterpolationInJSX", c = false;
                break;
              case "/":
                a === "<" && (F2.pop(), F2[F2.length - 1].tag === "JSXChildren" && F2.pop(), F2.push({ tag: "JSXTagEnd" }));
            }
            a = l2, yield { type: "JSXPunctuator", value: i[0] };
            continue;
          }
          if (bt2.lastIndex = n, i = bt2.exec(e)) {
            n = bt2.lastIndex, a = i[0], yield { type: "JSXIdentifier", value: i[0] };
            continue;
          }
          if (_t2.lastIndex = n, i = _t2.exec(e)) {
            n = _t2.lastIndex, a = i[0], yield { type: "JSXString", value: i[0], closed: i[2] !== void 0 };
            continue;
          }
          break;
        case "JSXChildren":
          if (xt2.lastIndex = n, i = xt2.exec(e)) {
            n = xt2.lastIndex, a = i[0], yield { type: "JSXText", value: i[0] };
            continue;
          }
          switch (e[n]) {
            case "<":
              F2.push({ tag: "JSXTag" }), n++, a = "<", yield { type: "JSXPunctuator", value: "<" };
              continue;
            case "{":
              F2.push({ tag: "InterpolationInJSX", nesting: u.length }), n++, a = "?InterpolationInJSX", c = false, yield { type: "JSXPunctuator", value: "{" };
              continue;
          }
      }
      if (Pt2.lastIndex = n, i = Pt2.exec(e)) {
        n = Pt2.lastIndex, yield { type: "WhiteSpace", value: i[0] };
        continue;
      }
      if (Ke2.lastIndex = n, i = Ke2.exec(e)) {
        n = Ke2.lastIndex, c = false, bu.test(a) && (a = "?NoLineTerminatorHere"), yield { type: "LineTerminatorSequence", value: i[0] };
        continue;
      }
      if (Bt2.lastIndex = n, i = Bt2.exec(e)) {
        n = Bt2.lastIndex, cn2.test(i[0]) && (c = false, bu.test(a) && (a = "?NoLineTerminatorHere")), yield { type: "MultiLineComment", value: i[0], closed: i[1] !== void 0 };
        continue;
      }
      if (St2.lastIndex = n, i = St2.exec(e)) {
        n = St2.lastIndex, c = false, yield { type: "SingleLineComment", value: i[0] };
        continue;
      }
      r = String.fromCodePoint(e.codePointAt(n)), n += r.length, a = r, c = false, yield { type: D.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid", value: r };
    }
  };
});
var Hn = {};
Yt(Hn, { __debug: () => li, check: () => ci, doc: () => wu, format: () => Jn, formatWithCursor: () => zn, getSupportInfo: () => fi, util: () => Pu, version: () => Mn });
var X = (e, t) => (u, r, ...o) => u | 1 && r == null ? void 0 : (t.call(r) ?? r[e]).apply(r, o);
var io = String.prototype.replaceAll ?? function(e, t) {
  return e.global ? this.replace(e, t) : this.split(e).join(t);
}, so = X("replaceAll", function() {
  if (typeof this == "string") return io;
}), oe = so;
var Ne = class {
  diff(t, u, r = {}) {
    let o;
    typeof r == "function" ? (o = r, r = {}) : "callback" in r && (o = r.callback);
    let n = this.castInput(t, r), a = this.castInput(u, r), s = this.removeEmpty(this.tokenize(n, r)), i = this.removeEmpty(this.tokenize(a, r));
    return this.diffWithOptionsObj(s, i, r, o);
  }
  diffWithOptionsObj(t, u, r, o) {
    var n;
    let a = (m) => {
      if (m = this.postProcess(m, r), o) {
        setTimeout(function() {
          o(m);
        }, 0);
        return;
      } else return m;
    }, s = u.length, i = t.length, D = 1, f2 = s + i;
    r.maxEditLength != null && (f2 = Math.min(f2, r.maxEditLength));
    let l2 = (n = r.timeout) !== null && n !== void 0 ? n : 1 / 0, d = Date.now() + l2, c = [{ oldPos: -1, lastComponent: void 0 }], p = this.extractCommon(c[0], u, t, 0, r);
    if (c[0].oldPos + 1 >= i && p + 1 >= s) return a(this.buildValues(c[0].lastComponent, u, t));
    let F2 = -1 / 0, C2 = 1 / 0, y2 = () => {
      for (let m = Math.max(F2, -D); m <= Math.min(C2, D); m += 2) {
        let h2, E = c[m - 1], g = c[m + 1];
        E && (c[m - 1] = void 0);
        let A2 = false;
        if (g) {
          let Q2 = g.oldPos - m;
          A2 = g && 0 <= Q2 && Q2 < s;
        }
        let J2 = E && E.oldPos + 1 < i;
        if (!A2 && !J2) {
          c[m] = void 0;
          continue;
        }
        if (!J2 || A2 && E.oldPos < g.oldPos ? h2 = this.addToPath(g, true, false, 0, r) : h2 = this.addToPath(E, false, true, 1, r), p = this.extractCommon(h2, u, t, m, r), h2.oldPos + 1 >= i && p + 1 >= s) return a(this.buildValues(h2.lastComponent, u, t)) || true;
        c[m] = h2, h2.oldPos + 1 >= i && (C2 = Math.min(C2, m - 1)), p + 1 >= s && (F2 = Math.max(F2, m + 1));
      }
      D++;
    };
    if (o) (function m() {
      setTimeout(function() {
        if (D > f2 || Date.now() > d) return o(void 0);
        y2() || m();
      }, 0);
    })();
    else for (; D <= f2 && Date.now() <= d; ) {
      let m = y2();
      if (m) return m;
    }
  }
  addToPath(t, u, r, o, n) {
    let a = t.lastComponent;
    return a && !n.oneChangePerToken && a.added === u && a.removed === r ? { oldPos: t.oldPos + o, lastComponent: { count: a.count + 1, added: u, removed: r, previousComponent: a.previousComponent } } : { oldPos: t.oldPos + o, lastComponent: { count: 1, added: u, removed: r, previousComponent: a } };
  }
  extractCommon(t, u, r, o, n) {
    let a = u.length, s = r.length, i = t.oldPos, D = i - o, f2 = 0;
    for (; D + 1 < a && i + 1 < s && this.equals(r[i + 1], u[D + 1], n); ) D++, i++, f2++, n.oneChangePerToken && (t.lastComponent = { count: 1, previousComponent: t.lastComponent, added: false, removed: false });
    return f2 && !n.oneChangePerToken && (t.lastComponent = { count: f2, previousComponent: t.lastComponent, added: false, removed: false }), t.oldPos = i, D;
  }
  equals(t, u, r) {
    return r.comparator ? r.comparator(t, u) : t === u || !!r.ignoreCase && t.toLowerCase() === u.toLowerCase();
  }
  removeEmpty(t) {
    let u = [];
    for (let r = 0; r < t.length; r++) t[r] && u.push(t[r]);
    return u;
  }
  castInput(t, u) {
    return t;
  }
  tokenize(t, u) {
    return Array.from(t);
  }
  join(t) {
    return t.join("");
  }
  postProcess(t, u) {
    return t;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(t, u, r) {
    let o = [], n;
    for (; t; ) o.push(t), n = t.previousComponent, delete t.previousComponent, t = n;
    o.reverse();
    let a = o.length, s = 0, i = 0, D = 0;
    for (; s < a; s++) {
      let f2 = o[s];
      if (f2.removed) f2.value = this.join(r.slice(D, D + f2.count)), D += f2.count;
      else {
        if (!f2.added && this.useLongestToken) {
          let l2 = u.slice(i, i + f2.count);
          l2 = l2.map(function(d, c) {
            let p = r[D + c];
            return p.length > d.length ? p : d;
          }), f2.value = this.join(l2);
        } else f2.value = this.join(u.slice(i, i + f2.count));
        i += f2.count, f2.added || (D += f2.count);
      }
    }
    return o;
  }
};
var jt = class extends Ne {
  tokenize(t) {
    return t.slice();
  }
  join(t) {
    return t;
  }
  removeEmpty(t) {
    return t;
  }
}, ku = new jt();
function Ut(e, t, u) {
  return ku.diff(e, t, u);
}
var Do = () => {
}, P = Do;
var Ru = "cr", Lu = "crlf", co = "lf", fo = co, Wt = "\r", Mu$1 = `\r
`, Je = `
`, lo = Je;
function Yu(e) {
  let t = e.indexOf(Wt);
  return t !== -1 ? e.charAt(t + 1) === Je ? Lu : Ru : fo;
}
function Se(e) {
  return e === Ru ? Wt : e === Lu ? Mu$1 : lo;
}
var po = /* @__PURE__ */ new Map([[Je, /\n/gu], [Wt, /\r/gu], [Mu$1, /\r\n/gu]]);
function $t(e, t) {
  let u = po.get(t);
  return e.match(u)?.length ?? 0;
}
var Fo = /\r\n?/gu;
function ju(e) {
  return oe(0, e, Fo, Je);
}
function mo(e) {
  return this[e < 0 ? this.length + e : e];
}
var Eo = X("at", function() {
  if (Array.isArray(this) || typeof this == "string") return mo;
}), b = Eo;
var G = "string", j = "array", U = "cursor", I = "indent", k = "align", v = "trim", x = "group", w = "fill", B = "if-break", R = "indent-if-break", L = "line-suffix", M = "line-suffix-boundary", _ = "line", O = "label", T = "break-parent", He = /* @__PURE__ */ new Set([U, I, k, v, x, w, B, R, L, M, _, O, T]);
function Uu(e) {
  let t = e.length;
  for (; t > 0 && (e[t - 1] === "\r" || e[t - 1] === `
`); ) t--;
  return t < e.length ? e.slice(0, t) : e;
}
function Co(e) {
  if (typeof e == "string") return G;
  if (Array.isArray(e)) return j;
  if (!e) return;
  let { type: t } = e;
  if (He.has(t)) return t;
}
var H = Co;
var ho = (e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e);
function go(e) {
  let t = e === null ? "null" : typeof e;
  if (t !== "string" && t !== "object") return `Unexpected doc '${t}', 
Expected it to be 'string' or 'object'.`;
  if (H(e)) throw new Error("doc is valid.");
  let u = Object.prototype.toString.call(e);
  if (u !== "[object Object]") return `Unexpected doc '${u}'.`;
  let r = ho([...He].map((o) => `'${o}'`));
  return `Unexpected doc.type '${e.type}'.
Expected it to be ${r}.`;
}
var Vt = class extends Error {
  name = "InvalidDocError";
  constructor(t) {
    super(go(t)), this.doc = t;
  }
}, Z = Vt;
var Wu = {};
function yo(e, t, u, r) {
  let o = [e];
  for (; o.length > 0; ) {
    let n = o.pop();
    if (n === Wu) {
      u(o.pop());
      continue;
    }
    u && o.push(n, Wu);
    let a = H(n);
    if (!a) throw new Z(n);
    if (t?.(n) !== false) switch (a) {
      case j:
      case w: {
        let s = a === j ? n : n.parts;
        for (let i = s.length, D = i - 1; D >= 0; --D) o.push(s[D]);
        break;
      }
      case B:
        o.push(n.flatContents, n.breakContents);
        break;
      case x:
        if (r && n.expandedStates) for (let s = n.expandedStates.length, i = s - 1; i >= 0; --i) o.push(n.expandedStates[i]);
        else o.push(n.contents);
        break;
      case k:
      case I:
      case R:
      case O:
      case L:
        o.push(n.contents);
        break;
      case G:
      case U:
      case v:
      case M:
      case _:
      case T:
        break;
      default:
        throw new Z(n);
    }
  }
}
var we = yo;
function Pe(e, t) {
  if (typeof e == "string") return t(e);
  let u = /* @__PURE__ */ new Map();
  return r(e);
  function r(n) {
    if (u.has(n)) return u.get(n);
    let a = o(n);
    return u.set(n, a), a;
  }
  function o(n) {
    switch (H(n)) {
      case j:
        return t(n.map(r));
      case w:
        return t({ ...n, parts: n.parts.map(r) });
      case B:
        return t({ ...n, breakContents: r(n.breakContents), flatContents: r(n.flatContents) });
      case x: {
        let { expandedStates: a, contents: s } = n;
        return a ? (a = a.map(r), s = a[0]) : s = r(s), t({ ...n, contents: s, expandedStates: a });
      }
      case k:
      case I:
      case R:
      case O:
      case L:
        return t({ ...n, contents: r(n.contents) });
      case G:
      case U:
      case v:
      case M:
      case _:
      case T:
        return t(n);
      default:
        throw new Z(n);
    }
  }
}
function Xe(e, t, u) {
  let r = u, o = false;
  function n(a) {
    if (o) return false;
    let s = t(a);
    s !== void 0 && (o = true, r = s);
  }
  return we(e, n), r;
}
function bo(e) {
  if (e.type === x && e.break || e.type === _ && e.hard || e.type === T) return true;
}
function Ku(e) {
  return Xe(e, bo, false);
}
function $u(e) {
  if (e.length > 0) {
    let t = b(0, e, -1);
    !t.expandedStates && !t.break && (t.break = "propagated");
  }
  return null;
}
function Gu(e) {
  let t = /* @__PURE__ */ new Set(), u = [];
  function r(n) {
    if (n.type === T && $u(u), n.type === x) {
      if (u.push(n), t.has(n)) return false;
      t.add(n);
    }
  }
  function o(n) {
    n.type === x && u.pop().break && $u(u);
  }
  we(e, r, o, true);
}
function Ao(e) {
  return e.type === _ && !e.hard ? e.soft ? "" : " " : e.type === B ? e.flatContents : e;
}
function zu(e) {
  return Pe(e, Ao);
}
function Vu(e) {
  for (e = [...e]; e.length >= 2 && b(0, e, -2).type === _ && b(0, e, -1).type === T; ) e.length -= 2;
  if (e.length > 0) {
    let t = Oe(b(0, e, -1));
    e[e.length - 1] = t;
  }
  return e;
}
function Oe(e) {
  switch (H(e)) {
    case I:
    case R:
    case x:
    case L:
    case O: {
      let t = Oe(e.contents);
      return { ...e, contents: t };
    }
    case B:
      return { ...e, breakContents: Oe(e.breakContents), flatContents: Oe(e.flatContents) };
    case w:
      return { ...e, parts: Vu(e.parts) };
    case j:
      return Vu(e);
    case G:
      return Uu(e);
    case k:
    case U:
    case v:
    case M:
    case _:
    case T:
      break;
    default:
      throw new Z(e);
  }
  return e;
}
function qe(e) {
  return Oe(xo2(e));
}
function _o(e) {
  switch (H(e)) {
    case w:
      if (e.parts.every((t) => t === "")) return "";
      break;
    case x:
      if (!e.contents && !e.id && !e.break && !e.expandedStates) return "";
      if (e.contents.type === x && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
      break;
    case k:
    case I:
    case R:
    case L:
      if (!e.contents) return "";
      break;
    case B:
      if (!e.flatContents && !e.breakContents) return "";
      break;
    case j: {
      let t = [];
      for (let u of e) {
        if (!u) continue;
        let [r, ...o] = Array.isArray(u) ? u : [u];
        typeof r == "string" && typeof b(0, t, -1) == "string" ? t[t.length - 1] += r : t.push(r), t.push(...o);
      }
      return t.length === 0 ? "" : t.length === 1 ? t[0] : t;
    }
    case G:
    case U:
    case v:
    case M:
    case _:
    case O:
    case T:
      break;
    default:
      throw new Z(e);
  }
  return e;
}
function xo2(e) {
  return Pe(e, (t) => _o(t));
}
function Ju(e, t = Qe) {
  return Pe(e, (u) => typeof u == "string" ? Ie(t, u.split(`
`)) : u);
}
function Bo(e) {
  if (e.type === _) return true;
}
function Hu(e) {
  return Xe(e, Bo, false);
}
function Ee(e, t) {
  return e.type === O ? { ...e, contents: t(e.contents) } : t(e);
}
var Ze = P;
function ae(e) {
  return { type: I, contents: e };
}
function De(e, t) {
  return { type: k, contents: t, n: e };
}
function Qu(e) {
  return De(Number.NEGATIVE_INFINITY, e);
}
function et(e) {
  return De({ type: "root" }, e);
}
function Zu(e) {
  return De(-1, e);
}
function tt(e, t, u) {
  let r = e;
  if (t > 0) {
    for (let o = 0; o < Math.floor(t / u); ++o) r = ae(r);
    r = De(t % u, r), r = De(Number.NEGATIVE_INFINITY, r);
  }
  return r;
}
var ce = { type: T };
var ee$1 = { type: U };
function er(e) {
  return { type: w, parts: e };
}
function Kt(e, t = {}) {
  return Ze(t.expandedStates), { type: x, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
}
function tr(e, t) {
  return Kt(e[0], { ...t, expandedStates: e });
}
function ur(e, t = "", u = {}) {
  return { type: B, breakContents: e, flatContents: t, groupId: u.groupId };
}
function rr(e, t) {
  return { type: R, contents: e, groupId: t.groupId, negate: t.negate };
}
function Ie(e, t) {
  let u = [];
  for (let r = 0; r < t.length; r++) r !== 0 && u.push(e), u.push(t[r]);
  return u;
}
function nr(e, t) {
  return e ? { type: O, label: e, contents: t } : t;
}
var ut = { type: _ }, or$1 = { type: _, soft: true }, ke = { type: _, hard: true }, V = [ke, ce], Gt$1 = { type: _, hard: true, literal: true }, Qe = [Gt$1, ce];
function ve2(e) {
  return { type: L, contents: e };
}
var ar = { type: M };
var ir = { type: v };
function te(e) {
  if (!e) return "";
  if (Array.isArray(e)) {
    let t = [];
    for (let u of e) if (Array.isArray(u)) t.push(...te(u));
    else {
      let r = te(u);
      r !== "" && t.push(r);
    }
    return t;
  }
  return e.type === B ? { ...e, breakContents: te(e.breakContents), flatContents: te(e.flatContents) } : e.type === x ? { ...e, contents: te(e.contents), expandedStates: e.expandedStates?.map(te) } : e.type === w ? { type: "fill", parts: e.parts.map(te) } : e.contents ? { ...e, contents: te(e.contents) } : e;
}
function sr2(e) {
  let t = /* @__PURE__ */ Object.create(null), u = /* @__PURE__ */ new Set();
  return r(te(e));
  function r(n, a, s) {
    if (typeof n == "string") return JSON.stringify(n);
    if (Array.isArray(n)) {
      let i = n.map(r).filter(Boolean);
      return i.length === 1 ? i[0] : `[${i.join(", ")}]`;
    }
    if (n.type === _) {
      let i = s?.[a + 1]?.type === T;
      return n.literal ? i ? "literalline" : "literallineWithoutBreakParent" : n.hard ? i ? "hardline" : "hardlineWithoutBreakParent" : n.soft ? "softline" : "line";
    }
    if (n.type === T) return s?.[a - 1]?.type === _ && s[a - 1].hard ? void 0 : "breakParent";
    if (n.type === v) return "trim";
    if (n.type === I) return "indent(" + r(n.contents) + ")";
    if (n.type === k) return n.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + r(n.contents) + ")" : n.n < 0 ? "dedent(" + r(n.contents) + ")" : n.n.type === "root" ? "markAsRoot(" + r(n.contents) + ")" : "align(" + JSON.stringify(n.n) + ", " + r(n.contents) + ")";
    if (n.type === B) return "ifBreak(" + r(n.breakContents) + (n.flatContents ? ", " + r(n.flatContents) : "") + (n.groupId ? (n.flatContents ? "" : ', ""') + `, { groupId: ${o(n.groupId)} }` : "") + ")";
    if (n.type === R) {
      let i = [];
      n.negate && i.push("negate: true"), n.groupId && i.push(`groupId: ${o(n.groupId)}`);
      let D = i.length > 0 ? `, { ${i.join(", ")} }` : "";
      return `indentIfBreak(${r(n.contents)}${D})`;
    }
    if (n.type === x) {
      let i = [];
      n.break && n.break !== "propagated" && i.push("shouldBreak: true"), n.id && i.push(`id: ${o(n.id)}`);
      let D = i.length > 0 ? `, { ${i.join(", ")} }` : "";
      return n.expandedStates ? `conditionalGroup([${n.expandedStates.map((f2) => r(f2)).join(",")}]${D})` : `group(${r(n.contents)}${D})`;
    }
    if (n.type === w) return `fill([${n.parts.map((i) => r(i)).join(", ")}])`;
    if (n.type === L) return "lineSuffix(" + r(n.contents) + ")";
    if (n.type === M) return "lineSuffixBoundary";
    if (n.type === O) return `label(${JSON.stringify(n.label)}, ${r(n.contents)})`;
    if (n.type === U) return "cursor";
    throw new Error("Unknown doc type " + n.type);
  }
  function o(n) {
    if (typeof n != "symbol") return JSON.stringify(String(n));
    if (n in t) return t[n];
    let a = n.description || "symbol";
    for (let s = 0; ; s++) {
      let i = a + (s > 0 ? ` #${s}` : "");
      if (!u.has(i)) return u.add(i), t[n] = `Symbol.for(${JSON.stringify(i)})`;
    }
  }
}
var Dr = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function zt(e) {
  return e === 12288 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
}
function Jt(e) {
  return e >= 4352 && e <= 4447 || e === 8986 || e === 8987 || e === 9001 || e === 9002 || e >= 9193 && e <= 9196 || e === 9200 || e === 9203 || e === 9725 || e === 9726 || e === 9748 || e === 9749 || e >= 9776 && e <= 9783 || e >= 9800 && e <= 9811 || e === 9855 || e >= 9866 && e <= 9871 || e === 9875 || e === 9889 || e === 9898 || e === 9899 || e === 9917 || e === 9918 || e === 9924 || e === 9925 || e === 9934 || e === 9940 || e === 9962 || e === 9970 || e === 9971 || e === 9973 || e === 9978 || e === 9981 || e === 9989 || e === 9994 || e === 9995 || e === 10024 || e === 10060 || e === 10062 || e >= 10067 && e <= 10069 || e === 10071 || e >= 10133 && e <= 10135 || e === 10160 || e === 10175 || e === 11035 || e === 11036 || e === 11088 || e === 11093 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12287 || e >= 12289 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12591 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12773 || e >= 12783 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 94176 && e <= 94180 || e >= 94192 && e <= 94198 || e >= 94208 && e <= 101589 || e >= 101631 && e <= 101662 || e >= 101760 && e <= 101874 || e >= 110576 && e <= 110579 || e >= 110581 && e <= 110587 || e === 110589 || e === 110590 || e >= 110592 && e <= 110882 || e === 110898 || e >= 110928 && e <= 110930 || e === 110933 || e >= 110948 && e <= 110951 || e >= 110960 && e <= 111355 || e >= 119552 && e <= 119638 || e >= 119648 && e <= 119670 || e === 126980 || e === 127183 || e === 127374 || e >= 127377 && e <= 127386 || e >= 127488 && e <= 127490 || e >= 127504 && e <= 127547 || e >= 127552 && e <= 127560 || e === 127568 || e === 127569 || e >= 127584 && e <= 127589 || e >= 127744 && e <= 127776 || e >= 127789 && e <= 127797 || e >= 127799 && e <= 127868 || e >= 127870 && e <= 127891 || e >= 127904 && e <= 127946 || e >= 127951 && e <= 127955 || e >= 127968 && e <= 127984 || e === 127988 || e >= 127992 && e <= 128062 || e === 128064 || e >= 128066 && e <= 128252 || e >= 128255 && e <= 128317 || e >= 128331 && e <= 128334 || e >= 128336 && e <= 128359 || e === 128378 || e === 128405 || e === 128406 || e === 128420 || e >= 128507 && e <= 128591 || e >= 128640 && e <= 128709 || e === 128716 || e >= 128720 && e <= 128722 || e >= 128725 && e <= 128728 || e >= 128732 && e <= 128735 || e === 128747 || e === 128748 || e >= 128756 && e <= 128764 || e >= 128992 && e <= 129003 || e === 129008 || e >= 129292 && e <= 129338 || e >= 129340 && e <= 129349 || e >= 129351 && e <= 129535 || e >= 129648 && e <= 129660 || e >= 129664 && e <= 129674 || e >= 129678 && e <= 129734 || e === 129736 || e >= 129741 && e <= 129756 || e >= 129759 && e <= 129770 || e >= 129775 && e <= 129784 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141;
}
var cr2 = "©®‼⁉™ℹ↔↕↖↗↘↙↩↪⌨⏏⏱⏲⏸⏹⏺▪▫▶◀◻◼☀☁☂☃☄☎☑☘☝☠☢☣☦☪☮☯☸☹☺♀♂♟♠♣♥♦♨♻♾⚒⚔⚕⚖⚗⚙⚛⚜⚠⚧⚰⚱⛈⛏⛑⛓⛩⛱⛷⛸⛹✂✈✉✌✍✏✒✔✖✝✡✳✴❄❇❣❤➡⤴⤵⬅⬆⬇";
var To = /[^\x20-\x7F]/u, No = new Set(cr2);
function So(e) {
  if (!e) return 0;
  if (!To.test(e)) return e.length;
  e = e.replace(Dr(), (u) => No.has(u) ? " " : "  ");
  let t = 0;
  for (let u of e) {
    let r = u.codePointAt(0);
    r <= 31 || r >= 127 && r <= 159 || r >= 768 && r <= 879 || r >= 65024 && r <= 65039 || (t += zt(r) || Jt(r) ? 2 : 1);
  }
  return t;
}
var Re$1 = So;
var wo = { type: 0 }, Oo2 = { type: 1 }, Ht = { value: "", length: 0, queue: [], get root() {
  return Ht;
} };
function fr(e, t, u) {
  let r = t.type === 1 ? e.queue.slice(0, -1) : [...e.queue, t], o = "", n = 0, a = 0, s = 0;
  for (let p of r) switch (p.type) {
    case 0:
      f2(), u.useTabs ? i(1) : D(u.tabWidth);
      break;
    case 3: {
      let { string: F2 } = p;
      f2(), o += F2, n += F2.length;
      break;
    }
    case 2: {
      let { width: F2 } = p;
      a += 1, s += F2;
      break;
    }
    default:
      throw new Error(`Unexpected indent comment '${p.type}'.`);
  }
  return d(), { ...e, value: o, length: n, queue: r };
  function i(p) {
    o += "	".repeat(p), n += u.tabWidth * p;
  }
  function D(p) {
    o += " ".repeat(p), n += p;
  }
  function f2() {
    u.useTabs ? l2() : d();
  }
  function l2() {
    a > 0 && i(a), c();
  }
  function d() {
    s > 0 && D(s), c();
  }
  function c() {
    a = 0, s = 0;
  }
}
function lr2(e, t, u) {
  if (!t) return e;
  if (t.type === "root") return { ...e, root: e };
  if (t === Number.NEGATIVE_INFINITY) return e.root;
  let r;
  return typeof t == "number" ? t < 0 ? r = Oo2 : r = { type: 2, width: t } : r = { type: 3, string: t }, fr(e, r, u);
}
function dr(e, t) {
  return fr(e, wo, t);
}
function Po(e) {
  let t = 0;
  for (let u = e.length - 1; u >= 0; u--) {
    let r = e[u];
    if (r === " " || r === "	") t++;
    else break;
  }
  return t;
}
function Xt(e) {
  let t = Po(e);
  return { text: t === 0 ? e : e.slice(0, e.length - t), count: t };
}
var W = /* @__PURE__ */ Symbol("MODE_BREAK"), q = /* @__PURE__ */ Symbol("MODE_FLAT"), qt = /* @__PURE__ */ Symbol("DOC_FILL_PRINTED_LENGTH");
function rt(e, t, u, r, o, n) {
  if (u === Number.POSITIVE_INFINITY) return true;
  let a = t.length, s = false, i = [e], D = "";
  for (; u >= 0; ) {
    if (i.length === 0) {
      if (a === 0) return true;
      i.push(t[--a]);
      continue;
    }
    let { mode: f2, doc: l2 } = i.pop(), d = H(l2);
    switch (d) {
      case G:
        l2 && (s && (D += " ", u -= 1, s = false), D += l2, u -= Re$1(l2));
        break;
      case j:
      case w: {
        let c = d === j ? l2 : l2.parts, p = l2[qt] ?? 0;
        for (let F2 = c.length - 1; F2 >= p; F2--) i.push({ mode: f2, doc: c[F2] });
        break;
      }
      case I:
      case k:
      case R:
      case O:
        i.push({ mode: f2, doc: l2.contents });
        break;
      case v: {
        let { text: c, count: p } = Xt(D);
        D = c, u += p;
        break;
      }
      case x: {
        if (n && l2.break) return false;
        let c = l2.break ? W : f2, p = l2.expandedStates && c === W ? b(0, l2.expandedStates, -1) : l2.contents;
        i.push({ mode: c, doc: p });
        break;
      }
      case B: {
        let p = (l2.groupId ? o[l2.groupId] || q : f2) === W ? l2.breakContents : l2.flatContents;
        p && i.push({ mode: f2, doc: p });
        break;
      }
      case _:
        if (f2 === W || l2.hard) return true;
        l2.soft || (s = true);
        break;
      case L:
        r = true;
        break;
      case M:
        if (r) return false;
        break;
    }
  }
  return false;
}
function Ce2(e, t) {
  let u = /* @__PURE__ */ Object.create(null), r = t.printWidth, o = Se(t.endOfLine), n = 0, a = [{ indent: Ht, mode: W, doc: e }], s = "", i = false, D = [], f2 = [], l2 = [], d = [], c = 0;
  for (Gu(e); a.length > 0; ) {
    let { indent: m, mode: h2, doc: E } = a.pop();
    switch (H(E)) {
      case G: {
        let g = o !== `
` ? oe(0, E, `
`, o) : E;
        g && (s += g, a.length > 0 && (n += Re$1(g)));
        break;
      }
      case j:
        for (let g = E.length - 1; g >= 0; g--) a.push({ indent: m, mode: h2, doc: E[g] });
        break;
      case U:
        if (f2.length >= 2) throw new Error("There are too many 'cursor' in doc.");
        f2.push(c + s.length);
        break;
      case I:
        a.push({ indent: dr(m, t), mode: h2, doc: E.contents });
        break;
      case k:
        a.push({ indent: lr2(m, E.n, t), mode: h2, doc: E.contents });
        break;
      case v:
        y2();
        break;
      case x:
        switch (h2) {
          case q:
            if (!i) {
              a.push({ indent: m, mode: E.break ? W : q, doc: E.contents });
              break;
            }
          case W: {
            i = false;
            let g = { indent: m, mode: q, doc: E.contents }, A2 = r - n, J2 = D.length > 0;
            if (!E.break && rt(g, a, A2, J2, u)) a.push(g);
            else if (E.expandedStates) {
              let Q2 = b(0, E.expandedStates, -1);
              if (E.break) {
                a.push({ indent: m, mode: W, doc: Q2 });
                break;
              } else for (let re2 = 1; re2 < E.expandedStates.length + 1; re2++) if (re2 >= E.expandedStates.length) {
                a.push({ indent: m, mode: W, doc: Q2 });
                break;
              } else {
                let Te2 = E.expandedStates[re2], ne3 = { indent: m, mode: q, doc: Te2 };
                if (rt(ne3, a, A2, J2, u)) {
                  a.push(ne3);
                  break;
                }
              }
            } else a.push({ indent: m, mode: W, doc: E.contents });
            break;
          }
        }
        E.id && (u[E.id] = b(0, a, -1).mode);
        break;
      case w: {
        let g = r - n, A2 = E[qt] ?? 0, { parts: J2 } = E, Q2 = J2.length - A2;
        if (Q2 === 0) break;
        let re2 = J2[A2 + 0], Te2 = J2[A2 + 1], ne3 = { indent: m, mode: q, doc: re2 }, vt2 = { indent: m, mode: W, doc: re2 }, Rt2 = rt(ne3, [], g, D.length > 0, u, true);
        if (Q2 === 1) {
          Rt2 ? a.push(ne3) : a.push(vt2);
          break;
        }
        let Iu = { indent: m, mode: q, doc: Te2 }, Lt2 = { indent: m, mode: W, doc: Te2 };
        if (Q2 === 2) {
          Rt2 ? a.push(Iu, ne3) : a.push(Lt2, vt2);
          break;
        }
        let Xn2 = J2[A2 + 2], qn2 = { indent: m, mode: h2, doc: { ...E, [qt]: A2 + 2 } }, Qn2 = rt({ indent: m, mode: q, doc: [re2, Te2, Xn2] }, [], g, D.length > 0, u, true);
        a.push(qn2), Qn2 ? a.push(Iu, ne3) : Rt2 ? a.push(Lt2, ne3) : a.push(Lt2, vt2);
        break;
      }
      case B:
      case R: {
        let g = E.groupId ? u[E.groupId] : h2;
        if (g === W) {
          let A2 = E.type === B ? E.breakContents : E.negate ? E.contents : ae(E.contents);
          A2 && a.push({ indent: m, mode: h2, doc: A2 });
        }
        if (g === q) {
          let A2 = E.type === B ? E.flatContents : E.negate ? ae(E.contents) : E.contents;
          A2 && a.push({ indent: m, mode: h2, doc: A2 });
        }
        break;
      }
      case L:
        D.push({ indent: m, mode: h2, doc: E.contents });
        break;
      case M:
        D.length > 0 && a.push({ indent: m, mode: h2, doc: ke });
        break;
      case _:
        switch (h2) {
          case q:
            if (E.hard) i = true;
            else {
              E.soft || (s += " ", n += 1);
              break;
            }
          case W:
            if (D.length > 0) {
              a.push({ indent: m, mode: h2, doc: E }, ...D.reverse()), D.length = 0;
              break;
            }
            E.literal ? (s += o, n = 0, m.root && (m.root.value && (s += m.root.value), n = m.root.length)) : (y2(), s += o + m.value, n = m.length);
            break;
        }
        break;
      case O:
        a.push({ indent: m, mode: h2, doc: E.contents });
        break;
      case T:
        break;
      default:
        throw new Z(E);
    }
    a.length === 0 && D.length > 0 && (a.push(...D.reverse()), D.length = 0);
  }
  let p = l2.join("") + s, F2 = [...d, ...f2];
  if (F2.length !== 2) return { formatted: p };
  let C2 = F2[0];
  return { formatted: p, cursorNodeStart: C2, cursorNodeText: p.slice(C2, b(0, F2, -1)) };
  function y2() {
    let { text: m, count: h2 } = Xt(s);
    m && (l2.push(m), c += m.length), s = "", n -= h2, f2.length > 0 && (d.push(...f2.map((E) => Math.min(E, c))), f2.length = 0);
  }
}
function Io(e, t, u = 0) {
  let r = 0;
  for (let o = u; o < e.length; ++o) e[o] === "	" ? r = r + t - r % t : r++;
  return r;
}
var he$2 = Io;
var Qt = class {
  constructor(t) {
    this.stack = [t];
  }
  get key() {
    let { stack: t, siblings: u } = this;
    return b(0, t, u === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : b(0, this.stack, -2);
  }
  get node() {
    return b(0, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: t } = this, u = b(0, t, -3);
    return Array.isArray(u) ? u : null;
  }
  get next() {
    let { siblings: t } = this;
    return t === null ? null : t[this.index + 1];
  }
  get previous() {
    let { siblings: t } = this;
    return t === null ? null : t[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: t, index: u } = this;
    return t !== null && u === t.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...this.#e()];
  }
  getName() {
    let { stack: t } = this, { length: u } = t;
    return u > 1 ? b(0, t, -2) : null;
  }
  getValue() {
    return b(0, this.stack, -1);
  }
  getNode(t = 0) {
    let u = this.#t(t);
    return u === -1 ? null : this.stack[u];
  }
  getParentNode(t = 0) {
    return this.getNode(t + 1);
  }
  #t(t) {
    let { stack: u } = this;
    for (let r = u.length - 1; r >= 0; r -= 2) if (!Array.isArray(u[r]) && --t < 0) return r;
    return -1;
  }
  call(t, ...u) {
    let { stack: r } = this, { length: o } = r, n = b(0, r, -1);
    for (let a of u) n = n?.[a], r.push(a, n);
    try {
      return t(this);
    } finally {
      r.length = o;
    }
  }
  callParent(t, u = 0) {
    let r = this.#t(u + 1), o = this.stack.splice(r + 1);
    try {
      return t(this);
    } finally {
      this.stack.push(...o);
    }
  }
  each(t, ...u) {
    let { stack: r } = this, { length: o } = r, n = b(0, r, -1);
    for (let a of u) n = n[a], r.push(a, n);
    try {
      for (let a = 0; a < n.length; ++a) r.push(a, n[a]), t(this, a, n), r.length -= 2;
    } finally {
      r.length = o;
    }
  }
  map(t, ...u) {
    let r = [];
    return this.each((o, n, a) => {
      r[n] = t(o, n, a);
    }, ...u), r;
  }
  match(...t) {
    let u = this.stack.length - 1, r = null, o = this.stack[u--];
    for (let n of t) {
      if (o === void 0) return false;
      let a = null;
      if (typeof r == "number" && (a = r, r = this.stack[u--], o = this.stack[u--]), n && !n(o, r, a)) return false;
      r = this.stack[u--], o = this.stack[u--];
    }
    return true;
  }
  findAncestor(t) {
    for (let u of this.#e()) if (t(u)) return u;
  }
  hasAncestor(t) {
    for (let u of this.#e()) if (t(u)) return true;
    return false;
  }
  *#e() {
    let { stack: t } = this;
    for (let u = t.length - 3; u >= 0; u -= 2) {
      let r = t[u];
      Array.isArray(r) || (yield r);
    }
  }
}, pr$1 = Qt;
function ko(e) {
  return e !== null && typeof e == "object";
}
var ge$1 = ko;
function ye(e) {
  return (t, u, r) => {
    let o = !!r?.backwards;
    if (u === false) return false;
    let { length: n } = t, a = u;
    for (; a >= 0 && a < n; ) {
      let s = t.charAt(a);
      if (e instanceof RegExp) {
        if (!e.test(s)) return a;
      } else if (!e.includes(s)) return a;
      o ? a-- : a++;
    }
    return a === -1 || a === n ? a : false;
  };
}
var Fr2 = ye(/\s/u), Y = ye(" 	"), nt = ye(",; 	"), ot = ye(/[^\n\r]/u);
var mr = (e) => e === `
` || e === "\r" || e === "\u2028" || e === "\u2029";
function vo(e, t, u) {
  let r = !!u?.backwards;
  if (t === false) return false;
  let o = e.charAt(t);
  if (r) {
    if (e.charAt(t - 1) === "\r" && o === `
`) return t - 2;
    if (mr(o)) return t - 1;
  } else {
    if (o === "\r" && e.charAt(t + 1) === `
`) return t + 2;
    if (mr(o)) return t + 1;
  }
  return t;
}
var K = vo;
function Ro(e, t, u = {}) {
  let r = Y(e, u.backwards ? t - 1 : t, u), o = K(e, r, u);
  return r !== o;
}
var z = Ro;
function Lo(e) {
  return Array.isArray(e) && e.length > 0;
}
var Er = Lo;
function* be(e, t) {
  let { getVisitorKeys: u, filter: r = () => true } = t, o = (n) => ge$1(n) && r(n);
  for (let n of u(e)) {
    let a = e[n];
    if (Array.isArray(a)) for (let s of a) o(s) && (yield s);
    else o(a) && (yield a);
  }
}
function* Cr(e, t) {
  let u = [e];
  for (let r = 0; r < u.length; r++) {
    let o = u[r];
    for (let n of be(o, t)) yield n, u.push(n);
  }
}
function hr(e, t) {
  return be(e, t).next().done;
}
function gr(e, t, u) {
  let { cache: r } = u;
  if (r.has(e)) return r.get(e);
  let { filter: o } = u;
  if (!o) return [];
  let n, a = (u.getChildren?.(e, u) ?? [...be(e, { getVisitorKeys: u.getVisitorKeys })]).flatMap((D) => (n ?? (n = [e, ...t]), o(D, n) ? [D] : gr(D, n, u))), { locStart: s, locEnd: i } = u;
  return a.sort((D, f2) => s(D) - s(f2) || i(D) - i(f2)), r.set(e, a), a;
}
var at = gr;
function Mo(e) {
  let t = e.type || e.kind || "(unknown type)", u = String(e.name || e.id && (typeof e.id == "object" ? e.id.name : e.id) || e.key && (typeof e.key == "object" ? e.key.name : e.key) || e.value && (typeof e.value == "object" ? "" : String(e.value)) || e.operator || "");
  return u.length > 20 && (u = u.slice(0, 19) + "…"), t + (u ? " " + u : "");
}
function Zt(e, t) {
  (e.comments ?? (e.comments = [])).push(t), t.printed = false, t.nodeDescription = Mo(e);
}
function fe(e, t) {
  t.leading = true, t.trailing = false, Zt(e, t);
}
function ue(e, t, u) {
  t.leading = false, t.trailing = false, u && (t.marker = u), Zt(e, t);
}
function le$1(e, t) {
  t.leading = false, t.trailing = true, Zt(e, t);
}
var uu = /* @__PURE__ */ new WeakMap();
function br(e, t, u, r, o = []) {
  let { locStart: n, locEnd: a } = u, s = n(t), i = a(t), D = at(e, o, { cache: uu, locStart: n, locEnd: a, getVisitorKeys: u.getVisitorKeys, filter: u.printer.canAttachComment, getChildren: u.printer.getCommentChildNodes }), f2, l2, d = 0, c = D.length;
  for (; d < c; ) {
    let p = d + c >> 1, F2 = D[p], C2 = n(F2), y2 = a(F2);
    if (C2 <= s && i <= y2) return br(F2, t, u, F2, [F2, ...o]);
    if (y2 <= s) {
      f2 = F2, d = p + 1;
      continue;
    }
    if (i <= C2) {
      l2 = F2, c = p;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if (r?.type === "TemplateLiteral") {
    let { quasis: p } = r, F2 = tu(p, t, u);
    f2 && tu(p, f2, u) !== F2 && (f2 = null), l2 && tu(p, l2, u) !== F2 && (l2 = null);
  }
  return { enclosingNode: r, precedingNode: f2, followingNode: l2 };
}
var eu = () => false;
function Ar(e, t) {
  let { comments: u } = e;
  if (delete e.comments, !Er(u) || !t.printer.canAttachComment) return;
  let r = [], { printer: { features: { experimental_avoidAstMutation: o }, handleComments: n = {} }, originalText: a } = t, { ownLine: s = eu, endOfLine: i = eu, remaining: D = eu } = n, f2 = u.map((l2, d) => ({ ...br(e, l2, t), comment: l2, text: a, options: t, ast: e, isLastComment: u.length - 1 === d }));
  for (let [l2, d] of f2.entries()) {
    let { comment: c, precedingNode: p, enclosingNode: F2, followingNode: C2, text: y2, options: m, ast: h2, isLastComment: E } = d, g;
    if (o ? g = [d] : (c.enclosingNode = F2, c.precedingNode = p, c.followingNode = C2, g = [c, y2, m, h2, E]), Yo(y2, m, f2, l2)) c.placement = "ownLine", s(...g) || (C2 ? fe(C2, c) : p ? le$1(p, c) : F2 ? ue(F2, c) : ue(h2, c));
    else if (jo(y2, m, f2, l2)) c.placement = "endOfLine", i(...g) || (p ? le$1(p, c) : C2 ? fe(C2, c) : F2 ? ue(F2, c) : ue(h2, c));
    else if (c.placement = "remaining", !D(...g)) if (p && C2) {
      let A2 = r.length;
      A2 > 0 && r[A2 - 1].followingNode !== C2 && yr(r, m), r.push(d);
    } else p ? le$1(p, c) : C2 ? fe(C2, c) : F2 ? ue(F2, c) : ue(h2, c);
  }
  if (yr(r, t), !o) for (let l2 of u) delete l2.precedingNode, delete l2.enclosingNode, delete l2.followingNode;
}
var _r = (e) => !/[\S\n\u2028\u2029]/u.test(e);
function Yo(e, t, u, r) {
  let { comment: o, precedingNode: n } = u[r], { locStart: a, locEnd: s } = t, i = a(o);
  if (n) for (let D = r - 1; D >= 0; D--) {
    let { comment: f2, precedingNode: l2 } = u[D];
    if (l2 !== n || !_r(e.slice(s(f2), i))) break;
    i = a(f2);
  }
  return z(e, i, { backwards: true });
}
function jo(e, t, u, r) {
  let { comment: o, followingNode: n } = u[r], { locStart: a, locEnd: s } = t, i = s(o);
  if (n) for (let D = r + 1; D < u.length; D++) {
    let { comment: f2, followingNode: l2 } = u[D];
    if (l2 !== n || !_r(e.slice(i, a(f2)))) break;
    i = s(f2);
  }
  return z(e, i);
}
function yr(e, t) {
  let u = e.length;
  if (u === 0) return;
  let { precedingNode: r, followingNode: o } = e[0], n = t.locStart(o), a;
  for (a = u; a > 0; --a) {
    let { comment: s, precedingNode: i, followingNode: D } = e[a - 1];
    let f2 = t.originalText.slice(t.locEnd(s), n);
    if (t.printer.isGap?.(f2, t) ?? /^[\s(]*$/u.test(f2)) n = t.locStart(s);
    else break;
  }
  for (let [s, { comment: i }] of e.entries()) s < a ? le$1(r, i) : fe(o, i);
  for (let s of [r, o]) s.comments && s.comments.length > 1 && s.comments.sort((i, D) => t.locStart(i) - t.locStart(D));
  e.length = 0;
}
function tu(e, t, u) {
  let r = u.locStart(t) - 1;
  for (let o = 1; o < e.length; ++o) if (r < u.locStart(e[o])) return o - 1;
  return 0;
}
function Uo(e, t) {
  let u = t - 1;
  u = Y(e, u, { backwards: true }), u = K(e, u, { backwards: true }), u = Y(e, u, { backwards: true });
  let r = K(e, u, { backwards: true });
  return u !== r;
}
var Le = Uo;
function xr(e, t) {
  let u = e.node;
  return u.printed = true, t.printer.printComment(e, t);
}
function Wo(e, t) {
  let u = e.node, r = [xr(e, t)], { printer: o, originalText: n, locStart: a, locEnd: s } = t;
  if (o.isBlockComment?.(u)) {
    let f2 = z(n, s(u)) ? z(n, a(u), { backwards: true }) ? V : ut : " ";
    r.push(f2);
  } else r.push(V);
  let D = K(n, Y(n, s(u)));
  return D !== false && z(n, D) && r.push(V), r;
}
function $o(e, t, u) {
  let r = e.node, o = xr(e, t), { printer: n, originalText: a, locStart: s } = t, i = n.isBlockComment?.(r);
  if (u?.hasLineSuffix && !u?.isBlock || z(a, s(r), { backwards: true })) {
    let D = Le(a, s(r));
    return { doc: ve2([V, D ? V : "", o]), isBlock: i, hasLineSuffix: true };
  }
  return !i || u?.hasLineSuffix ? { doc: [ve2([" ", o]), ce], isBlock: i, hasLineSuffix: true } : { doc: [" ", o], isBlock: i, hasLineSuffix: false };
}
function Vo2(e, t) {
  let u = e.node;
  if (!u) return {};
  let r = t[/* @__PURE__ */ Symbol.for("printedComments")];
  if ((u.comments || []).filter((i) => !r.has(i)).length === 0) return { leading: "", trailing: "" };
  let n = [], a = [], s;
  return e.each(() => {
    let i = e.node;
    if (r?.has(i)) return;
    let { leading: D, trailing: f2 } = i;
    D ? n.push(Wo(e, t)) : f2 && (s = $o(e, t, s), a.push(s.doc));
  }, "comments"), { leading: n, trailing: a };
}
function Br2(e, t, u) {
  let { leading: r, trailing: o } = Vo2(e, u);
  return !r && !o ? t : Ee(t, (n) => [r, n, o]);
}
function Tr(e) {
  let { [/* @__PURE__ */ Symbol.for("comments")]: t, [/* @__PURE__ */ Symbol.for("printedComments")]: u } = e;
  for (let r of t) {
    if (!r.printed && !u.has(r)) throw new Error('Comment "' + r.value.trim() + '" was not printed. Please report this error!');
    delete r.printed;
  }
}
var Me = class extends Error {
  name = "ConfigError";
}, Ye = class extends Error {
  name = "UndefinedParserError";
};
var Sr = { checkIgnorePragma: { category: "Special", type: "boolean", default: false, description: "Check whether the file's first docblock comment contains '@noprettier' or '@noformat' to determine if it should be formatted.", cliCategory: "Other" }, cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (e) => typeof e == "string" || typeof e == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }, { value: "mjml", description: "MJML" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e) => typeof e == "string" || typeof e == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment in order for it to be formatted.", cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function it$1({ plugins: e = [], showDeprecated: t = false } = {}) {
  let u = e.flatMap((o) => o.languages ?? []), r = [];
  for (let o of Go(Object.assign({}, ...e.map(({ options: n }) => n), Sr))) !t && o.deprecated || (Array.isArray(o.choices) && (t || (o.choices = o.choices.filter((n) => !n.deprecated)), o.name === "parser" && (o.choices = [...o.choices, ...Ko(o.choices, u, e)])), o.pluginDefaults = Object.fromEntries(e.filter((n) => n.defaultOptions?.[o.name] !== void 0).map((n) => [n.name, n.defaultOptions[o.name]])), r.push(o));
  return { languages: u, options: r };
}
function* Ko(e, t, u) {
  let r = new Set(e.map((o) => o.value));
  for (let o of t) if (o.parsers) {
    for (let n of o.parsers) if (!r.has(n)) {
      r.add(n);
      let a = u.find((i) => i.parsers && Object.prototype.hasOwnProperty.call(i.parsers, n)), s = o.name;
      a?.name && (s += ` (plugin: ${a.name})`), yield { value: n, description: s };
    }
  }
}
function Go(e) {
  let t = [];
  for (let [u, r] of Object.entries(e)) {
    let o = { name: u, ...r };
    Array.isArray(o.default) && (o.default = b(0, o.default, -1).value), t.push(o);
  }
  return t;
}
var zo = Array.prototype.toReversed ?? function() {
  return [...this].reverse();
}, Jo = X("toReversed", function() {
  if (Array.isArray(this)) return zo;
}), wr$1 = Jo;
function Ho() {
  let e = globalThis, t = e.Deno?.build?.os;
  return typeof t == "string" ? t === "windows" : e.navigator?.platform?.startsWith("Win") ?? e.process?.platform?.startsWith("win") ?? false;
}
var Xo = Ho();
function Or$1(e) {
  if (e = e instanceof URL ? e : new URL(e), e.protocol !== "file:") throw new TypeError(`URL must be a file URL: received "${e.protocol}"`);
  return e;
}
function qo(e) {
  return e = Or$1(e), decodeURIComponent(e.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function Qo(e) {
  e = Or$1(e);
  let t = decodeURIComponent(e.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return e.hostname !== "" && (t = `\\\\${e.hostname}${t}`), t;
}
function ru(e) {
  return Xo ? Qo(e) : qo(e);
}
var Pr$1 = (e) => String(e).split(/[/\\]/u).pop(), Ir = (e) => String(e).startsWith("file:");
function kr(e, t) {
  if (!t) return;
  let u = Pr$1(t).toLowerCase();
  return e.find(({ filenames: r }) => r?.some((o) => o.toLowerCase() === u)) ?? e.find(({ extensions: r }) => r?.some((o) => u.endsWith(o)));
}
function Zo(e, t) {
  if (t) return e.find(({ name: u }) => u.toLowerCase() === t) ?? e.find(({ aliases: u }) => u?.includes(t)) ?? e.find(({ extensions: u }) => u?.includes(`.${t}`));
}
var ea = void 0;
function vr(e, t) {
  if (t) {
    if (Ir(t)) try {
      t = ru(t);
    } catch {
      return;
    }
    if (typeof t == "string") return e.find(({ isSupported: u }) => u?.({ filepath: t }));
  }
}
function ta(e, t) {
  let u = wr$1(0, e.plugins).flatMap((o) => o.languages ?? []);
  return (Zo(u, t.language) ?? kr(u, t.physicalFile) ?? kr(u, t.file) ?? vr(u, t.physicalFile) ?? vr(u, t.file) ?? ea?.(u, t.physicalFile))?.parsers[0];
}
var st = ta;
var ie = { key: (e) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e), value(e) {
  if (e === null || typeof e != "object") return JSON.stringify(e);
  if (Array.isArray(e)) return `[${e.map((u) => ie.value(u)).join(", ")}]`;
  let t = Object.keys(e);
  return t.length === 0 ? "{}" : `{ ${t.map((u) => `${ie.key(u)}: ${ie.value(e[u])}`).join(", ")} }`;
}, pair: ({ key: e, value: t }) => ie.value({ [e]: t }) };
var nu$1 = new Proxy(String, { get: () => nu$1 }), $ = nu$1, ou = () => nu$1;
var Rr = (e, t, { descriptor: u }) => {
  let r = [`${$.yellow(typeof e == "string" ? u.key(e) : u.pair(e))} is deprecated`];
  return t && r.push(`we now treat it as ${$.blue(typeof t == "string" ? u.key(t) : u.pair(t))}`), r.join("; ") + ".";
};
var Dt = /* @__PURE__ */ Symbol.for("vnopts.VALUE_NOT_EXIST"), Ae = /* @__PURE__ */ Symbol.for("vnopts.VALUE_UNCHANGED");
var Lr2 = " ".repeat(2), Yr2 = (e, t, u) => {
  let { text: r, list: o } = u.normalizeExpectedResult(u.schemas[e].expected(u)), n = [];
  return r && n.push(Mr(e, t, r, u.descriptor)), o && n.push([Mr(e, t, o.title, u.descriptor)].concat(o.values.map((a) => jr(a, u.loggerPrintWidth))).join(`
`)), Ur(n, u.loggerPrintWidth);
};
function Mr(e, t, u, r) {
  return [`Invalid ${$.red(r.key(e))} value.`, `Expected ${$.blue(u)},`, `but received ${t === Dt ? $.gray("nothing") : $.red(r.value(t))}.`].join(" ");
}
function jr({ text: e, list: t }, u) {
  let r = [];
  return e && r.push(`- ${$.blue(e)}`), t && r.push([`- ${$.blue(t.title)}:`].concat(t.values.map((o) => jr(o, u - Lr2.length).replace(/^|\n/g, `$&${Lr2}`))).join(`
`)), Ur(r, u);
}
function Ur(e, t) {
  if (e.length === 1) return e[0];
  let [u, r] = e, [o, n] = e.map((a) => a.split(`
`, 1)[0].length);
  return o > t && o > n ? r : u;
}
var _e = [], au = [];
function ct(e, t, u) {
  if (e === t) return 0;
  let r = u?.maxDistance, o = e;
  e.length > t.length && (e = t, t = o);
  let n = e.length, a = t.length;
  for (; n > 0 && e.charCodeAt(~-n) === t.charCodeAt(~-a); ) n--, a--;
  let s = 0;
  for (; s < n && e.charCodeAt(s) === t.charCodeAt(s); ) s++;
  if (n -= s, a -= s, r !== void 0 && a - n > r) return r;
  if (n === 0) return r !== void 0 && a > r ? r : a;
  let i, D, f2, l2, d = 0, c = 0;
  for (; d < n; ) au[d] = e.charCodeAt(s + d), _e[d] = ++d;
  for (; c < a; ) {
    for (i = t.charCodeAt(s + c), f2 = c++, D = c, d = 0; d < n; d++) l2 = i === au[d] ? f2 : f2 + 1, f2 = _e[d], D = _e[d] = f2 > D ? l2 > D ? D + 1 : l2 : l2 > f2 ? f2 + 1 : l2;
    if (r !== void 0) {
      let p = D;
      for (d = 0; d < n; d++) _e[d] < p && (p = _e[d]);
      if (p > r) return r;
    }
  }
  return _e.length = n, au.length = n, r !== void 0 && D > r ? r : D;
}
function Wr(e, t, u) {
  if (!Array.isArray(t) || t.length === 0) return;
  let r = u?.maxDistance, o = e.length;
  for (let i of t) if (i === e) return i;
  let n, a = Number.POSITIVE_INFINITY, s = /* @__PURE__ */ new Set();
  for (let i of t) {
    if (s.has(i)) continue;
    s.add(i);
    let D = Math.abs(i.length - o);
    if (D >= a || D > r) continue;
    let f2 = Number.isFinite(a) ? Math.min(a, r) : r, l2 = f2 === void 0 ? ct(e, i) : ct(e, i, { maxDistance: f2 });
    if (l2 > r) continue;
    let d = l2;
    if (f2 !== void 0 && l2 === f2 && f2 === r && (d = ct(e, i)), d < a && (a = d, n = i, a === 0)) break;
  }
  if (!(a > r)) return n;
}
var ft = (e, t, { descriptor: u, logger: r, schemas: o }) => {
  let n = [`Ignored unknown option ${$.yellow(u.pair({ key: e, value: t }))}.`], a = Wr(e, Object.keys(o), { maxDistance: 3 });
  a && n.push(`Did you mean ${$.blue(u.key(a))}?`), r.warn(n.join(" "));
};
var ua = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function ra(e, t) {
  let u = new e(t), r = Object.create(u);
  for (let o of ua) o in t && (r[o] = na(t[o], u, S.prototype[o].length));
  return r;
}
var S = class {
  static create(t) {
    return ra(this, t);
  }
  constructor(t) {
    this.name = t.name;
  }
  default(t) {
  }
  expected(t) {
    return "nothing";
  }
  validate(t, u) {
    return false;
  }
  deprecated(t, u) {
    return false;
  }
  forward(t, u) {
  }
  redirect(t, u) {
  }
  overlap(t, u, r) {
    return t;
  }
  preprocess(t, u) {
    return t;
  }
  postprocess(t, u) {
    return Ae;
  }
};
function na(e, t, u) {
  return typeof e == "function" ? (...r) => e(...r.slice(0, u - 1), t, ...r.slice(u - 1)) : () => e;
}
var lt$3 = class lt extends S {
  constructor(t) {
    super(t), this._sourceName = t.sourceName;
  }
  expected(t) {
    return t.schemas[this._sourceName].expected(t);
  }
  validate(t, u) {
    return u.schemas[this._sourceName].validate(t, u);
  }
  redirect(t, u) {
    return this._sourceName;
  }
};
var dt = class extends S {
  expected() {
    return "anything";
  }
  validate() {
    return true;
  }
};
var pt = class extends S {
  constructor({ valueSchema: t, name: u = t.name, ...r }) {
    super({ ...r, name: u }), this._valueSchema = t;
  }
  expected(t) {
    let { text: u, list: r } = t.normalizeExpectedResult(this._valueSchema.expected(t));
    return { text: u && `an array of ${u}`, list: r && { title: "an array of the following values", values: [{ list: r }] } };
  }
  validate(t, u) {
    if (!Array.isArray(t)) return false;
    let r = [];
    for (let o of t) {
      let n = u.normalizeValidateResult(this._valueSchema.validate(o, u), o);
      n !== true && r.push(n.value);
    }
    return r.length === 0 ? true : { value: r };
  }
  deprecated(t, u) {
    let r = [];
    for (let o of t) {
      let n = u.normalizeDeprecatedResult(this._valueSchema.deprecated(o, u), o);
      n !== false && r.push(...n.map(({ value: a }) => ({ value: [a] })));
    }
    return r;
  }
  forward(t, u) {
    let r = [];
    for (let o of t) {
      let n = u.normalizeForwardResult(this._valueSchema.forward(o, u), o);
      r.push(...n.map($r));
    }
    return r;
  }
  redirect(t, u) {
    let r = [], o = [];
    for (let n of t) {
      let a = u.normalizeRedirectResult(this._valueSchema.redirect(n, u), n);
      "remain" in a && r.push(a.remain), o.push(...a.redirect.map($r));
    }
    return r.length === 0 ? { redirect: o } : { redirect: o, remain: r };
  }
  overlap(t, u) {
    return t.concat(u);
  }
};
function $r({ from: e, to: t }) {
  return { from: [e], to: t };
}
var Ft = class extends S {
  expected() {
    return "true or false";
  }
  validate(t) {
    return typeof t == "boolean";
  }
};
function Kr(e, t) {
  let u = /* @__PURE__ */ Object.create(null);
  for (let r of e) {
    let o = r[t];
    if (u[o]) throw new Error(`Duplicate ${t} ${JSON.stringify(o)}`);
    u[o] = r;
  }
  return u;
}
function Gr(e, t) {
  let u = /* @__PURE__ */ new Map();
  for (let r of e) {
    let o = r[t];
    if (u.has(o)) throw new Error(`Duplicate ${t} ${JSON.stringify(o)}`);
    u.set(o, r);
  }
  return u;
}
function zr() {
  let e = /* @__PURE__ */ Object.create(null);
  return (t) => {
    let u = JSON.stringify(t);
    return e[u] ? true : (e[u] = true, false);
  };
}
function Jr(e, t) {
  let u = [], r = [];
  for (let o of e) t(o) ? u.push(o) : r.push(o);
  return [u, r];
}
function Hr(e) {
  return e === Math.floor(e);
}
function Xr(e, t) {
  if (e === t) return 0;
  let u = typeof e, r = typeof t, o = ["undefined", "object", "boolean", "number", "string"];
  return u !== r ? o.indexOf(u) - o.indexOf(r) : u !== "string" ? Number(e) - Number(t) : e.localeCompare(t);
}
function qr(e) {
  return (...t) => {
    let u = e(...t);
    return typeof u == "string" ? new Error(u) : u;
  };
}
function iu(e) {
  return e === void 0 ? {} : e;
}
function su(e) {
  if (typeof e == "string") return { text: e };
  let { text: t, list: u } = e;
  return oa((t || u) !== void 0, "Unexpected `expected` result, there should be at least one field."), u ? { text: t, list: { title: u.title, values: u.values.map(su) } } : { text: t };
}
function Du(e, t) {
  return e === true ? true : e === false ? { value: t } : e;
}
function cu(e, t, u = false) {
  return e === false ? false : e === true ? u ? true : [{ value: t }] : "value" in e ? [e] : e.length === 0 ? false : e;
}
function Vr2(e, t) {
  return typeof e == "string" || "key" in e ? { from: t, to: e } : "from" in e ? { from: e.from, to: e.to } : { from: t, to: e.to };
}
function mt(e, t) {
  return e === void 0 ? [] : Array.isArray(e) ? e.map((u) => Vr2(u, t)) : [Vr2(e, t)];
}
function fu(e, t) {
  let u = mt(typeof e == "object" && "redirect" in e ? e.redirect : e, t);
  return u.length === 0 ? { remain: t, redirect: u } : typeof e == "object" && "remain" in e ? { remain: e.remain, redirect: u } : { redirect: u };
}
function oa(e, t) {
  if (!e) throw new Error(t);
}
var Et = class extends S {
  constructor(t) {
    super(t), this._choices = Gr(t.choices.map((u) => u && typeof u == "object" ? u : { value: u }), "value");
  }
  expected({ descriptor: t }) {
    let u = Array.from(this._choices.keys()).map((a) => this._choices.get(a)).filter(({ hidden: a }) => !a).map((a) => a.value).sort(Xr).map(t.value), r = u.slice(0, -2), o = u.slice(-2);
    return { text: r.concat(o.join(" or ")).join(", "), list: { title: "one of the following values", values: u } };
  }
  validate(t) {
    return this._choices.has(t);
  }
  deprecated(t) {
    let u = this._choices.get(t);
    return u && u.deprecated ? { value: t } : false;
  }
  forward(t) {
    let u = this._choices.get(t);
    return u ? u.forward : void 0;
  }
  redirect(t) {
    let u = this._choices.get(t);
    return u ? u.redirect : void 0;
  }
};
var Ct = class extends S {
  expected() {
    return "a number";
  }
  validate(t, u) {
    return typeof t == "number";
  }
};
var ht2 = class extends Ct {
  expected() {
    return "an integer";
  }
  validate(t, u) {
    return u.normalizeValidateResult(super.validate(t, u), t) === true && Hr(t);
  }
};
var je = class extends S {
  expected() {
    return "a string";
  }
  validate(t) {
    return typeof t == "string";
  }
};
var Qr = ie, Zr = ft, en = Yr2, tn = Rr;
var gt$4 = class gt2 {
  constructor(t, u) {
    let { logger: r = console, loggerPrintWidth: o = 80, descriptor: n = Qr, unknown: a = Zr, invalid: s = en, deprecated: i = tn, missing: D = () => false, required: f2 = () => false, preprocess: l2 = (c) => c, postprocess: d = () => Ae } = u || {};
    this._utils = { descriptor: n, logger: r || { warn: () => {
    } }, loggerPrintWidth: o, schemas: Kr(t, "name"), normalizeDefaultResult: iu, normalizeExpectedResult: su, normalizeDeprecatedResult: cu, normalizeForwardResult: mt, normalizeRedirectResult: fu, normalizeValidateResult: Du }, this._unknownHandler = a, this._invalidHandler = qr(s), this._deprecatedHandler = i, this._identifyMissing = (c, p) => !(c in p) || D(c, p), this._identifyRequired = f2, this._preprocess = l2, this._postprocess = d, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = zr();
  }
  normalize(t) {
    let u = {}, o = [this._preprocess(t, this._utils)], n = () => {
      for (; o.length !== 0; ) {
        let a = o.shift(), s = this._applyNormalization(a, u);
        o.push(...s);
      }
    };
    n();
    for (let a of Object.keys(this._utils.schemas)) {
      let s = this._utils.schemas[a];
      if (!(a in u)) {
        let i = iu(s.default(this._utils));
        "value" in i && o.push({ [a]: i.value });
      }
    }
    n();
    for (let a of Object.keys(this._utils.schemas)) {
      if (!(a in u)) continue;
      let s = this._utils.schemas[a], i = u[a], D = s.postprocess(i, this._utils);
      D !== Ae && (this._applyValidation(D, a, s), u[a] = D);
    }
    return this._applyPostprocess(u), this._applyRequiredCheck(u), u;
  }
  _applyNormalization(t, u) {
    let r = [], { knownKeys: o, unknownKeys: n } = this._partitionOptionKeys(t);
    for (let a of o) {
      let s = this._utils.schemas[a], i = s.preprocess(t[a], this._utils);
      this._applyValidation(i, a, s);
      let D = ({ from: c, to: p }) => {
        r.push(typeof p == "string" ? { [p]: c } : { [p.key]: p.value });
      }, f2 = ({ value: c, redirectTo: p }) => {
        let F2 = cu(s.deprecated(c, this._utils), i, true);
        if (F2 !== false) if (F2 === true) this._hasDeprecationWarned(a) || this._utils.logger.warn(this._deprecatedHandler(a, p, this._utils));
        else for (let { value: C2 } of F2) {
          let y2 = { key: a, value: C2 };
          if (!this._hasDeprecationWarned(y2)) {
            let m = typeof p == "string" ? { key: p, value: C2 } : p;
            this._utils.logger.warn(this._deprecatedHandler(y2, m, this._utils));
          }
        }
      };
      mt(s.forward(i, this._utils), i).forEach(D);
      let d = fu(s.redirect(i, this._utils), i);
      if (d.redirect.forEach(D), "remain" in d) {
        let c = d.remain;
        u[a] = a in u ? s.overlap(u[a], c, this._utils) : c, f2({ value: c });
      }
      for (let { from: c, to: p } of d.redirect) f2({ value: c, redirectTo: p });
    }
    for (let a of n) {
      let s = t[a];
      this._applyUnknownHandler(a, s, u, (i, D) => {
        r.push({ [i]: D });
      });
    }
    return r;
  }
  _applyRequiredCheck(t) {
    for (let u of Object.keys(this._utils.schemas)) if (this._identifyMissing(u, t) && this._identifyRequired(u)) throw this._invalidHandler(u, Dt, this._utils);
  }
  _partitionOptionKeys(t) {
    let [u, r] = Jr(Object.keys(t).filter((o) => !this._identifyMissing(o, t)), (o) => o in this._utils.schemas);
    return { knownKeys: u, unknownKeys: r };
  }
  _applyValidation(t, u, r) {
    let o = Du(r.validate(t, this._utils), t);
    if (o !== true) throw this._invalidHandler(u, o.value, this._utils);
  }
  _applyUnknownHandler(t, u, r, o) {
    let n = this._unknownHandler(t, u, this._utils);
    if (n) for (let a of Object.keys(n)) {
      if (this._identifyMissing(a, n)) continue;
      let s = n[a];
      a in this._utils.schemas ? o(a, s) : r[a] = s;
    }
  }
  _applyPostprocess(t) {
    let u = this._postprocess(t, this._utils);
    if (u !== Ae) {
      if (u.delete) for (let r of u.delete) delete t[r];
      if (u.override) {
        let { knownKeys: r, unknownKeys: o } = this._partitionOptionKeys(u.override);
        for (let n of r) {
          let a = u.override[n];
          this._applyValidation(a, n, this._utils.schemas[n]), t[n] = a;
        }
        for (let n of o) {
          let a = u.override[n];
          this._applyUnknownHandler(n, a, t, (s, i) => {
            let D = this._utils.schemas[s];
            this._applyValidation(i, s, D), t[s] = i;
          });
        }
      }
    }
  }
};
var lu;
function ia(e, t, { logger: u = false, isCLI: r = false, passThrough: o = false, FlagSchema: n, descriptor: a } = {}) {
  if (r) {
    if (!n) throw new Error("'FlagSchema' option is required.");
    if (!a) throw new Error("'descriptor' option is required.");
  } else a = ie;
  let s = o ? Array.isArray(o) ? (d, c) => o.includes(d) ? { [d]: c } : void 0 : (d, c) => ({ [d]: c }) : (d, c, p) => {
    let { _: F2, ...C2 } = p.schemas;
    return ft(d, c, { ...p, schemas: C2 });
  }, i = sa(t, { isCLI: r, FlagSchema: n }), D = new gt$4(i, { logger: u, unknown: s, descriptor: a }), f2 = u !== false;
  f2 && lu && (D._hasDeprecationWarned = lu);
  let l2 = D.normalize(e);
  return f2 && (lu = D._hasDeprecationWarned), l2;
}
function sa(e, { isCLI: t, FlagSchema: u }) {
  let r = [];
  t && r.push(dt.create({ name: "_" }));
  for (let o of e) r.push(Da(o, { isCLI: t, optionInfos: e, FlagSchema: u })), o.alias && t && r.push(lt$3.create({ name: o.alias, sourceName: o.name }));
  return r;
}
function Da(e, { isCLI: t, optionInfos: u, FlagSchema: r }) {
  let { name: o } = e, n = { name: o }, a, s = {};
  switch (e.type) {
    case "int":
      a = ht2, t && (n.preprocess = Number);
      break;
    case "string":
      a = je;
      break;
    case "choice":
      a = Et, n.choices = e.choices.map((i) => i?.redirect ? { ...i, redirect: { to: { key: e.name, value: i.redirect } } } : i);
      break;
    case "boolean":
      a = Ft;
      break;
    case "flag":
      a = r, n.flags = u.flatMap((i) => [i.alias, i.description && i.name, i.oppositeDescription && `no-${i.name}`].filter(Boolean));
      break;
    case "path":
      a = je;
      break;
    default:
      throw new Error(`Unexpected type ${e.type}`);
  }
  if (e.exception ? n.validate = (i, D, f2) => e.exception(i) || D.validate(i, f2) : n.validate = (i, D, f2) => i === void 0 || D.validate(i, f2), e.redirect && (s.redirect = (i) => i ? { to: typeof e.redirect == "string" ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : void 0), e.deprecated && (s.deprecated = true), t && !e.array) {
    let i = n.preprocess || ((D) => D);
    n.preprocess = (D, f2, l2) => f2.preprocess(i(Array.isArray(D) ? b(0, D, -1) : D), l2);
  }
  return e.array ? pt.create({ ...t ? { preprocess: (i) => Array.isArray(i) ? i : [i] } : {}, ...s, valueSchema: a.create(n) }) : a.create({ ...n, ...s });
}
var un = ia;
var ca = Array.prototype.findLast ?? function(e) {
  for (let t = this.length - 1; t >= 0; t--) {
    let u = this[t];
    if (e(u, t, this)) return u;
  }
}, fa = X("findLast", function() {
  if (Array.isArray(this)) return ca;
}), du = fa;
var rn = /* @__PURE__ */ Symbol.for("PRETTIER_IS_FRONT_MATTER"), pu = [];
function la(e) {
  return !!e?.[rn];
}
var de = la;
var nn = /* @__PURE__ */ new Set(["yaml", "toml"]), Ue = ({ node: e }) => de(e) && nn.has(e.language);
async function Fu(e, t, u, r) {
  let { node: o } = u, { language: n } = o;
  if (!nn.has(n)) return;
  let a = o.value.trim(), s;
  if (a) {
    let i = n === "yaml" ? n : st(r, { language: n });
    if (!i) return;
    s = a ? await e(a, { parser: i }) : "";
  } else s = a;
  return et([o.startDelimiter, o.explicitLanguage ?? "", V, s, s ? V : "", o.endDelimiter]);
}
function da(e, t) {
  return Ue({ node: e }) && (delete t.end, delete t.raw, delete t.value), t;
}
var mu$1 = da;
function pa({ node: e }) {
  return e.raw;
}
var Eu = pa;
var on = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]), Fa = (e) => Object.keys(e).filter((t) => !on.has(t));
function ma(e, t) {
  let u = e ? (r) => e(r, on) : Fa;
  return t ? new Proxy(u, { apply: (r, o, n) => de(n[0]) ? pu : Reflect.apply(r, o, n) }) : u;
}
var Cu = ma;
function gu(e, t) {
  if (!t) throw new Error("parserName is required.");
  let u = du(0, e, (o) => o.parsers && Object.prototype.hasOwnProperty.call(o.parsers, t));
  if (u) return u;
  let r = `Couldn't resolve parser "${t}".`;
  throw r += " Plugins must be explicitly added to the standalone bundle.", new Me(r);
}
function an(e, t) {
  if (!t) throw new Error("astFormat is required.");
  let u = du(0, e, (o) => o.printers && Object.prototype.hasOwnProperty.call(o.printers, t));
  if (u) return u;
  let r = `Couldn't find plugin for AST format "${t}".`;
  throw r += " Plugins must be explicitly added to the standalone bundle.", new Me(r);
}
function We2({ plugins: e, parser: t }) {
  let u = gu(e, t);
  return yu(u, t);
}
function yu(e, t) {
  let u = e.parsers[t];
  return typeof u == "function" ? u() : u;
}
async function sn(e, t) {
  let u = e.printers[t], r = typeof u == "function" ? await u() : u;
  return Ea(r);
}
var hu = /* @__PURE__ */ new WeakMap();
function Ea(e) {
  if (hu.has(e)) return hu.get(e);
  let { features: t, getVisitorKeys: u, embed: r, massageAstNode: o, print: n, ...a } = e;
  t = ya(t);
  let s = t.experimental_frontMatterSupport;
  u = Cu(u, s.massageAstNode || s.embed || s.print);
  let i = o;
  o && s.massageAstNode && (i = new Proxy(o, { apply(d, c, p) {
    return mu$1(...p), Reflect.apply(d, c, p);
  } }));
  let D = r;
  if (r) {
    let d;
    D = new Proxy(r, { get(c, p, F2) {
      return p === "getVisitorKeys" ? (d ?? (d = r.getVisitorKeys ? Cu(r.getVisitorKeys, s.massageAstNode || s.embed) : u), d) : Reflect.get(c, p, F2);
    }, apply: (c, p, F2) => s.embed && Ue(...F2) ? Fu : Reflect.apply(c, p, F2) });
  }
  let f2 = n;
  s.print && (f2 = new Proxy(n, { apply(d, c, p) {
    let [F2] = p;
    return de(F2.node) ? Eu(F2) : Reflect.apply(d, c, p);
  } }));
  let l2 = { features: t, getVisitorKeys: u, embed: D, massageAstNode: i, print: f2, ...a };
  return hu.set(e, l2), l2;
}
var Ca = ["clean", "embed", "print"], ha = Object.fromEntries(Ca.map((e) => [e, false]));
function ga(e) {
  return { ...ha, ...e };
}
function ya(e) {
  return { experimental_avoidAstMutation: false, ...e, experimental_frontMatterSupport: ga(e?.experimental_frontMatterSupport) };
}
var Dn = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null, getVisitorKeys: null };
async function ba(e, t = {}) {
  let u = { ...e };
  if (!u.parser) if (u.filepath) {
    if (u.parser = st(u, { physicalFile: u.filepath }), !u.parser) throw new Ye(`No parser could be inferred for file "${u.filepath}".`);
  } else throw new Ye("No parser and no file path given, couldn't infer a parser.");
  let r = it$1({ plugins: e.plugins, showDeprecated: true }).options, o = { ...Dn, ...Object.fromEntries(r.filter((l2) => l2.default !== void 0).map((l2) => [l2.name, l2.default])) }, n = gu(u.plugins, u.parser), a = await yu(n, u.parser);
  u.astFormat = a.astFormat, u.locEnd = a.locEnd, u.locStart = a.locStart;
  let s = n.printers?.[a.astFormat] ? n : an(u.plugins, a.astFormat), i = await sn(s, a.astFormat);
  u.printer = i, u.getVisitorKeys = i.getVisitorKeys;
  let D = s.defaultOptions ? Object.fromEntries(Object.entries(s.defaultOptions).filter(([, l2]) => l2 !== void 0)) : {}, f2 = { ...o, ...D };
  for (let [l2, d] of Object.entries(f2)) (u[l2] === null || u[l2] === void 0) && (u[l2] = d);
  return u.parser === "json" && (u.trailingComma = "none"), un(u, r, { passThrough: Object.keys(Dn), ...t });
}
var se = ba;
ao(dn());
var _u = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] };
new Set(_u.keyword);
new Set(_u.strict);
new Set(_u.strictBind);
var It = (e, t) => (u) => e(t(u));
function mn(e) {
  return { keyword: e.cyan, capitalized: e.yellow, jsxIdentifier: e.yellow, punctuator: e.yellow, number: e.magenta, string: e.green, regex: e.magenta, comment: e.gray, invalid: It(It(e.white, e.bgRed), e.bold), gutter: e.gray, marker: It(e.red, e.bold), message: It(e.red, e.bold), reset: e.reset };
}
mn(ou());
mn(ou());
function _a() {
  return new Proxy({}, { get: () => (e) => e });
}
var Fn = /\r\n|[\n\r\u2028\u2029]/;
function xa(e, t, u) {
  let r = Object.assign({ column: 0, line: -1 }, e.start), o = Object.assign({}, r, e.end), { linesAbove: n = 2, linesBelow: a = 3 } = u || {}, s = r.line, i = r.column, D = o.line, f2 = o.column, l2 = Math.max(s - (n + 1), 0), d = Math.min(t.length, D + a);
  s === -1 && (l2 = 0), D === -1 && (d = t.length);
  let c = D - s, p = {};
  if (c) for (let F2 = 0; F2 <= c; F2++) {
    let C2 = F2 + s;
    if (!i) p[C2] = true;
    else if (F2 === 0) {
      let y2 = t[C2 - 1].length;
      p[C2] = [i, y2 - i + 1];
    } else if (F2 === c) p[C2] = [0, f2];
    else {
      let y2 = t[C2 - F2].length;
      p[C2] = [0, y2];
    }
  }
  else i === f2 ? i ? p[s] = [i, 0] : p[s] = true : p[s] = [i, f2 - i];
  return { start: l2, end: d, markerLines: p };
}
function En(e, t, u = {}) {
  let o = _a(), n = e.split(Fn), { start: a, end: s, markerLines: i } = xa(t, n, u), D = t.start && typeof t.start.column == "number", f2 = String(s).length, d = e.split(Fn, s).slice(a, s).map((c, p) => {
    let F2 = a + 1 + p, y2 = ` ${` ${F2}`.slice(-f2)} |`, m = i[F2], h2 = !i[F2 + 1];
    if (m) {
      let E = "";
      if (Array.isArray(m)) {
        let g = c.slice(0, Math.max(m[0] - 1, 0)).replace(/[^\t]/g, " "), A2 = m[1] || 1;
        E = [`
 `, o.gutter(y2.replace(/\d/g, " ")), " ", g, o.marker("^").repeat(A2)].join(""), h2 && u.message && (E += " " + o.message(u.message));
      }
      return [o.marker(">"), o.gutter(y2), c.length > 0 ? ` ${c}` : "", E].join("");
    } else return ` ${o.gutter(y2)}${c.length > 0 ? ` ${c}` : ""}`;
  }).join(`
`);
  return u.message && !D && (d = `${" ".repeat(f2 + 1)}${u.message}
${d}`), d;
}
async function Ba(e, t) {
  let u = await We2(t), r = u.preprocess ? await u.preprocess(e, t) : e;
  t.originalText = r;
  let o;
  try {
    o = await u.parse(r, t, t);
  } catch (n) {
    Ta(n, e);
  }
  return { text: r, ast: o };
}
function Ta(e, t) {
  let { loc: u } = e;
  if (u) {
    let r = En(t, u, {});
    throw e.message += `
` + r, e.codeFrame = r, e;
  }
  throw e;
}
var Fe = Ba;
async function Cn(e, t, u, r, o) {
  if (u.embeddedLanguageFormatting !== "auto") return;
  let { printer: n } = u, { embed: a } = n;
  if (!a) return;
  if (a.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
  let { hasPrettierIgnore: s } = n, { getVisitorKeys: i } = a, D = [];
  d();
  let f2 = e.stack;
  for (let { print: c, node: p, pathStack: F2 } of D) try {
    e.stack = F2;
    let C2 = await c(l2, t, e, u);
    C2 && o.set(p, C2);
  } catch (C2) {
    if (globalThis.PRETTIER_DEBUG) throw C2;
  }
  e.stack = f2;
  function l2(c, p) {
    return Na(c, p, u, r);
  }
  function d() {
    let { node: c } = e;
    if (c === null || typeof c != "object" || s?.(e)) return;
    for (let F2 of i(c)) Array.isArray(c[F2]) ? e.each(d, F2) : e.call(d, F2);
    let p = a(e, u);
    if (p) {
      if (typeof p == "function") {
        D.push({ print: p, node: c, pathStack: [...e.stack] });
        return;
      }
      o.set(c, p);
    }
  }
}
async function Na(e, t, u, r) {
  let o = await se({ ...u, ...t, parentParser: u.parser, originalText: e, cursorOffset: void 0, rangeStart: void 0, rangeEnd: void 0 }, { passThrough: true }), { ast: n } = await Fe(e, o), a = await r(n, o);
  return qe(a);
}
function Sa(e, t, u, r) {
  let { originalText: o, [/* @__PURE__ */ Symbol.for("comments")]: n, locStart: a, locEnd: s, [/* @__PURE__ */ Symbol.for("printedComments")]: i } = t, { node: D } = e, f2 = a(D), l2 = s(D);
  for (let c of n) a(c) >= f2 && s(c) <= l2 && i.add(c);
  let { printPrettierIgnored: d } = t.printer;
  return d ? d(e, t, u, r) : o.slice(f2, l2);
}
var hn = Sa;
async function Ge(e, t) {
  ({ ast: e } = await xu(e, t));
  let u = /* @__PURE__ */ new Map(), r = new pr$1(e), n = /* @__PURE__ */ new Map();
  await Cn(r, s, t, Ge, n);
  let a = await gn(r, t, s, void 0, n);
  if (Tr(t), t.cursorOffset >= 0) {
    if (t.nodeAfterCursor && !t.nodeBeforeCursor) return [ee$1, a];
    if (t.nodeBeforeCursor && !t.nodeAfterCursor) return [a, ee$1];
  }
  return a;
  function s(D, f2) {
    return D === void 0 || D === r ? i(f2) : Array.isArray(D) ? r.call(() => i(f2), ...D) : r.call(() => i(f2), D);
  }
  function i(D) {
    let f2 = r.node;
    if (f2 == null) return "";
    let l2 = ge$1(f2) && D === void 0;
    if (l2 && u.has(f2)) return u.get(f2);
    let d = gn(r, t, s, D, n);
    return l2 && u.set(f2, d), d;
  }
}
function gn(e, t, u, r, o) {
  let { node: n } = e, { printer: a } = t, s;
  switch (a.hasPrettierIgnore?.(e) ? s = hn(e, t, u, r) : o.has(n) ? s = o.get(n) : s = a.print(e, t, u, r), n) {
    case t.cursorNode:
      s = Ee(s, (i) => [ee$1, i, ee$1]);
      break;
    case t.nodeBeforeCursor:
      s = Ee(s, (i) => [i, ee$1]);
      break;
    case t.nodeAfterCursor:
      s = Ee(s, (i) => [ee$1, i]);
      break;
  }
  return a.printComment && !a.willPrintOwnComments?.(e, t) && (s = Br2(e, s, t)), s;
}
async function xu(e, t) {
  let u = e.comments ?? [];
  t[/* @__PURE__ */ Symbol.for("comments")] = u, t[/* @__PURE__ */ Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), Ar(e, t);
  let { printer: { preprocess: r } } = t;
  return e = r ? await r(e, t) : e, { ast: e, comments: u };
}
function wa(e, t) {
  let { cursorOffset: u, locStart: r, locEnd: o, getVisitorKeys: n } = t, a = (c) => r(c) <= u && o(c) >= u, s = e, i = [e];
  for (let c of Cr(e, { getVisitorKeys: n, filter: a })) i.push(c), s = c;
  if (hr(s, { getVisitorKeys: n })) return { cursorNode: s };
  let D, f2, l2 = -1, d = Number.POSITIVE_INFINITY;
  for (; i.length > 0 && (D === void 0 || f2 === void 0); ) {
    s = i.pop();
    let c = D !== void 0, p = f2 !== void 0;
    for (let F2 of be(s, { getVisitorKeys: n })) {
      if (!c) {
        let C2 = o(F2);
        C2 <= u && C2 > l2 && (D = F2, l2 = C2);
      }
      if (!p) {
        let C2 = r(F2);
        C2 >= u && C2 < d && (f2 = F2, d = C2);
      }
    }
  }
  return { nodeBeforeCursor: D, nodeAfterCursor: f2 };
}
var Bu = wa;
function Oa(e, t) {
  let { printer: u } = t, r = u.massageAstNode;
  if (!r) return e;
  let { getVisitorKeys: o } = u, { ignoredProperties: n } = r;
  return a(e);
  function a(s, i) {
    if (!ge$1(s)) return s;
    if (Array.isArray(s)) return s.map((d) => a(d, i)).filter(Boolean);
    let D = {}, f2 = new Set(o(s));
    for (let d in s) !Object.prototype.hasOwnProperty.call(s, d) || n?.has(d) || (f2.has(d) ? D[d] = a(s[d], s) : D[d] = s[d]);
    let l2 = r(s, D, i);
    if (l2 !== null) return l2 ?? D;
  }
}
var yn = Oa;
var Pa = Array.prototype.findLastIndex ?? function(e) {
  for (let t = this.length - 1; t >= 0; t--) {
    let u = this[t];
    if (e(u, t, this)) return t;
  }
  return -1;
}, Ia = X("findLastIndex", function() {
  if (Array.isArray(this)) return Pa;
}), bn = Ia;
var ka = ({ parser: e }) => e === "json" || e === "json5" || e === "jsonc" || e === "json-stringify";
function va(e, t) {
  return t = new Set(t), e.find((u) => xn.has(u.type) && t.has(u));
}
function An(e) {
  let t = bn(0, e, (u) => u.type !== "Program" && u.type !== "File");
  return t === -1 ? e : e.slice(0, t + 1);
}
function Ra(e, t, { locStart: u, locEnd: r }) {
  let [o, ...n] = e, [a, ...s] = t;
  if (o === a) return [o, a];
  let i = u(o);
  for (let f2 of An(s)) if (u(f2) >= i) a = f2;
  else break;
  let D = r(a);
  for (let f2 of An(n)) {
    if (r(f2) <= D) o = f2;
    else break;
    if (o === a) break;
  }
  return [o, a];
}
function Tu(e, t, u, r, o = [], n) {
  let { locStart: a, locEnd: s } = u, i = a(e), D = s(e);
  if (t > D || t < i || n === "rangeEnd" && t === i || n === "rangeStart" && t === D) return;
  let f2 = [e, ...o], l2 = at(e, f2, { cache: uu, locStart: a, locEnd: s, getVisitorKeys: u.getVisitorKeys, filter: u.printer.canAttachComment, getChildren: u.printer.getCommentChildNodes });
  for (let d of l2) {
    let c = Tu(d, t, u, r, f2, n);
    if (c) return c;
  }
  if (r(e, o[0])) return f2;
}
function La(e, t) {
  return t !== "DeclareExportDeclaration" && e !== "TypeParameterDeclaration" && (e === "Directive" || e === "TypeAlias" || e === "TSExportAssignment" || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
}
var xn = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), Ma = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function _n(e, t, u) {
  if (!t) return false;
  switch (e.parser) {
    case "flow":
    case "hermes":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "oxc":
    case "oxc-ts":
    case "__babel_estree":
      return La(t.type, u?.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return xn.has(t.type);
    case "graphql":
      return Ma.has(t.kind);
    case "vue":
      return t.tag !== "root";
  }
  return false;
}
function Bn(e, t, u) {
  let { rangeStart: r, rangeEnd: o, locStart: n, locEnd: a } = t;
  let s = e.slice(r, o).search(/\S/u), i = s === -1;
  if (!i) for (r += s; o > r && !/\S/u.test(e[o - 1]); --o) ;
  let D = Tu(u, r, t, (c, p) => _n(t, c, p), [], "rangeStart");
  if (!D) return;
  let f2 = i ? D : Tu(u, o, t, (c) => _n(t, c), [], "rangeEnd");
  if (!f2) return;
  let l2, d;
  if (ka(t)) {
    let c = va(D, f2);
    l2 = c, d = c;
  } else [l2, d] = Ra(D, f2, t);
  return [Math.min(n(l2), n(d)), Math.max(a(l2), a(d))];
}
var wn = "\uFEFF", Tn = /* @__PURE__ */ Symbol("cursor");
async function On(e, t, u = 0) {
  if (!e || e.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: r, text: o } = await Fe(e, t);
  t.cursorOffset >= 0 && (t = { ...t, ...Bu(r, t) });
  let n = await Ge(r, t);
  u > 0 && (n = tt([V, n], u, t.tabWidth));
  let a = Ce2(n, t);
  if (u > 0) {
    let i = a.formatted.trim();
    a.cursorNodeStart !== void 0 && (a.cursorNodeStart -= a.formatted.indexOf(i), a.cursorNodeStart < 0 && (a.cursorNodeStart = 0, a.cursorNodeText = a.cursorNodeText.trimStart()), a.cursorNodeStart + a.cursorNodeText.length > i.length && (a.cursorNodeText = a.cursorNodeText.trimEnd())), a.formatted = i + Se(t.endOfLine);
  }
  let s = t[/* @__PURE__ */ Symbol.for("comments")];
  if (t.cursorOffset >= 0) {
    let i, D, f2, l2;
    if ((t.cursorNode || t.nodeBeforeCursor || t.nodeAfterCursor) && a.cursorNodeText) if (f2 = a.cursorNodeStart, l2 = a.cursorNodeText, t.cursorNode) i = t.locStart(t.cursorNode), D = o.slice(i, t.locEnd(t.cursorNode));
    else {
      if (!t.nodeBeforeCursor && !t.nodeAfterCursor) throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
      i = t.nodeBeforeCursor ? t.locEnd(t.nodeBeforeCursor) : 0;
      let y2 = t.nodeAfterCursor ? t.locStart(t.nodeAfterCursor) : o.length;
      D = o.slice(i, y2);
    }
    else i = 0, D = o, f2 = 0, l2 = a.formatted;
    let d = t.cursorOffset - i;
    if (D === l2) return { formatted: a.formatted, cursorOffset: f2 + d, comments: s };
    let c = D.split("");
    c.splice(d, 0, Tn);
    let p = l2.split(""), F2 = Ut(c, p), C2 = f2;
    for (let y2 of F2) if (y2.removed) {
      if (y2.value.includes(Tn)) break;
    } else C2 += y2.count;
    return { formatted: a.formatted, cursorOffset: C2, comments: s };
  }
  return { formatted: a.formatted, cursorOffset: -1, comments: s };
}
async function Ya(e, t) {
  let { ast: u, text: r } = await Fe(e, t), [o, n] = Bn(r, t, u) ?? [0, 0], a = r.slice(o, n), s = Math.min(o, r.lastIndexOf(`
`, o) + 1), i = r.slice(s, o).match(/^\s*/u)[0], D = he$2(i, t.tabWidth), f2 = await On(a, { ...t, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > o && t.cursorOffset <= n ? t.cursorOffset - o : -1, endOfLine: "lf" }, D), l2 = f2.formatted.trimEnd(), { cursorOffset: d } = t;
  d > n ? d += l2.length - a.length : f2.cursorOffset >= 0 && (d = f2.cursorOffset + o);
  let c = r.slice(0, o) + l2 + r.slice(n);
  if (t.endOfLine !== "lf") {
    let p = Se(t.endOfLine);
    d >= 0 && p === `\r
` && (d += $t(c.slice(0, d), `
`)), c = oe(0, c, `
`, p);
  }
  return { formatted: c, cursorOffset: d, comments: f2.comments };
}
function Nu$1(e, t, u) {
  return typeof t != "number" || Number.isNaN(t) || t < 0 || t > e.length ? u : t;
}
function Nn(e, t) {
  let { cursorOffset: u, rangeStart: r, rangeEnd: o } = t;
  return u = Nu$1(e, u, -1), r = Nu$1(e, r, 0), o = Nu$1(e, o, e.length), { ...t, cursorOffset: u, rangeStart: r, rangeEnd: o };
}
function Pn(e, t) {
  let { cursorOffset: u, rangeStart: r, rangeEnd: o, endOfLine: n } = Nn(e, t), a = e.charAt(0) === wn;
  if (a && (e = e.slice(1), u--, r--, o--), n === "auto" && (n = Yu(e)), e.includes("\r")) {
    let s = (i) => $t(e.slice(0, Math.max(i, 0)), `\r
`);
    u -= s(u), r -= s(r), o -= s(o), e = ju(e);
  }
  return { hasBOM: a, text: e, options: Nn(e, { ...t, cursorOffset: u, rangeStart: r, rangeEnd: o, endOfLine: n }) };
}
async function Sn(e, t) {
  let u = await We2(t);
  return !u.hasPragma || u.hasPragma(e);
}
async function ja(e, t) {
  return (await We2(t)).hasIgnorePragma?.(e);
}
async function Su(e, t) {
  let { hasBOM: u, text: r, options: o } = Pn(e, await se(t));
  if (o.rangeStart >= o.rangeEnd && r !== "" || o.requirePragma && !await Sn(r, o) || o.checkIgnorePragma && await ja(r, o)) return { formatted: e, cursorOffset: t.cursorOffset, comments: [] };
  let n;
  return o.rangeStart > 0 || o.rangeEnd < r.length ? n = await Ya(r, o) : (!o.requirePragma && o.insertPragma && o.printer.insertPragma && !await Sn(r, o) && (r = o.printer.insertPragma(r)), n = await On(r, o)), u && (n.formatted = wn + n.formatted, n.cursorOffset >= 0 && n.cursorOffset++), n;
}
async function In(e, t, u) {
  let { text: r, options: o } = Pn(e, await se(t)), n = await Fe(r, o);
  return u && (u.preprocessForPrint && (n.ast = await xu(n.ast, o)), u.massage && (n.ast = yn(n.ast, o))), n;
}
async function kn(e, t) {
  t = await se(t);
  let u = await Ge(e, t);
  return Ce2(u, t);
}
async function vn(e, t) {
  let u = sr2(e), { formatted: r } = await Su(u, { ...t, parser: "__js_expression" });
  return r;
}
async function Rn(e, t) {
  t = await se(t);
  let { ast: u } = await Fe(e, t);
  return t.cursorOffset >= 0 && (t = { ...t, ...Bu(u, t) }), Ge(u, t);
}
async function Ln(e, t) {
  return Ce2(e, await se(t));
}
var wu = {};
Yt(wu, { builders: () => Wa, printer: () => $a, utils: () => Va });
var Wa = { join: Ie, line: ut, softline: or$1, hardline: V, literalline: Qe, group: Kt, conditionalGroup: tr, fill: er, lineSuffix: ve2, lineSuffixBoundary: ar, cursor: ee$1, breakParent: ce, ifBreak: ur, trim: ir, indent: ae, indentIfBreak: rr, align: De, addAlignmentToDoc: tt, markAsRoot: et, dedentToRoot: Qu, dedent: Zu, hardlineWithoutBreakParent: ke, literallineWithoutBreakParent: Gt$1, label: nr, concat: (e) => e }, $a = { printDocToString: Ce2 }, Va = { willBreak: Ku, traverseDoc: we, findInDoc: Xe, mapDoc: Pe, removeLines: zu, stripTrailingHardline: qe, replaceEndOfLine: Ju, canBreak: Hu };
var Mn = "3.7.4";
var Pu = {};
Yt(Pu, { addDanglingComment: () => ue, addLeadingComment: () => fe, addTrailingComment: () => le$1, getAlignmentSize: () => he$2, getIndentSize: () => Yn, getMaxContinuousCount: () => jn, getNextNonSpaceNonCommentCharacter: () => Un, getNextNonSpaceNonCommentCharacterIndex: () => ni$1, getPreferredQuote: () => Vn, getStringWidth: () => Re$1, hasNewline: () => z, hasNewlineInRange: () => Kn, hasSpaces: () => Gn, isNextLineEmpty: () => Di2, isNextLineEmptyAfterIndex: () => kt, isPreviousLineEmpty: () => ai, makeString: () => si, skip: () => ye, skipEverythingButNewLine: () => ot, skipInlineComment: () => xe, skipNewline: () => K, skipSpaces: () => Y, skipToLineEnd: () => nt, skipTrailingComment: () => Be, skipWhitespace: () => Fr2 });
function Ka(e, t) {
  if (t === false) return false;
  if (e.charAt(t) === "/" && e.charAt(t + 1) === "*") {
    for (let u = t + 2; u < e.length; ++u) if (e.charAt(u) === "*" && e.charAt(u + 1) === "/") return u + 2;
  }
  return t;
}
var xe = Ka;
function Ga(e, t) {
  return t === false ? false : e.charAt(t) === "/" && e.charAt(t + 1) === "/" ? ot(e, t) : t;
}
var Be = Ga;
function za(e, t) {
  let u = null, r = t;
  for (; r !== u; ) u = r, r = Y(e, r), r = xe(e, r), r = Be(e, r), r = K(e, r);
  return r;
}
var ze = za;
function Ja(e, t) {
  let u = null, r = t;
  for (; r !== u; ) u = r, r = nt(e, r), r = xe(e, r), r = Y(e, r);
  return r = Be(e, r), r = K(e, r), r !== false && z(e, r);
}
var kt = Ja;
function Ha(e, t) {
  let u = e.lastIndexOf(`
`);
  return u === -1 ? 0 : he$2(e.slice(u + 1).match(/^[\t ]*/u)[0], t);
}
var Yn = Ha;
function Ou(e) {
  if (typeof e != "string") throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Xa(e, t) {
  let u = e.matchAll(new RegExp(`(?:${Ou(t)})+`, "gu"));
  return u.reduce || (u = [...u]), u.reduce((r, [o]) => Math.max(r, o.length), 0) / t.length;
}
var jn = Xa;
function qa(e, t) {
  let u = ze(e, t);
  return u === false ? "" : e.charAt(u);
}
var Un = qa;
var Wn = Object.freeze({ character: "'", codePoint: 39 }), $n = Object.freeze({ character: '"', codePoint: 34 }), Qa = Object.freeze({ preferred: Wn, alternate: $n }), Za = Object.freeze({ preferred: $n, alternate: Wn });
function ei(e, t) {
  let { preferred: u, alternate: r } = t === true || t === "'" ? Qa : Za, { length: o } = e, n = 0, a = 0;
  for (let s = 0; s < o; s++) {
    let i = e.charCodeAt(s);
    i === u.codePoint ? n++ : i === r.codePoint && a++;
  }
  return (n > a ? r : u).character;
}
var Vn = ei;
function ti(e, t, u) {
  for (let r = t; r < u; ++r) if (e.charAt(r) === `
`) return true;
  return false;
}
var Kn = ti;
function ui(e, t, u = {}) {
  return Y(e, u.backwards ? t - 1 : t, u) !== t;
}
var Gn = ui;
function ri(e, t, u) {
  return ze(e, u(t));
}
function ni$1(e, t) {
  return arguments.length === 2 || typeof t == "number" ? ze(e, t) : ri(...arguments);
}
function oi(e, t, u) {
  return Le(e, u(t));
}
function ai(e, t) {
  return arguments.length === 2 || typeof t == "number" ? Le(e, t) : oi(...arguments);
}
function ii$1(e, t, u) {
  return kt(e, u(t));
}
function si(e, t, u) {
  let r = t === '"' ? "'" : '"', n = oe(0, e, /\\(.)|(["'])/gsu, (a, s, i) => s === r ? s : i === t ? "\\" + i : i || (u && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : "\\" + s));
  return t + n + t;
}
function Di2(e, t) {
  return arguments.length === 2 || typeof t == "number" ? kt(e, t) : ii$1(...arguments);
}
function me(e, t = 1) {
  return async (...u) => {
    let r = u[t] ?? {}, o = r.plugins ?? [];
    return u[t] = { ...r, plugins: Array.isArray(o) ? o : Object.values(o) }, e(...u);
  };
}
var zn = me(Su);
async function Jn(e, t) {
  let { formatted: u } = await zn(e, { ...t, cursorOffset: -1 });
  return u;
}
async function ci(e, t) {
  return await Jn(e, t) === e;
}
var fi = me(it$1, 0), li = { parse: me(In), formatAST: me(kn), formatDoc: me(vn), printToDoc: me(Rn), printDocToString: me(Ln) };
var lib$6 = {};
var lib$5 = {};
var hasRequiredLib$6;
function requireLib$6() {
  if (hasRequiredLib$6) return lib$5;
  hasRequiredLib$6 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Doctype = exports$1.CDATA = exports$1.Tag = exports$1.Style = exports$1.Script = exports$1.Comment = exports$1.Directive = exports$1.Text = exports$1.Root = exports$1.isTag = exports$1.ElementType = void 0;
    var ElementType;
    (function(ElementType2) {
      ElementType2["Root"] = "root";
      ElementType2["Text"] = "text";
      ElementType2["Directive"] = "directive";
      ElementType2["Comment"] = "comment";
      ElementType2["Script"] = "script";
      ElementType2["Style"] = "style";
      ElementType2["Tag"] = "tag";
      ElementType2["CDATA"] = "cdata";
      ElementType2["Doctype"] = "doctype";
    })(ElementType = exports$1.ElementType || (exports$1.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
    }
    exports$1.isTag = isTag;
    exports$1.Root = ElementType.Root;
    exports$1.Text = ElementType.Text;
    exports$1.Directive = ElementType.Directive;
    exports$1.Comment = ElementType.Comment;
    exports$1.Script = ElementType.Script;
    exports$1.Style = ElementType.Style;
    exports$1.Tag = ElementType.Tag;
    exports$1.CDATA = ElementType.CDATA;
    exports$1.Doctype = ElementType.Doctype;
  })(lib$5);
  return lib$5;
}
var node$1 = {};
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1) return node$1;
  hasRequiredNode$1 = 1;
  var __extends = node$1 && node$1.__extends || /* @__PURE__ */ (function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
  })();
  var __assign = node$1 && node$1.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(node$1, "__esModule", { value: true });
  node$1.cloneNode = node$1.hasChildren = node$1.isDocument = node$1.isDirective = node$1.isComment = node$1.isText = node$1.isCDATA = node$1.isTag = node$1.Element = node$1.Document = node$1.NodeWithChildren = node$1.ProcessingInstruction = node$1.Comment = node$1.Text = node$1.DataNode = node$1.Node = void 0;
  var domelementtype_1 = /* @__PURE__ */ requireLib$6();
  var nodeTypes = /* @__PURE__ */ new Map([
    [domelementtype_1.ElementType.Tag, 1],
    [domelementtype_1.ElementType.Script, 1],
    [domelementtype_1.ElementType.Style, 1],
    [domelementtype_1.ElementType.Directive, 1],
    [domelementtype_1.ElementType.Text, 3],
    [domelementtype_1.ElementType.CDATA, 4],
    [domelementtype_1.ElementType.Comment, 8],
    [domelementtype_1.ElementType.Root, 9]
  ]);
  var Node = (
    /** @class */
    (function() {
      function Node2(type) {
        this.type = type;
        this.parent = null;
        this.prev = null;
        this.next = null;
        this.startIndex = null;
        this.endIndex = null;
      }
      Object.defineProperty(Node2.prototype, "nodeType", {
        // Read-only aliases
        /**
         * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
         * node {@link type}.
         */
        get: function() {
          var _a2;
          return (_a2 = nodeTypes.get(this.type)) !== null && _a2 !== void 0 ? _a2 : 1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.parent;
        },
        set: function(parent) {
          this.parent = parent;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.prev;
        },
        set: function(prev) {
          this.prev = prev;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.next;
        },
        set: function(next) {
          this.next = next;
        },
        enumerable: false,
        configurable: true
      });
      Node2.prototype.cloneNode = function(recursive) {
        if (recursive === void 0) {
          recursive = false;
        }
        return cloneNode(this, recursive);
      };
      return Node2;
    })()
  );
  node$1.Node = Node;
  var DataNode = (
    /** @class */
    (function(_super) {
      __extends(DataNode2, _super);
      function DataNode2(type, data) {
        var _this = _super.call(this, type) || this;
        _this.data = data;
        return _this;
      }
      Object.defineProperty(DataNode2.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.data;
        },
        set: function(data) {
          this.data = data;
        },
        enumerable: false,
        configurable: true
      });
      return DataNode2;
    })(Node)
  );
  node$1.DataNode = DataNode;
  var Text2 = (
    /** @class */
    (function(_super) {
      __extends(Text3, _super);
      function Text3(data) {
        return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
      }
      return Text3;
    })(DataNode)
  );
  node$1.Text = Text2;
  var Comment = (
    /** @class */
    (function(_super) {
      __extends(Comment2, _super);
      function Comment2(data) {
        return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
      }
      return Comment2;
    })(DataNode)
  );
  node$1.Comment = Comment;
  var ProcessingInstruction = (
    /** @class */
    (function(_super) {
      __extends(ProcessingInstruction2, _super);
      function ProcessingInstruction2(name, data) {
        var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
        _this.name = name;
        return _this;
      }
      return ProcessingInstruction2;
    })(DataNode)
  );
  node$1.ProcessingInstruction = ProcessingInstruction;
  var NodeWithChildren = (
    /** @class */
    (function(_super) {
      __extends(NodeWithChildren2, _super);
      function NodeWithChildren2(type, children) {
        var _this = _super.call(this, type) || this;
        _this.children = children;
        return _this;
      }
      Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */
        get: function() {
          var _a2;
          return (_a2 = this.children[0]) !== null && _a2 !== void 0 ? _a2 : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
        /** Last child of the node. */
        get: function() {
          return this.children.length > 0 ? this.children[this.children.length - 1] : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.children;
        },
        set: function(children) {
          this.children = children;
        },
        enumerable: false,
        configurable: true
      });
      return NodeWithChildren2;
    })(Node)
  );
  node$1.NodeWithChildren = NodeWithChildren;
  var Document = (
    /** @class */
    (function(_super) {
      __extends(Document2, _super);
      function Document2(children) {
        return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
      }
      return Document2;
    })(NodeWithChildren)
  );
  node$1.Document = Document;
  var Element2 = (
    /** @class */
    (function(_super) {
      __extends(Element3, _super);
      function Element3(name, attribs, children, type) {
        if (children === void 0) {
          children = [];
        }
        if (type === void 0) {
          type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
        }
        var _this = _super.call(this, type, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        return _this;
      }
      Object.defineProperty(Element3.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.name;
        },
        set: function(name) {
          this.name = name;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element3.prototype, "attributes", {
        get: function() {
          var _this = this;
          return Object.keys(this.attribs).map(function(name) {
            var _a2, _b;
            return {
              name,
              value: _this.attribs[name],
              namespace: (_a2 = _this["x-attribsNamespace"]) === null || _a2 === void 0 ? void 0 : _a2[name],
              prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
            };
          });
        },
        enumerable: false,
        configurable: true
      });
      return Element3;
    })(NodeWithChildren)
  );
  node$1.Element = Element2;
  function isTag(node2) {
    return (0, domelementtype_1.isTag)(node2);
  }
  node$1.isTag = isTag;
  function isCDATA(node2) {
    return node2.type === domelementtype_1.ElementType.CDATA;
  }
  node$1.isCDATA = isCDATA;
  function isText(node2) {
    return node2.type === domelementtype_1.ElementType.Text;
  }
  node$1.isText = isText;
  function isComment(node2) {
    return node2.type === domelementtype_1.ElementType.Comment;
  }
  node$1.isComment = isComment;
  function isDirective(node2) {
    return node2.type === domelementtype_1.ElementType.Directive;
  }
  node$1.isDirective = isDirective;
  function isDocument(node2) {
    return node2.type === domelementtype_1.ElementType.Root;
  }
  node$1.isDocument = isDocument;
  function hasChildren(node2) {
    return Object.prototype.hasOwnProperty.call(node2, "children");
  }
  node$1.hasChildren = hasChildren;
  function cloneNode(node2, recursive) {
    if (recursive === void 0) {
      recursive = false;
    }
    var result;
    if (isText(node2)) {
      result = new Text2(node2.data);
    } else if (isComment(node2)) {
      result = new Comment(node2.data);
    } else if (isTag(node2)) {
      var children = recursive ? cloneChildren(node2.children) : [];
      var clone_1 = new Element2(node2.name, __assign({}, node2.attribs), children);
      children.forEach(function(child) {
        return child.parent = clone_1;
      });
      if (node2.namespace != null) {
        clone_1.namespace = node2.namespace;
      }
      if (node2["x-attribsNamespace"]) {
        clone_1["x-attribsNamespace"] = __assign({}, node2["x-attribsNamespace"]);
      }
      if (node2["x-attribsPrefix"]) {
        clone_1["x-attribsPrefix"] = __assign({}, node2["x-attribsPrefix"]);
      }
      result = clone_1;
    } else if (isCDATA(node2)) {
      var children = recursive ? cloneChildren(node2.children) : [];
      var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
      children.forEach(function(child) {
        return child.parent = clone_2;
      });
      result = clone_2;
    } else if (isDocument(node2)) {
      var children = recursive ? cloneChildren(node2.children) : [];
      var clone_3 = new Document(children);
      children.forEach(function(child) {
        return child.parent = clone_3;
      });
      if (node2["x-mode"]) {
        clone_3["x-mode"] = node2["x-mode"];
      }
      result = clone_3;
    } else if (isDirective(node2)) {
      var instruction = new ProcessingInstruction(node2.name, node2.data);
      if (node2["x-name"] != null) {
        instruction["x-name"] = node2["x-name"];
        instruction["x-publicId"] = node2["x-publicId"];
        instruction["x-systemId"] = node2["x-systemId"];
      }
      result = instruction;
    } else {
      throw new Error("Not implemented yet: ".concat(node2.type));
    }
    result.startIndex = node2.startIndex;
    result.endIndex = node2.endIndex;
    if (node2.sourceCodeLocation != null) {
      result.sourceCodeLocation = node2.sourceCodeLocation;
    }
    return result;
  }
  node$1.cloneNode = cloneNode;
  function cloneChildren(childs) {
    var children = childs.map(function(child) {
      return cloneNode(child, true);
    });
    for (var i = 1; i < children.length; i++) {
      children[i].prev = children[i - 1];
      children[i - 1].next = children[i];
    }
    return children;
  }
  return node$1;
}
var hasRequiredLib$5;
function requireLib$5() {
  if (hasRequiredLib$5) return lib$6;
  hasRequiredLib$5 = 1;
  (function(exports$1) {
    var __createBinding = lib$6 && lib$6.__createBinding || (Object.create ? (function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    }) : (function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    }));
    var __exportStar = lib$6 && lib$6.__exportStar || function(m, exports$12) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.DomHandler = void 0;
    var domelementtype_1 = /* @__PURE__ */ requireLib$6();
    var node_1 = /* @__PURE__ */ requireNode$1();
    __exportStar(/* @__PURE__ */ requireNode$1(), exports$1);
    var reWhitespace = /\s+/g;
    var defaultOpts = {
      normalizeWhitespace: false,
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = (
      /** @class */
      (function() {
        function DomHandler2(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler2.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function(name, attribs) {
          var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element = new node_1.Element(name, attribs, void 0, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler2.prototype.ontext = function(data) {
          var normalizeWhitespace = this.options.normalizeWhitespace;
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            if (normalizeWhitespace) {
              lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
            } else {
              lastNode.data += data;
            }
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            if (normalizeWhitespace) {
              data = data.replace(reWhitespace, " ");
            }
            var node2 = new node_1.Text(data);
            this.addNode(node2);
            this.lastNode = node2;
          }
        };
        DomHandler2.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node2 = new node_1.Comment(data);
          this.addNode(node2);
          this.lastNode = node2;
        };
        DomHandler2.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function() {
          var text = new node_1.Text("");
          var node2 = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
          this.addNode(node2);
          text.parent = node2;
          this.lastNode = text;
        };
        DomHandler2.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function(name, data) {
          var node2 = new node_1.ProcessingInstruction(name, data);
          this.addNode(node2);
        };
        DomHandler2.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler2.prototype.addNode = function(node2) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node2.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node2.endIndex = this.parser.endIndex;
          }
          parent.children.push(node2);
          if (previousSibling) {
            node2.prev = previousSibling;
            previousSibling.next = node2;
          }
          node2.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      })()
    );
    exports$1.DomHandler = DomHandler;
    exports$1.default = DomHandler;
  })(lib$6);
  return lib$6;
}
var libExports = /* @__PURE__ */ requireLib$5();
var nearley$1 = { exports: {} };
var nearley = nearley$1.exports;
var hasRequiredNearley;
function requireNearley() {
  if (hasRequiredNearley) return nearley$1.exports;
  hasRequiredNearley = 1;
  (function(module) {
    (function(root, factory) {
      if (module.exports) {
        module.exports = factory();
      } else {
        root.nearley = factory();
      }
    })(nearley, function() {
      function Rule(name, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name;
        this.symbols = symbols;
        this.postprocess = postprocess;
        return this;
      }
      Rule.highestId = 0;
      Rule.prototype.toString = function(withCursorAt) {
        var symbolSequence = typeof withCursorAt === "undefined" ? this.symbols.map(getSymbolShortDisplay).join(" ") : this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(" ") + " ● " + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(" ");
        return this.name + " → " + symbolSequence;
      };
      function State(rule, dot2, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot2;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
      }
      State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      };
      State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
          state.data = state.build();
          state.right = void 0;
        }
        return state;
      };
      State.prototype.build = function() {
        var children = [];
        var node2 = this;
        do {
          children.push(node2.right.data);
          node2 = node2.left;
        } while (node2.left);
        children.reverse();
        return children;
      };
      State.prototype.finish = function() {
        if (this.rule.postprocess) {
          this.data = this.rule.postprocess(this.data, this.reference, Parser2.fail);
        }
      };
      function Column2(grammar2, index2) {
        this.grammar = grammar2;
        this.index = index2;
        this.states = [];
        this.wants = {};
        this.scannable = [];
        this.completed = {};
      }
      Column2.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;
        for (var w2 = 0; w2 < states.length; w2++) {
          var state = states[w2];
          if (state.isComplete) {
            state.finish();
            if (state.data !== Parser2.fail) {
              var wantedBy = state.wantedBy;
              for (var i = wantedBy.length; i--; ) {
                var left = wantedBy[i];
                this.complete(left, state);
              }
              if (state.reference === this.index) {
                var exp = state.rule.name;
                (this.completed[exp] = this.completed[exp] || []).push(state);
              }
            }
          } else {
            var exp = state.rule.symbols[state.dot];
            if (typeof exp !== "string") {
              this.scannable.push(state);
              continue;
            }
            if (wants[exp]) {
              wants[exp].push(state);
              if (completed.hasOwnProperty(exp)) {
                var nulls = completed[exp];
                for (var i = 0; i < nulls.length; i++) {
                  var right = nulls[i];
                  this.complete(state, right);
                }
              }
            } else {
              wants[exp] = [state];
              this.predict(exp);
            }
          }
        }
      };
      Column2.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];
        for (var i = 0; i < rules.length; i++) {
          var r = rules[i];
          var wantedBy = this.wants[exp];
          var s = new State(r, 0, this.index, wantedBy);
          this.states.push(s);
        }
      };
      Column2.prototype.complete = function(left, right) {
        var copy2 = left.nextState(right);
        this.states.push(copy2);
      };
      function Grammar(rules, start) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
          if (!byName.hasOwnProperty(rule.name)) {
            byName[rule.name] = [];
          }
          byName[rule.name].push(rule);
        });
      }
      Grammar.fromCompiled = function(rules, start) {
        var lexer2 = rules.Lexer;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function(r) {
          return new Rule(r.name, r.symbols, r.postprocess);
        });
        var g = new Grammar(rules, start);
        g.lexer = lexer2;
        return g;
      };
      function StreamLexer() {
        this.reset("");
      }
      StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
      };
      StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var ch = this.buffer[this.index++];
          if (ch === "\n") {
            this.line += 1;
            this.lastLineBreak = this.index;
          }
          return { value: ch };
        }
      };
      StreamLexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      };
      StreamLexer.prototype.formatError = function(token, message2) {
        var buffer = this.buffer;
        if (typeof buffer === "string") {
          var lines = buffer.split("\n").slice(
            Math.max(0, this.line - 5),
            this.line
          );
          var nextLineBreak = buffer.indexOf("\n", this.index);
          if (nextLineBreak === -1) nextLineBreak = buffer.length;
          var col = this.index - this.lastLineBreak;
          var lastLineDigits = String(this.line).length;
          message2 += " at line " + this.line + " col " + col + ":\n\n";
          message2 += lines.map(function(line, i) {
            return pad(this.line - lines.length + i + 1, lastLineDigits) + " " + line;
          }, this).join("\n");
          message2 += "\n" + pad("", lastLineDigits + col) + "^\n";
          return message2;
        } else {
          return message2 + " at index " + (this.index - 1);
        }
        function pad(n, length) {
          var s = String(n);
          return Array(length - s.length + 1).join(" ") + s;
        }
      };
      function Parser2(rules, start, options) {
        if (rules instanceof Grammar) {
          var grammar2 = rules;
          var options = start;
        } else {
          var grammar2 = Grammar.fromCompiled(rules, start);
        }
        this.grammar = grammar2;
        this.options = {
          keepHistory: false,
          lexer: grammar2.lexer || new StreamLexer()
        };
        for (var key in options || {}) {
          this.options[key] = options[key];
        }
        this.lexer = this.options.lexer;
        this.lexerState = void 0;
        var column = new Column2(grammar2, 0);
        this.table = [column];
        column.wants[grammar2.start] = [];
        column.predict(grammar2.start);
        column.process();
        this.current = 0;
      }
      Parser2.fail = {};
      Parser2.prototype.feed = function(chunk) {
        var lexer2 = this.lexer;
        lexer2.reset(chunk, this.lexerState);
        var token;
        while (true) {
          try {
            token = lexer2.next();
            if (!token) {
              break;
            }
          } catch (e) {
            var nextColumn = new Column2(this.grammar, this.current + 1);
            this.table.push(nextColumn);
            var err = new Error(this.reportLexerError(e));
            err.offset = this.current;
            err.token = e.token;
            throw err;
          }
          var column = this.table[this.current];
          if (!this.options.keepHistory) {
            delete this.table[this.current - 1];
          }
          var n = this.current + 1;
          var nextColumn = new Column2(this.grammar, n);
          this.table.push(nextColumn);
          var literal = token.text !== void 0 ? token.text : token.value;
          var value = lexer2.constructor === StreamLexer ? token.value : token;
          var scannable = column.scannable;
          for (var w2 = scannable.length; w2--; ) {
            var state = scannable[w2];
            var expect = state.rule.symbols[state.dot];
            if (expect.test ? expect.test(value) : expect.type ? expect.type === token.type : expect.literal === literal) {
              var next = state.nextState({ data: value, token, isToken: true, reference: n - 1 });
              nextColumn.states.push(next);
            }
          }
          nextColumn.process();
          if (nextColumn.states.length === 0) {
            var err = new Error(this.reportError(token));
            err.offset = this.current;
            err.token = token;
            throw err;
          }
          if (this.options.keepHistory) {
            column.lexerState = lexer2.save();
          }
          this.current++;
        }
        if (column) {
          this.lexerState = lexer2.save();
        }
        this.results = this.finish();
        return this;
      };
      Parser2.prototype.reportLexerError = function(lexerError) {
        var tokenDisplay, lexerMessage;
        var token = lexerError.token;
        if (token) {
          tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
          lexerMessage = this.lexer.formatError(token, "Syntax error");
        } else {
          tokenDisplay = "input (lexer error)";
          lexerMessage = lexerError.message;
        }
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser2.prototype.reportError = function(token) {
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== void 0 ? token.value : token);
        var lexerMessage = this.lexer.formatError(token, "Syntax error");
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser2.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
        var lines = [];
        lines.push(lexerMessage);
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states.filter(function(state) {
          var nextSymbol = state.rule.symbols[state.dot];
          return nextSymbol && typeof nextSymbol !== "string";
        });
        if (expectantStates.length === 0) {
          lines.push("Unexpected " + tokenDisplay + ". I did not expect any more input. Here is the state of my parse table:\n");
          this.displayStateStack(lastColumn.states, lines);
        } else {
          lines.push("Unexpected " + tokenDisplay + ". Instead, I was expecting to see one of the following:\n");
          var stateStacks = expectantStates.map(function(state) {
            return this.buildFirstStateStack(state, []) || [state];
          }, this);
          stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push("A " + symbolDisplay + " based on:");
            this.displayStateStack(stateStack, lines);
          }, this);
        }
        lines.push("");
        return lines.join("\n");
      };
      Parser2.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j2 = 0; j2 < stateStack.length; j2++) {
          var state = stateStack[j2];
          var display = state.rule.toString(state.dot);
          if (display === lastDisplay) {
            sameDisplayCount++;
          } else {
            if (sameDisplayCount > 0) {
              lines.push("    ^ " + sameDisplayCount + " more lines identical to this");
            }
            sameDisplayCount = 0;
            lines.push("    " + display);
          }
          lastDisplay = display;
        }
      };
      Parser2.prototype.getSymbolDisplay = function(symbol) {
        return getSymbolLongDisplay(symbol);
      };
      Parser2.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
          return null;
        }
        if (state.wantedBy.length === 0) {
          return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
          return null;
        }
        return [state].concat(childResult);
      };
      Parser2.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
      };
      Parser2.prototype.restore = function(column) {
        var index2 = column.index;
        this.current = index2;
        this.table[index2] = column;
        this.table.splice(index2 + 1);
        this.lexerState = column.lexerState;
        this.results = this.finish();
      };
      Parser2.prototype.rewind = function(index2) {
        if (!this.options.keepHistory) {
          throw new Error("set option `keepHistory` to enable rewinding");
        }
        this.restore(this.table[index2]);
      };
      Parser2.prototype.finish = function() {
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1];
        column.states.forEach(function(t) {
          if (t.rule.name === start && t.dot === t.rule.symbols.length && t.reference === 0 && t.data !== Parser2.fail) {
            considerations.push(t);
          }
        });
        return considerations.map(function(c) {
          return c.data;
        });
      };
      function getSymbolLongDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return "character matching " + symbol;
          } else if (symbol.type) {
            return symbol.type + " token";
          } else if (symbol.test) {
            return "token matching " + String(symbol.test);
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      function getSymbolShortDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return symbol.toString();
          } else if (symbol.type) {
            return "%" + symbol.type;
          } else if (symbol.test) {
            return "<" + String(symbol.test) + ">";
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      return {
        Parser: Parser2,
        Grammar,
        Rule
      };
    });
  })(nearley$1);
  return nearley$1.exports;
}
var nearleyExports = requireNearley();
var moo$1 = { exports: {} };
var moo = moo$1.exports;
var hasRequiredMoo;
function requireMoo() {
  if (hasRequiredMoo) return moo$1.exports;
  hasRequiredMoo = 1;
  (function(module) {
    (function(root, factory) {
      if (module.exports) {
        module.exports = factory();
      } else {
        root.moo = factory();
      }
    })(moo, function() {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var toString = Object.prototype.toString;
      var hasSticky = typeof new RegExp().sticky === "boolean";
      function isRegExp(o) {
        return o && toString.call(o) === "[object RegExp]";
      }
      function isObject(o) {
        return o && typeof o === "object" && !isRegExp(o) && !Array.isArray(o);
      }
      function reEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function reGroups(s) {
        var re2 = new RegExp("|" + s);
        return re2.exec("").length - 1;
      }
      function reCapture(s) {
        return "(" + s + ")";
      }
      function reUnion(regexps) {
        if (!regexps.length) return "(?!)";
        var source = regexps.map(function(s) {
          return "(?:" + s + ")";
        }).join("|");
        return "(?:" + source + ")";
      }
      function regexpOrLiteral(obj) {
        if (typeof obj === "string") {
          return "(?:" + reEscape(obj) + ")";
        } else if (isRegExp(obj)) {
          if (obj.ignoreCase) throw new Error("RegExp /i flag not allowed");
          if (obj.global) throw new Error("RegExp /g flag is implied");
          if (obj.sticky) throw new Error("RegExp /y flag is implied");
          if (obj.multiline) throw new Error("RegExp /m flag is implied");
          return obj.source;
        } else {
          throw new Error("Not a pattern: " + obj);
        }
      }
      function pad(s, length) {
        if (s.length > length) {
          return s;
        }
        return Array(length - s.length + 1).join(" ") + s;
      }
      function lastNLines(string, numLines) {
        var position = string.length;
        var lineBreaks = 0;
        while (true) {
          var idx = string.lastIndexOf("\n", position - 1);
          if (idx === -1) {
            break;
          } else {
            lineBreaks++;
          }
          position = idx;
          if (lineBreaks === numLines) {
            break;
          }
          if (position === 0) {
            break;
          }
        }
        var startPosition = lineBreaks < numLines ? 0 : position + 1;
        return string.substring(startPosition).split("\n");
      }
      function objectToRules(object) {
        var keys = Object.getOwnPropertyNames(object);
        var result = [];
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var thing = object[key];
          var rules = [].concat(thing);
          if (key === "include") {
            for (var j2 = 0; j2 < rules.length; j2++) {
              result.push({ include: rules[j2] });
            }
            continue;
          }
          var match = [];
          rules.forEach(function(rule) {
            if (isObject(rule)) {
              if (match.length) result.push(ruleOptions(key, match));
              result.push(ruleOptions(key, rule));
              match = [];
            } else {
              match.push(rule);
            }
          });
          if (match.length) result.push(ruleOptions(key, match));
        }
        return result;
      }
      function arrayToRules(array) {
        var result = [];
        for (var i = 0; i < array.length; i++) {
          var obj = array[i];
          if (obj.include) {
            var include = [].concat(obj.include);
            for (var j2 = 0; j2 < include.length; j2++) {
              result.push({ include: include[j2] });
            }
            continue;
          }
          if (!obj.type) {
            throw new Error("Rule has no type: " + JSON.stringify(obj));
          }
          result.push(ruleOptions(obj.type, obj));
        }
        return result;
      }
      function ruleOptions(type, obj) {
        if (!isObject(obj)) {
          obj = { match: obj };
        }
        if (obj.include) {
          throw new Error("Matching rules cannot also include states");
        }
        var options = {
          defaultType: type,
          lineBreaks: !!obj.error || !!obj.fallback,
          pop: false,
          next: null,
          push: null,
          error: false,
          fallback: false,
          value: null,
          type: null,
          shouldThrow: false
        };
        for (var key in obj) {
          if (hasOwnProperty.call(obj, key)) {
            options[key] = obj[key];
          }
        }
        if (typeof options.type === "string" && type !== options.type) {
          throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type + "')");
        }
        var match = options.match;
        options.match = Array.isArray(match) ? match : match ? [match] : [];
        options.match.sort(function(a, b2) {
          return isRegExp(a) && isRegExp(b2) ? 0 : isRegExp(b2) ? -1 : isRegExp(a) ? 1 : b2.length - a.length;
        });
        return options;
      }
      function toRules(spec) {
        return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
      }
      var defaultErrorRule = ruleOptions("error", { lineBreaks: true, shouldThrow: true });
      function compileRules(rules, hasStates) {
        var errorRule = null;
        var fast = /* @__PURE__ */ Object.create(null);
        var fastAllowed = true;
        var unicodeFlag = null;
        var groups = [];
        var parts = [];
        for (var i = 0; i < rules.length; i++) {
          if (rules[i].fallback) {
            fastAllowed = false;
          }
        }
        for (var i = 0; i < rules.length; i++) {
          var options = rules[i];
          if (options.include) {
            throw new Error("Inheritance is not allowed in stateless lexers");
          }
          if (options.error || options.fallback) {
            if (errorRule) {
              if (!options.fallback === !errorRule.fallback) {
                throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')");
              } else {
                throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')");
              }
            }
            errorRule = options;
          }
          var match = options.match.slice();
          if (fastAllowed) {
            while (match.length && typeof match[0] === "string" && match[0].length === 1) {
              var word = match.shift();
              fast[word.charCodeAt(0)] = options;
            }
          }
          if (options.pop || options.push || options.next) {
            if (!hasStates) {
              throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')");
            }
            if (options.fallback) {
              throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')");
            }
          }
          if (match.length === 0) {
            continue;
          }
          fastAllowed = false;
          groups.push(options);
          for (var j2 = 0; j2 < match.length; j2++) {
            var obj = match[j2];
            if (!isRegExp(obj)) {
              continue;
            }
            if (unicodeFlag === null) {
              unicodeFlag = obj.unicode;
            } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
              throw new Error("If one rule is /u then all must be");
            }
          }
          var pat = reUnion(match.map(regexpOrLiteral));
          var regexp = new RegExp(pat);
          if (regexp.test("")) {
            throw new Error("RegExp matches empty string: " + regexp);
          }
          var groupCount = reGroups(pat);
          if (groupCount > 0) {
            throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: … ) instead");
          }
          if (!options.lineBreaks && regexp.test("\n")) {
            throw new Error("Rule should declare lineBreaks: " + regexp);
          }
          parts.push(reCapture(pat));
        }
        var fallbackRule = errorRule && errorRule.fallback;
        var flags = hasSticky && !fallbackRule ? "ym" : "gm";
        var suffix = hasSticky || fallbackRule ? "" : "|";
        if (unicodeFlag === true) flags += "u";
        var combined = new RegExp(reUnion(parts) + suffix, flags);
        return { regexp: combined, groups, fast, error: errorRule || defaultErrorRule };
      }
      function compile(rules) {
        var result = compileRules(toRules(rules));
        return new Lexer({ start: result }, "start");
      }
      function checkStateGroup(g, name, map2) {
        var state = g && (g.push || g.next);
        if (state && !map2[state]) {
          throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name + "')");
        }
        if (g && g.pop && +g.pop !== 1) {
          throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name + "')");
        }
      }
      function compileStates(states, start) {
        var all = states.$all ? toRules(states.$all) : [];
        delete states.$all;
        var keys = Object.getOwnPropertyNames(states);
        if (!start) start = keys[0];
        var ruleMap = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          ruleMap[key] = toRules(states[key]).concat(all);
        }
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var rules = ruleMap[key];
          var included = /* @__PURE__ */ Object.create(null);
          for (var j2 = 0; j2 < rules.length; j2++) {
            var rule = rules[j2];
            if (!rule.include) continue;
            var splice = [j2, 1];
            if (rule.include !== key && !included[rule.include]) {
              included[rule.include] = true;
              var newRules = ruleMap[rule.include];
              if (!newRules) {
                throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key + "')");
              }
              for (var k2 = 0; k2 < newRules.length; k2++) {
                var newRule = newRules[k2];
                if (rules.indexOf(newRule) !== -1) continue;
                splice.push(newRule);
              }
            }
            rules.splice.apply(rules, splice);
            j2--;
          }
        }
        var map2 = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          map2[key] = compileRules(ruleMap[key], true);
        }
        for (var i = 0; i < keys.length; i++) {
          var name = keys[i];
          var state = map2[name];
          var groups = state.groups;
          for (var j2 = 0; j2 < groups.length; j2++) {
            checkStateGroup(groups[j2], name, map2);
          }
          var fastKeys = Object.getOwnPropertyNames(state.fast);
          for (var j2 = 0; j2 < fastKeys.length; j2++) {
            checkStateGroup(state.fast[fastKeys[j2]], name, map2);
          }
        }
        return new Lexer(map2, start);
      }
      function keywordTransform(map2) {
        var isMap = typeof Map !== "undefined";
        var reverseMap = isMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
        var types = Object.getOwnPropertyNames(map2);
        for (var i = 0; i < types.length; i++) {
          var tokenType = types[i];
          var item = map2[tokenType];
          var keywordList = Array.isArray(item) ? item : [item];
          keywordList.forEach(function(keyword) {
            if (typeof keyword !== "string") {
              throw new Error("keyword must be string (in keyword '" + tokenType + "')");
            }
            if (isMap) {
              reverseMap.set(keyword, tokenType);
            } else {
              reverseMap[keyword] = tokenType;
            }
          });
        }
        return function(k2) {
          return isMap ? reverseMap.get(k2) : reverseMap[k2];
        };
      }
      var Lexer = function(states, state) {
        this.startState = state;
        this.states = states;
        this.buffer = "";
        this.stack = [];
        this.reset();
      };
      Lexer.prototype.reset = function(data, info) {
        this.buffer = data || "";
        this.index = 0;
        this.line = info ? info.line : 1;
        this.col = info ? info.col : 1;
        this.queuedToken = info ? info.queuedToken : null;
        this.queuedText = info ? info.queuedText : "";
        this.queuedThrow = info ? info.queuedThrow : null;
        this.setState(info ? info.state : this.startState);
        this.stack = info && info.stack ? info.stack.slice() : [];
        return this;
      };
      Lexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.col,
          state: this.state,
          stack: this.stack.slice(),
          queuedToken: this.queuedToken,
          queuedText: this.queuedText,
          queuedThrow: this.queuedThrow
        };
      };
      Lexer.prototype.setState = function(state) {
        if (!state || this.state === state) return;
        this.state = state;
        var info = this.states[state];
        this.groups = info.groups;
        this.error = info.error;
        this.re = info.regexp;
        this.fast = info.fast;
      };
      Lexer.prototype.popState = function() {
        this.setState(this.stack.pop());
      };
      Lexer.prototype.pushState = function(state) {
        this.stack.push(this.state);
        this.setState(state);
      };
      var eat = hasSticky ? function(re2, buffer) {
        return re2.exec(buffer);
      } : function(re2, buffer) {
        var match = re2.exec(buffer);
        if (match[0].length === 0) {
          return null;
        }
        return match;
      };
      Lexer.prototype._getGroup = function(match) {
        var groupCount = this.groups.length;
        for (var i = 0; i < groupCount; i++) {
          if (match[i + 1] !== void 0) {
            return this.groups[i];
          }
        }
        throw new Error("Cannot find token type for matched text");
      };
      function tokenToString() {
        return this.value;
      }
      Lexer.prototype.next = function() {
        var index2 = this.index;
        if (this.queuedGroup) {
          var token = this._token(this.queuedGroup, this.queuedText, index2);
          this.queuedGroup = null;
          this.queuedText = "";
          return token;
        }
        var buffer = this.buffer;
        if (index2 === buffer.length) {
          return;
        }
        var group = this.fast[buffer.charCodeAt(index2)];
        if (group) {
          return this._token(group, buffer.charAt(index2), index2);
        }
        var re2 = this.re;
        re2.lastIndex = index2;
        var match = eat(re2, buffer);
        var error = this.error;
        if (match == null) {
          return this._token(error, buffer.slice(index2, buffer.length), index2);
        }
        var group = this._getGroup(match);
        var text = match[0];
        if (error.fallback && match.index !== index2) {
          this.queuedGroup = group;
          this.queuedText = text;
          return this._token(error, buffer.slice(index2, match.index), index2);
        }
        return this._token(group, text, index2);
      };
      Lexer.prototype._token = function(group, text, offset) {
        var lineBreaks = 0;
        if (group.lineBreaks) {
          var matchNL = /\n/g;
          var nl2 = 1;
          if (text === "\n") {
            lineBreaks = 1;
          } else {
            while (matchNL.exec(text)) {
              lineBreaks++;
              nl2 = matchNL.lastIndex;
            }
          }
        }
        var token = {
          type: typeof group.type === "function" && group.type(text) || group.defaultType,
          value: typeof group.value === "function" ? group.value(text) : text,
          text,
          toString: tokenToString,
          offset,
          lineBreaks,
          line: this.line,
          col: this.col
        };
        var size = text.length;
        this.index += size;
        this.line += lineBreaks;
        if (lineBreaks !== 0) {
          this.col = size - nl2 + 1;
        } else {
          this.col += size;
        }
        if (group.shouldThrow) {
          var err = new Error(this.formatError(token, "invalid syntax"));
          throw err;
        }
        if (group.pop) this.popState();
        else if (group.push) this.pushState(group.push);
        else if (group.next) this.setState(group.next);
        return token;
      };
      if (typeof Symbol !== "undefined" && Symbol.iterator) {
        var LexerIterator = function(lexer2) {
          this.lexer = lexer2;
        };
        LexerIterator.prototype.next = function() {
          var token = this.lexer.next();
          return { value: token, done: !token };
        };
        LexerIterator.prototype[Symbol.iterator] = function() {
          return this;
        };
        Lexer.prototype[Symbol.iterator] = function() {
          return new LexerIterator(this);
        };
      }
      Lexer.prototype.formatError = function(token, message2) {
        if (token == null) {
          var text = this.buffer.slice(this.index);
          var token = {
            text,
            offset: this.index,
            lineBreaks: text.indexOf("\n") === -1 ? 0 : 1,
            line: this.line,
            col: this.col
          };
        }
        var numLinesAround = 2;
        var firstDisplayedLine = Math.max(token.line - numLinesAround, 1);
        var lastDisplayedLine = token.line + numLinesAround;
        var lastLineDigits = String(lastDisplayedLine).length;
        var displayedLines = lastNLines(
          this.buffer,
          this.line - token.line + numLinesAround + 1
        ).slice(0, 5);
        var errorLines = [];
        errorLines.push(message2 + " at line " + token.line + " col " + token.col + ":");
        errorLines.push("");
        for (var i = 0; i < displayedLines.length; i++) {
          var line = displayedLines[i];
          var lineNo = firstDisplayedLine + i;
          errorLines.push(pad(String(lineNo), lastLineDigits) + "  " + line);
          if (lineNo === token.line) {
            errorLines.push(pad("", lastLineDigits + token.col + 1) + "^");
          }
        }
        return errorLines.join("\n");
      };
      Lexer.prototype.clone = function() {
        return new Lexer(this.states, this.state);
      };
      Lexer.prototype.has = function(tokenType) {
        return true;
      };
      return {
        compile,
        states: compileStates,
        error: Object.freeze({ error: true }),
        fallback: Object.freeze({ fallback: true }),
        keywords: keywordTransform
      };
    });
  })(moo$1);
  return moo$1.exports;
}
var mooExports = requireMoo();
function id(d) {
  return d[0];
}
const lexer = mooExports.compile({
  ws: { match: /[ \t\r\n\f]+/, lineBreaks: true },
  idn: { match: /[a-zA-Z_-][a-zA-Z0-9_-]*/ },
  hashToken: { match: /#[a-zA-Z0-9_-]+/, value: (s) => s.slice(1) },
  str1: { match: /'(?:\\['\\]|[^\n'\\])*'/, value: (s) => s.slice(1, -1) },
  str2: { match: /"(?:\\["\\]|[^\n"\\])*"/, value: (s) => s.slice(1, -1) },
  asterisk: "*",
  fullstop: ".",
  comma: ",",
  lbr: "[",
  rbr: "]",
  eq: "=",
  gt: ">",
  vbar: "|",
  plus: "+",
  tilde: "~",
  caret: "^",
  dollar: "$"
  //colon:      ':',
  //lpar:       '(',
  //rpar:       ')',
});
function firstTokenValue(tokens) {
  return tokens[0].value;
}
function second(tokens) {
  return tokens[1];
}
function sumSpec([a0, a1, a2], [b0, b1, b2]) {
  return [a0 + b0, a1 + b1, a2 + b2];
}
const grammar = {
  Lexer: lexer,
  ParserRules: [
    { "name": "main", "symbols": ["_", "listSelector", "_"], "postprocess": second },
    { "name": "mainNoList", "symbols": ["_", "complexSelector", "_"], "postprocess": second },
    { "name": "listSelector", "symbols": ["complexSelector"], "postprocess": ([next]) => ({ type: "list", list: [next] }) },
    { "name": "listSelector", "symbols": ["listSelector", "_", lexer.has("comma") ? { type: "comma" } : comma, "_", "complexSelector"], "postprocess": ([acc, , , , next]) => ({ type: "list", list: [...acc.list, next] }) },
    { "name": "complexSelector", "symbols": ["compoundSelector"], "postprocess": id },
    { "name": "complexSelector", "symbols": ["complexSelector", "__", "compoundSelector"], "postprocess": ([left, , right]) => ({
      type: "compound",
      list: [...right.list, { type: "combinator", combinator: " ", left, specificity: left.specificity }],
      specificity: sumSpec(left.specificity, right.specificity)
    }) },
    { "name": "complexSelector", "symbols": ["complexSelector", "_", "combinator", "_", "compoundSelector"], "postprocess": ([left, , c, , right]) => ({
      type: "compound",
      list: [...right.list, { type: "combinator", combinator: c, left, specificity: left.specificity }],
      specificity: sumSpec(left.specificity, right.specificity)
    }) },
    { "name": "combinator", "symbols": [lexer.has("gt") ? { type: "gt" } : gt], "postprocess": () => ">" },
    { "name": "combinator", "symbols": [lexer.has("plus") ? { type: "plus" } : plus], "postprocess": () => "+" },
    { "name": "combinator", "symbols": [lexer.has("tilde") ? { type: "tilde" } : tilde], "postprocess": () => "~" },
    { "name": "combinator", "symbols": [lexer.has("vbar") ? { type: "vbar" } : vbar, lexer.has("vbar") ? { type: "vbar" } : vbar], "postprocess": () => "||" },
    { "name": "compoundSelector", "symbols": ["typeSelector"], "postprocess": ([next]) => ({
      type: "compound",
      list: [next],
      specificity: next.specificity
    }) },
    { "name": "compoundSelector", "symbols": ["subclassSelector"], "postprocess": ([next]) => ({
      type: "compound",
      list: [next],
      specificity: next.specificity
    }) },
    { "name": "compoundSelector", "symbols": ["compoundSelector", "subclassSelector"], "postprocess": ([acc, next]) => ({
      type: "compound",
      list: [...acc.list, next],
      specificity: sumSpec(acc.specificity, next.specificity)
    }) },
    { "name": "subclassSelector", "symbols": ["idSelector"], "postprocess": id },
    { "name": "subclassSelector", "symbols": ["classSelector"], "postprocess": id },
    { "name": "subclassSelector", "symbols": ["attrSelector"], "postprocess": id },
    { "name": "attrSelector", "symbols": ["attrPresenceSelector"], "postprocess": id },
    { "name": "attrSelector", "symbols": ["attrValueSelector"], "postprocess": id },
    { "name": "typeSelector", "symbols": ["tagSelector"], "postprocess": id },
    { "name": "typeSelector", "symbols": ["uniSelector"], "postprocess": id },
    {
      "name": "attrPresenceSelector",
      "symbols": [lexer.has("lbr") ? { type: "lbr" } : lbr, "_", "wqname", "_", lexer.has("rbr") ? { type: "rbr" } : rbr],
      "postprocess": ([, , wqname]) => ({
        type: "attrPresence",
        name: wqname.name,
        namespace: wqname.namespace,
        specificity: [0, 1, 0]
      })
    },
    {
      "name": "attrValueSelector",
      "symbols": [lexer.has("lbr") ? { type: "lbr" } : lbr, "_", "wqname", "_", "attrMatcher", "_", "attrValue", "_", lexer.has("rbr") ? { type: "rbr" } : rbr],
      "postprocess": ([, , wqname, , matcher, , v2]) => ({
        type: "attrValue",
        name: wqname.name,
        namespace: wqname.namespace,
        matcher,
        value: v2.value,
        modifier: v2.modifier,
        specificity: [0, 1, 0]
      })
    },
    { "name": "attrMatcher", "symbols": [lexer.has("eq") ? { type: "eq" } : eq], "postprocess": () => "=" },
    { "name": "attrMatcher", "symbols": [lexer.has("tilde") ? { type: "tilde" } : tilde, lexer.has("eq") ? { type: "eq" } : eq], "postprocess": () => "~=" },
    { "name": "attrMatcher", "symbols": [lexer.has("vbar") ? { type: "vbar" } : vbar, lexer.has("eq") ? { type: "eq" } : eq], "postprocess": () => "|=" },
    { "name": "attrMatcher", "symbols": [lexer.has("caret") ? { type: "caret" } : caret, lexer.has("eq") ? { type: "eq" } : eq], "postprocess": () => "^=" },
    { "name": "attrMatcher", "symbols": [lexer.has("dollar") ? { type: "dollar" } : dollar, lexer.has("eq") ? { type: "eq" } : eq], "postprocess": () => "$=" },
    { "name": "attrMatcher", "symbols": [lexer.has("asterisk") ? { type: "asterisk" } : asterisk, lexer.has("eq") ? { type: "eq" } : eq], "postprocess": () => "*=" },
    { "name": "attrValue", "symbols": ["str"], "postprocess": ([v2]) => ({ value: v2, modifier: null }) },
    { "name": "attrValue", "symbols": ["idn"], "postprocess": ([v2]) => ({ value: v2, modifier: null }) },
    { "name": "attrValue", "symbols": ["str", "_", "attrModifier"], "postprocess": ([v2, , mod]) => ({ value: v2, modifier: mod }) },
    { "name": "attrValue", "symbols": ["idn", "__", "attrModifier"], "postprocess": ([v2, , mod]) => ({ value: v2, modifier: mod }) },
    { "name": "attrModifier", "symbols": [{ "literal": "i" }], "postprocess": () => "i" },
    { "name": "attrModifier", "symbols": [{ "literal": "I" }], "postprocess": () => "i" },
    { "name": "attrModifier", "symbols": [{ "literal": "s" }], "postprocess": () => "s" },
    { "name": "attrModifier", "symbols": [{ "literal": "S" }], "postprocess": () => "s" },
    { "name": "idSelector", "symbols": [lexer.has("hashToken") ? { type: "hashToken" } : hashToken], "postprocess": ([{ value: name }]) => ({ type: "id", name, specificity: [1, 0, 0] }) },
    { "name": "classSelector", "symbols": [lexer.has("fullstop") ? { type: "fullstop" } : fullstop, "idn"], "postprocess": ([, name]) => ({ type: "class", name, specificity: [0, 1, 0] }) },
    {
      "name": "tagSelector",
      "symbols": ["wqname"],
      "postprocess": ([wqname]) => ({
        type: "tag",
        name: wqname.name,
        namespace: wqname.namespace,
        specificity: [0, 0, 1]
      })
    },
    { "name": "uniSelector", "symbols": [lexer.has("asterisk") ? { type: "asterisk" } : asterisk], "postprocess": () => ({ type: "universal", namespace: null, specificity: [0, 0, 0] }) },
    { "name": "uniSelector", "symbols": ["ns", lexer.has("asterisk") ? { type: "asterisk" } : asterisk], "postprocess": ([ns2]) => ({ type: "universal", namespace: ns2, specificity: [0, 0, 0] }) },
    { "name": "wqname", "symbols": ["idn"], "postprocess": ([name]) => ({ name, namespace: null }) },
    { "name": "wqname", "symbols": ["ns", "idn"], "postprocess": ([ns2, name]) => ({ name, namespace: ns2 }) },
    { "name": "ns", "symbols": [lexer.has("vbar") ? { type: "vbar" } : vbar], "postprocess": () => "" },
    { "name": "ns", "symbols": ["idn", lexer.has("vbar") ? { type: "vbar" } : vbar], "postprocess": id },
    { "name": "str", "symbols": [lexer.has("str1") ? { type: "str1" } : str1], "postprocess": firstTokenValue },
    { "name": "str", "symbols": [lexer.has("str2") ? { type: "str2" } : str2], "postprocess": firstTokenValue },
    { "name": "idn", "symbols": [lexer.has("idn") ? { type: "idn" } : idn], "postprocess": firstTokenValue },
    { "name": "_$ebnf$1", "symbols": [lexer.has("ws") ? { type: "ws" } : ws], "postprocess": id },
    { "name": "_$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": () => null },
    { "name": "__", "symbols": [lexer.has("ws") ? { type: "ws" } : ws], "postprocess": () => null }
  ],
  ParserStart: "main"
};
const compiledRulesNoList = { ...grammar, ParserStart: "mainNoList" };
function parse1(str) {
  return _parse(compiledRulesNoList, str);
}
function _parse(compiledRules1, str) {
  const parser = new nearleyExports.Parser(nearleyExports.Grammar.fromCompiled(compiledRules1));
  parser.feed(str);
  if (parser.results.length === 0) {
    throw new Error("Failed to parse - input string might be incomplete.");
  }
  return parser.results[0];
}
function serialize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "universal":
      return _serNs(selector.namespace) + "*";
    case "tag":
      return _serNs(selector.namespace) + selector.name;
    case "class":
      return "." + selector.name;
    case "id":
      return "#" + selector.name;
    case "attrPresence":
      return `[${_serNs(selector.namespace)}${selector.name}]`;
    case "attrValue":
      return `[${_serNs(selector.namespace)}${selector.name}${selector.matcher}${_serStr(selector.value)}${selector.modifier ? selector.modifier : ""}]`;
    case "combinator":
      return serialize(selector.left) + selector.combinator;
    case "compound":
      return selector.list.reduce((acc, node2) => {
        if (node2.type === "combinator") {
          return serialize(node2) + acc;
        } else {
          return acc + serialize(node2);
        }
      }, "");
    case "list":
      return selector.list.map(serialize).join(",");
  }
}
function _serNs(ns2) {
  return ns2 || ns2 === "" ? ns2 + "|" : "";
}
function _serStr(str) {
  if (str.indexOf('"') === -1) {
    return `"${str}"`;
  } else if (str.indexOf("'") === -1) {
    return `'${str}'`;
  } else {
    return `"${str.replace('"', '\\"')}"`;
  }
}
function normalize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "compound": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b2) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b2)));
      break;
    }
    case "combinator": {
      normalize(selector.left);
      break;
    }
    case "list": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b2) => serialize(a) < serialize(b2) ? -1 : 1);
      break;
    }
  }
  return selector;
}
function _getSelectorPriority(selector) {
  switch (selector.type) {
    case "universal":
      return [1];
    case "tag":
      return [1];
    case "id":
      return [2];
    case "class":
      return [3, selector.name];
    case "attrPresence":
      return [4, serialize(selector)];
    case "attrValue":
      return [5, serialize(selector)];
    case "combinator":
      return [15, serialize(selector)];
  }
}
function compareSpecificity(a, b2) {
  return _compareArrays(a, b2);
}
function _compareArrays(a, b2) {
  if (!Array.isArray(a) || !Array.isArray(b2)) {
    throw new Error("Arguments must be arrays.");
  }
  const shorter = a.length < b2.length ? a.length : b2.length;
  for (let i = 0; i < shorter; i++) {
    if (a[i] === b2[i]) {
      continue;
    }
    return a[i] < b2[i] ? -1 : 1;
  }
  return a.length - b2.length;
}
var Ast = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
var Types = /* @__PURE__ */ Object.freeze({
  __proto__: null
});
const treeify = (nodes) => "▽\n" + treeifyArray(nodes, thinLines);
const thinLines = [["├─", "│ "], ["└─", "  "]];
const heavyLines = [["┠─", "┃ "], ["┖─", "  "]];
const doubleLines = [["╟─", "║ "], ["╙─", "  "]];
function treeifyArray(nodes, tpl = heavyLines) {
  return prefixItems(tpl, nodes.map((n) => treeifyNode(n)));
}
function treeifyNode(node2) {
  switch (node2.type) {
    case "terminal": {
      const vctr = node2.valueContainer;
      return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;
    }
    case "tagName":
      return `◻ Tag name
${treeifyArray(node2.variants, doubleLines)}`;
    case "attrValue":
      return `▣ Attr value: ${node2.name}
${treeifyArray(node2.matchers, doubleLines)}`;
    case "attrPresence":
      return `◨ Attr presence: ${node2.name}
${treeifyArray(node2.cont)}`;
    case "pushElement":
      return `◉ Push element: ${node2.combinator}
${treeifyArray(node2.cont, thinLines)}`;
    case "popElement":
      return `◌ Pop element
${treeifyArray(node2.cont, thinLines)}`;
    case "variant":
      return `◇ = ${node2.value}
${treeifyArray(node2.cont)}`;
    case "matcher":
      return `◈ ${node2.matcher} "${node2.value}"${node2.modifier || ""}
${treeifyArray(node2.cont)}`;
  }
}
function prefixItems(tpl, items) {
  return items.map((item, i, { length }) => prefixItem(tpl, item, i === length - 1)).join("\n");
}
function prefixItem(tpl, item, tail = true) {
  const tpl1 = tpl[tail ? 1 : 0];
  return tpl1[0] + item.split("\n").join("\n" + tpl1[1]);
}
var TreeifyBuilder = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  treeify
});
class DecisionTree {
  /**
   * Create new DecisionTree object.
   *
   * @param input - an array containing all selectors
   * paired with associated values.
   *
   * @typeParam V - the type of values associated with selectors.
   */
  constructor(input) {
    this.branches = weave(toAstTerminalPairs(input));
  }
  /**
   * Turn this decision tree into a usable form.
   *
   * @typeParam R - return type defined by the builder function.
   *
   * @param builder - the builder function.
   *
   * @returns the decision tree in a form ready for use.
   */
  build(builder) {
    return builder(this.branches);
  }
}
function toAstTerminalPairs(array) {
  const len = array.length;
  const results = new Array(len);
  for (let i = 0; i < len; i++) {
    const [selectorString, val] = array[i];
    const ast2 = preprocess(parse1(selectorString));
    results[i] = {
      ast: ast2,
      terminal: {
        type: "terminal",
        valueContainer: { index: i, value: val, specificity: ast2.specificity }
      }
    };
  }
  return results;
}
function preprocess(ast2) {
  reduceSelectorVariants(ast2);
  normalize(ast2);
  return ast2;
}
function reduceSelectorVariants(ast2) {
  const newList = [];
  ast2.list.forEach((sel) => {
    switch (sel.type) {
      case "class":
        newList.push({
          matcher: "~=",
          modifier: null,
          name: "class",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "id":
        newList.push({
          matcher: "=",
          modifier: null,
          name: "id",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "combinator":
        reduceSelectorVariants(sel.left);
        newList.push(sel);
        break;
      case "universal":
        break;
      default:
        newList.push(sel);
        break;
    }
  });
  ast2.list = newList;
}
function weave(items) {
  const branches = [];
  while (items.length) {
    const topKind = findTopKey(items, (sel) => true, getSelectorKind);
    const { matches, nonmatches, empty: empty2 } = breakByKind(items, topKind);
    items = nonmatches;
    if (matches.length) {
      branches.push(branchOfKind(topKind, matches));
    }
    if (empty2.length) {
      branches.push(...terminate(empty2));
    }
  }
  return branches;
}
function terminate(items) {
  const results = [];
  for (const item of items) {
    const terminal = item.terminal;
    if (terminal.type === "terminal") {
      results.push(terminal);
    } else {
      const { matches, rest } = partition(terminal.cont, (node2) => node2.type === "terminal");
      matches.forEach((node2) => results.push(node2));
      if (rest.length) {
        terminal.cont = rest;
        results.push(terminal);
      }
    }
  }
  return results;
}
function breakByKind(items, selectedKind) {
  const matches = [];
  const nonmatches = [];
  const empty2 = [];
  for (const item of items) {
    const simpsels = item.ast.list;
    if (simpsels.length) {
      const isMatch = simpsels.some((node2) => getSelectorKind(node2) === selectedKind);
      (isMatch ? matches : nonmatches).push(item);
    } else {
      empty2.push(item);
    }
  }
  return { matches, nonmatches, empty: empty2 };
}
function getSelectorKind(sel) {
  switch (sel.type) {
    case "attrPresence":
      return `attrPresence ${sel.name}`;
    case "attrValue":
      return `attrValue ${sel.name}`;
    case "combinator":
      return `combinator ${sel.combinator}`;
    default:
      return sel.type;
  }
}
function branchOfKind(kind, items) {
  if (kind === "tag") {
    return tagNameBranch(items);
  }
  if (kind.startsWith("attrValue ")) {
    return attrValueBranch(kind.substring(10), items);
  }
  if (kind.startsWith("attrPresence ")) {
    return attrPresenceBranch(kind.substring(13), items);
  }
  if (kind === "combinator >") {
    return combinatorBranch(">", items);
  }
  if (kind === "combinator +") {
    return combinatorBranch("+", items);
  }
  throw new Error(`Unsupported selector kind: ${kind}`);
}
function tagNameBranch(items) {
  const groups = spliceAndGroup(items, (x2) => x2.type === "tag", (x2) => x2.name);
  const variants = Object.entries(groups).map(([name, group]) => ({
    type: "variant",
    value: name,
    cont: weave(group.items)
  }));
  return {
    type: "tagName",
    variants
  };
}
function attrPresenceBranch(name, items) {
  for (const item of items) {
    spliceSimpleSelector(item, (x2) => x2.type === "attrPresence" && x2.name === name);
  }
  return {
    type: "attrPresence",
    name,
    cont: weave(items)
  };
}
function attrValueBranch(name, items) {
  const groups = spliceAndGroup(items, (x2) => x2.type === "attrValue" && x2.name === name, (x2) => `${x2.matcher} ${x2.modifier || ""} ${x2.value}`);
  const matchers = [];
  for (const group of Object.values(groups)) {
    const sel = group.oneSimpleSelector;
    const predicate = getAttrPredicate(sel);
    const continuation = weave(group.items);
    matchers.push({
      type: "matcher",
      matcher: sel.matcher,
      modifier: sel.modifier,
      value: sel.value,
      predicate,
      cont: continuation
    });
  }
  return {
    type: "attrValue",
    name,
    matchers
  };
}
function getAttrPredicate(sel) {
  if (sel.modifier === "i") {
    const expected = sel.value.toLowerCase();
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual.toLowerCase();
      case "~=":
        return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.toLowerCase().startsWith(expected);
      case "$=":
        return (actual) => actual.toLowerCase().endsWith(expected);
      case "*=":
        return (actual) => actual.toLowerCase().includes(expected);
      case "|=":
        return (actual) => {
          const lower = actual.toLowerCase();
          return expected === lower || lower.startsWith(expected) && lower[expected.length] === "-";
        };
    }
  } else {
    const expected = sel.value;
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual;
      case "~=":
        return (actual) => actual.split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.startsWith(expected);
      case "$=":
        return (actual) => actual.endsWith(expected);
      case "*=":
        return (actual) => actual.includes(expected);
      case "|=":
        return (actual) => expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
    }
  }
}
function combinatorBranch(combinator, items) {
  const groups = spliceAndGroup(items, (x2) => x2.type === "combinator" && x2.combinator === combinator, (x2) => serialize(x2.left));
  const leftItems = [];
  for (const group of Object.values(groups)) {
    const rightCont = weave(group.items);
    const leftAst = group.oneSimpleSelector.left;
    leftItems.push({
      ast: leftAst,
      terminal: { type: "popElement", cont: rightCont }
    });
  }
  return {
    type: "pushElement",
    combinator,
    cont: weave(leftItems)
  };
}
function spliceAndGroup(items, predicate, keyCallback) {
  const groups = {};
  while (items.length) {
    const bestKey = findTopKey(items, predicate, keyCallback);
    const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
    const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
    const { matches, rest } = partition1(items, hasBestKeyPredicate);
    let oneSimpleSelector = null;
    for (const item of matches) {
      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
      if (!oneSimpleSelector) {
        oneSimpleSelector = splicedNode;
      }
    }
    if (oneSimpleSelector == null) {
      throw new Error("No simple selector is found.");
    }
    groups[bestKey] = { oneSimpleSelector, items: matches };
    items = rest;
  }
  return groups;
}
function spliceSimpleSelector(item, predicate) {
  const simpsels = item.ast.list;
  const matches = new Array(simpsels.length);
  let firstIndex = -1;
  for (let i = simpsels.length; i-- > 0; ) {
    if (predicate(simpsels[i])) {
      matches[i] = true;
      firstIndex = i;
    }
  }
  if (firstIndex == -1) {
    throw new Error(`Couldn't find the required simple selector.`);
  }
  const result = simpsels[firstIndex];
  item.ast.list = simpsels.filter((sel, i) => !matches[i]);
  return result;
}
function findTopKey(items, predicate, keyCallback) {
  const candidates = {};
  for (const item of items) {
    const candidates1 = {};
    for (const node2 of item.ast.list.filter(predicate)) {
      candidates1[keyCallback(node2)] = true;
    }
    for (const key of Object.keys(candidates1)) {
      if (candidates[key]) {
        candidates[key]++;
      } else {
        candidates[key] = 1;
      }
    }
  }
  let topKind = "";
  let topCounter = 0;
  for (const entry of Object.entries(candidates)) {
    if (entry[1] > topCounter) {
      topKind = entry[0];
      topCounter = entry[1];
    }
  }
  return topKind;
}
function partition(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x2 of src) {
    if (predicate(x2)) {
      matches.push(x2);
    } else {
      rest.push(x2);
    }
  }
  return { matches, rest };
}
function partition1(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x2 of src) {
    if (predicate(x2)) {
      matches.push(x2);
    } else {
      rest.push(x2);
    }
  }
  return { matches, rest };
}
class Picker {
  /**
   * Create new Picker object.
   *
   * @typeParam L - the type of HTML Element in the targeted DOM AST.
   * @typeParam V - the type of associated values.
   *
   * @param f - the function that matches an element
   * and returns all associated values.
   */
  constructor(f2) {
    this.f = f2;
  }
  /**
   * Run the selectors decision tree against one HTML Element
   * and return all matched associated values
   * along with selector specificities.
   *
   * Client code then decides how to further process them
   * (sort, filter, etc).
   *
   * @param el - an HTML Element.
   *
   * @returns all associated values along with
   * selector specificities for all matched selectors.
   */
  pickAll(el2) {
    return this.f(el2);
  }
  /**
   * Run the selectors decision tree against one HTML Element
   * and choose the value from the most specific mached selector.
   *
   * @param el - an HTML Element.
   *
   * @param preferFirst - option to define which value to choose
   * when there are multiple matches with equal specificity.
   *
   * @returns the value from the most specific mached selector
   * or `null` if nothing matched.
   */
  pick1(el2, preferFirst = false) {
    const results = this.f(el2);
    const len = results.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return results[0].value;
    }
    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
    let result = results[0];
    for (let i = 1; i < len; i++) {
      const next = results[i];
      if (comparator(result, next)) {
        result = next;
      }
    }
    return result.value;
  }
}
function comparatorPreferFirst(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index < acc.index;
}
function comparatorPreferLast(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index > acc.index;
}
const selderee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Ast,
  DecisionTree,
  Picker,
  Treeify: TreeifyBuilder,
  Types
}, Symbol.toStringTag, { value: "Module" }));
function hp2Builder(nodes) {
  return new Picker(handleArray(nodes));
}
function handleArray(nodes) {
  const matchers = nodes.map(handleNode);
  return (el2, ...tail) => flatMap(matchers, (m) => m(el2, ...tail));
}
function handleNode(node2) {
  switch (node2.type) {
    case "terminal": {
      const result = [node2.valueContainer];
      return (el2, ...tail) => result;
    }
    case "tagName":
      return handleTagName(node2);
    case "attrValue":
      return handleAttrValueName(node2);
    case "attrPresence":
      return handleAttrPresenceName(node2);
    case "pushElement":
      return handlePushElementNode(node2);
    case "popElement":
      return handlePopElementNode(node2);
  }
}
function handleTagName(node2) {
  const variants = {};
  for (const variant of node2.variants) {
    variants[variant.value] = handleArray(variant.cont);
  }
  return (el2, ...tail) => {
    const continuation = variants[el2.name];
    return continuation ? continuation(el2, ...tail) : [];
  };
}
function handleAttrPresenceName(node2) {
  const attrName = node2.name;
  const continuation = handleArray(node2.cont);
  return (el2, ...tail) => Object.prototype.hasOwnProperty.call(el2.attribs, attrName) ? continuation(el2, ...tail) : [];
}
function handleAttrValueName(node2) {
  const callbacks = [];
  for (const matcher of node2.matchers) {
    const predicate = matcher.predicate;
    const continuation = handleArray(matcher.cont);
    callbacks.push((attr, el2, ...tail) => predicate(attr) ? continuation(el2, ...tail) : []);
  }
  const attrName = node2.name;
  return (el2, ...tail) => {
    const attr = el2.attribs[attrName];
    return attr || attr === "" ? flatMap(callbacks, (cb) => cb(attr, el2, ...tail)) : [];
  };
}
function handlePushElementNode(node2) {
  const continuation = handleArray(node2.cont);
  const leftElementGetter = node2.combinator === "+" ? getPrecedingElement : getParentElement;
  return (el2, ...tail) => {
    const next = leftElementGetter(el2);
    if (next === null) {
      return [];
    }
    return continuation(next, el2, ...tail);
  };
}
const getPrecedingElement = (el2) => {
  const prev = el2.prev;
  if (prev === null) {
    return null;
  }
  return libExports.isTag(prev) ? prev : getPrecedingElement(prev);
};
const getParentElement = (el2) => {
  const parent = el2.parent;
  return parent && libExports.isTag(parent) ? parent : null;
};
function handlePopElementNode(node2) {
  const continuation = handleArray(node2.cont);
  return (el2, next, ...tail) => continuation(next, ...tail);
}
function flatMap(items, mapper) {
  return [].concat(...amap(items, mapper));
}
function amap(items, mapper) {
  const len = items.length;
  const res = new Array(len);
  for (let i = 0; i < len; i++) {
    res[i] = mapper(items[i]);
  }
  return res;
}
const hp2Builder$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hp2Builder
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(hp2Builder$1);
var cjs;
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  var isMergeableObject = function isMergeableObject2(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? /* @__PURE__ */ Symbol.for("react.element") : 60103;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target2, source, options) {
    return target2.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target2) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target2).filter(function(symbol) {
      return Object.propertyIsEnumerable.call(target2, symbol);
    }) : [];
  }
  function getKeys(target2) {
    return Object.keys(target2).concat(getEnumerableOwnPropertySymbols(target2));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_2) {
      return false;
    }
  }
  function propertyIsUnsafe(target2, key) {
    return propertyIsOnObject(target2, key) && !(Object.hasOwnProperty.call(target2, key) && Object.propertyIsEnumerable.call(target2, key));
  }
  function mergeObject(target2, source, options) {
    var destination = {};
    if (options.isMergeableObject(target2)) {
      getKeys(target2).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target2[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target2, key)) {
        return;
      }
      if (propertyIsOnObject(target2, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target2[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target2, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target2);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target2, source, options);
    } else {
      return mergeObject(target2, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error("first argument should be an array");
    }
    return array.reduce(function(prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  cjs = deepmerge_1;
  return cjs;
}
var he$1 = { exports: {} };
var he = he$1.exports;
var hasRequiredHe;
function requireHe() {
  if (hasRequiredHe) return he$1.exports;
  hasRequiredHe = 1;
  (function(module, exports$1) {
    (function(root) {
      var freeExports = exports$1;
      var freeModule = module && module.exports == freeExports && module;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = { "­": "shy", "‌": "zwnj", "‍": "zwj", "‎": "lrm", "⁣": "ic", "⁢": "it", "⁡": "af", "‏": "rlm", "​": "ZeroWidthSpace", "⁠": "NoBreak", "̑": "DownBreve", "⃛": "tdot", "⃜": "DotDot", "	": "Tab", "\n": "NewLine", " ": "puncsp", " ": "MediumSpace", " ": "thinsp", " ": "hairsp", " ": "emsp13", " ": "ensp", " ": "emsp14", " ": "emsp", " ": "numsp", " ": "nbsp", "  ": "ThickSpace", "‾": "oline", "_": "lowbar", "‐": "dash", "–": "ndash", "—": "mdash", "―": "horbar", ",": "comma", ";": "semi", "⁏": "bsemi", ":": "colon", "⩴": "Colone", "!": "excl", "¡": "iexcl", "?": "quest", "¿": "iquest", ".": "period", "‥": "nldr", "…": "mldr", "·": "middot", "'": "apos", "‘": "lsquo", "’": "rsquo", "‚": "sbquo", "‹": "lsaquo", "›": "rsaquo", '"': "quot", "“": "ldquo", "”": "rdquo", "„": "bdquo", "«": "laquo", "»": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "⌈": "lceil", "⌉": "rceil", "⌊": "lfloor", "⌋": "rfloor", "⦅": "lopar", "⦆": "ropar", "⦋": "lbrke", "⦌": "rbrke", "⦍": "lbrkslu", "⦎": "rbrksld", "⦏": "lbrksld", "⦐": "rbrkslu", "⦑": "langd", "⦒": "rangd", "⦓": "lparlt", "⦔": "rpargt", "⦕": "gtlPar", "⦖": "ltrPar", "⟦": "lobrk", "⟧": "robrk", "⟨": "lang", "⟩": "rang", "⟪": "Lang", "⟫": "Rang", "⟬": "loang", "⟭": "roang", "❲": "lbbrk", "❳": "rbbrk", "‖": "Vert", "§": "sect", "¶": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "‰": "permil", "‱": "pertenk", "†": "dagger", "‡": "Dagger", "•": "bull", "⁃": "hybull", "′": "prime", "″": "Prime", "‴": "tprime", "⁗": "qprime", "‵": "bprime", "⁁": "caret", "`": "grave", "´": "acute", "˜": "tilde", "^": "Hat", "¯": "macr", "˘": "breve", "˙": "dot", "¨": "die", "˚": "ring", "˝": "dblac", "¸": "cedil", "˛": "ogon", "ˆ": "circ", "ˇ": "caron", "°": "deg", "©": "copy", "®": "reg", "℗": "copysr", "℘": "wp", "℞": "rx", "℧": "mho", "℩": "iiota", "←": "larr", "↚": "nlarr", "→": "rarr", "↛": "nrarr", "↑": "uarr", "↓": "darr", "↔": "harr", "↮": "nharr", "↕": "varr", "↖": "nwarr", "↗": "nearr", "↘": "searr", "↙": "swarr", "↝": "rarrw", "↝̸": "nrarrw", "↞": "Larr", "↟": "Uarr", "↠": "Rarr", "↡": "Darr", "↢": "larrtl", "↣": "rarrtl", "↤": "mapstoleft", "↥": "mapstoup", "↦": "map", "↧": "mapstodown", "↩": "larrhk", "↪": "rarrhk", "↫": "larrlp", "↬": "rarrlp", "↭": "harrw", "↰": "lsh", "↱": "rsh", "↲": "ldsh", "↳": "rdsh", "↵": "crarr", "↶": "cularr", "↷": "curarr", "↺": "olarr", "↻": "orarr", "↼": "lharu", "↽": "lhard", "↾": "uharr", "↿": "uharl", "⇀": "rharu", "⇁": "rhard", "⇂": "dharr", "⇃": "dharl", "⇄": "rlarr", "⇅": "udarr", "⇆": "lrarr", "⇇": "llarr", "⇈": "uuarr", "⇉": "rrarr", "⇊": "ddarr", "⇋": "lrhar", "⇌": "rlhar", "⇐": "lArr", "⇍": "nlArr", "⇑": "uArr", "⇒": "rArr", "⇏": "nrArr", "⇓": "dArr", "⇔": "iff", "⇎": "nhArr", "⇕": "vArr", "⇖": "nwArr", "⇗": "neArr", "⇘": "seArr", "⇙": "swArr", "⇚": "lAarr", "⇛": "rAarr", "⇝": "zigrarr", "⇤": "larrb", "⇥": "rarrb", "⇵": "duarr", "⇽": "loarr", "⇾": "roarr", "⇿": "hoarr", "∀": "forall", "∁": "comp", "∂": "part", "∂̸": "npart", "∃": "exist", "∄": "nexist", "∅": "empty", "∇": "Del", "∈": "in", "∉": "notin", "∋": "ni", "∌": "notni", "϶": "bepsi", "∏": "prod", "∐": "coprod", "∑": "sum", "+": "plus", "±": "pm", "÷": "div", "×": "times", "<": "lt", "≮": "nlt", "<⃒": "nvlt", "=": "equals", "≠": "ne", "=⃥": "bne", "⩵": "Equal", ">": "gt", "≯": "ngt", ">⃒": "nvgt", "¬": "not", "|": "vert", "¦": "brvbar", "−": "minus", "∓": "mp", "∔": "plusdo", "⁄": "frasl", "∖": "setmn", "∗": "lowast", "∘": "compfn", "√": "Sqrt", "∝": "prop", "∞": "infin", "∟": "angrt", "∠": "ang", "∠⃒": "nang", "∡": "angmsd", "∢": "angsph", "∣": "mid", "∤": "nmid", "∥": "par", "∦": "npar", "∧": "and", "∨": "or", "∩": "cap", "∩︀": "caps", "∪": "cup", "∪︀": "cups", "∫": "int", "∬": "Int", "∭": "tint", "⨌": "qint", "∮": "oint", "∯": "Conint", "∰": "Cconint", "∱": "cwint", "∲": "cwconint", "∳": "awconint", "∴": "there4", "∵": "becaus", "∶": "ratio", "∷": "Colon", "∸": "minusd", "∺": "mDDot", "∻": "homtht", "∼": "sim", "≁": "nsim", "∼⃒": "nvsim", "∽": "bsim", "∽̱": "race", "∾": "ac", "∾̳": "acE", "∿": "acd", "≀": "wr", "≂": "esim", "≂̸": "nesim", "≃": "sime", "≄": "nsime", "≅": "cong", "≇": "ncong", "≆": "simne", "≈": "ap", "≉": "nap", "≊": "ape", "≋": "apid", "≋̸": "napid", "≌": "bcong", "≍": "CupCap", "≭": "NotCupCap", "≍⃒": "nvap", "≎": "bump", "≎̸": "nbump", "≏": "bumpe", "≏̸": "nbumpe", "≐": "doteq", "≐̸": "nedot", "≑": "eDot", "≒": "efDot", "≓": "erDot", "≔": "colone", "≕": "ecolon", "≖": "ecir", "≗": "cire", "≙": "wedgeq", "≚": "veeeq", "≜": "trie", "≟": "equest", "≡": "equiv", "≢": "nequiv", "≡⃥": "bnequiv", "≤": "le", "≰": "nle", "≤⃒": "nvle", "≥": "ge", "≱": "nge", "≥⃒": "nvge", "≦": "lE", "≦̸": "nlE", "≧": "gE", "≧̸": "ngE", "≨︀": "lvnE", "≨": "lnE", "≩": "gnE", "≩︀": "gvnE", "≪": "ll", "≪̸": "nLtv", "≪⃒": "nLt", "≫": "gg", "≫̸": "nGtv", "≫⃒": "nGt", "≬": "twixt", "≲": "lsim", "≴": "nlsim", "≳": "gsim", "≵": "ngsim", "≶": "lg", "≸": "ntlg", "≷": "gl", "≹": "ntgl", "≺": "pr", "⊀": "npr", "≻": "sc", "⊁": "nsc", "≼": "prcue", "⋠": "nprcue", "≽": "sccue", "⋡": "nsccue", "≾": "prsim", "≿": "scsim", "≿̸": "NotSucceedsTilde", "⊂": "sub", "⊄": "nsub", "⊂⃒": "vnsub", "⊃": "sup", "⊅": "nsup", "⊃⃒": "vnsup", "⊆": "sube", "⊈": "nsube", "⊇": "supe", "⊉": "nsupe", "⊊︀": "vsubne", "⊊": "subne", "⊋︀": "vsupne", "⊋": "supne", "⊍": "cupdot", "⊎": "uplus", "⊏": "sqsub", "⊏̸": "NotSquareSubset", "⊐": "sqsup", "⊐̸": "NotSquareSuperset", "⊑": "sqsube", "⋢": "nsqsube", "⊒": "sqsupe", "⋣": "nsqsupe", "⊓": "sqcap", "⊓︀": "sqcaps", "⊔": "sqcup", "⊔︀": "sqcups", "⊕": "oplus", "⊖": "ominus", "⊗": "otimes", "⊘": "osol", "⊙": "odot", "⊚": "ocir", "⊛": "oast", "⊝": "odash", "⊞": "plusb", "⊟": "minusb", "⊠": "timesb", "⊡": "sdotb", "⊢": "vdash", "⊬": "nvdash", "⊣": "dashv", "⊤": "top", "⊥": "bot", "⊧": "models", "⊨": "vDash", "⊭": "nvDash", "⊩": "Vdash", "⊮": "nVdash", "⊪": "Vvdash", "⊫": "VDash", "⊯": "nVDash", "⊰": "prurel", "⊲": "vltri", "⋪": "nltri", "⊳": "vrtri", "⋫": "nrtri", "⊴": "ltrie", "⋬": "nltrie", "⊴⃒": "nvltrie", "⊵": "rtrie", "⋭": "nrtrie", "⊵⃒": "nvrtrie", "⊶": "origof", "⊷": "imof", "⊸": "mumap", "⊹": "hercon", "⊺": "intcal", "⊻": "veebar", "⊽": "barvee", "⊾": "angrtvb", "⊿": "lrtri", "⋀": "Wedge", "⋁": "Vee", "⋂": "xcap", "⋃": "xcup", "⋄": "diam", "⋅": "sdot", "⋆": "Star", "⋇": "divonx", "⋈": "bowtie", "⋉": "ltimes", "⋊": "rtimes", "⋋": "lthree", "⋌": "rthree", "⋍": "bsime", "⋎": "cuvee", "⋏": "cuwed", "⋐": "Sub", "⋑": "Sup", "⋒": "Cap", "⋓": "Cup", "⋔": "fork", "⋕": "epar", "⋖": "ltdot", "⋗": "gtdot", "⋘": "Ll", "⋘̸": "nLl", "⋙": "Gg", "⋙̸": "nGg", "⋚︀": "lesg", "⋚": "leg", "⋛": "gel", "⋛︀": "gesl", "⋞": "cuepr", "⋟": "cuesc", "⋦": "lnsim", "⋧": "gnsim", "⋨": "prnsim", "⋩": "scnsim", "⋮": "vellip", "⋯": "ctdot", "⋰": "utdot", "⋱": "dtdot", "⋲": "disin", "⋳": "isinsv", "⋴": "isins", "⋵": "isindot", "⋵̸": "notindot", "⋶": "notinvc", "⋷": "notinvb", "⋹": "isinE", "⋹̸": "notinE", "⋺": "nisd", "⋻": "xnis", "⋼": "nis", "⋽": "notnivc", "⋾": "notnivb", "⌅": "barwed", "⌆": "Barwed", "⌌": "drcrop", "⌍": "dlcrop", "⌎": "urcrop", "⌏": "ulcrop", "⌐": "bnot", "⌒": "profline", "⌓": "profsurf", "⌕": "telrec", "⌖": "target", "⌜": "ulcorn", "⌝": "urcorn", "⌞": "dlcorn", "⌟": "drcorn", "⌢": "frown", "⌣": "smile", "⌭": "cylcty", "⌮": "profalar", "⌶": "topbot", "⌽": "ovbar", "⌿": "solbar", "⍼": "angzarr", "⎰": "lmoust", "⎱": "rmoust", "⎴": "tbrk", "⎵": "bbrk", "⎶": "bbrktbrk", "⏜": "OverParenthesis", "⏝": "UnderParenthesis", "⏞": "OverBrace", "⏟": "UnderBrace", "⏢": "trpezium", "⏧": "elinters", "␣": "blank", "─": "boxh", "│": "boxv", "┌": "boxdr", "┐": "boxdl", "└": "boxur", "┘": "boxul", "├": "boxvr", "┤": "boxvl", "┬": "boxhd", "┴": "boxhu", "┼": "boxvh", "═": "boxH", "║": "boxV", "╒": "boxdR", "╓": "boxDr", "╔": "boxDR", "╕": "boxdL", "╖": "boxDl", "╗": "boxDL", "╘": "boxuR", "╙": "boxUr", "╚": "boxUR", "╛": "boxuL", "╜": "boxUl", "╝": "boxUL", "╞": "boxvR", "╟": "boxVr", "╠": "boxVR", "╡": "boxvL", "╢": "boxVl", "╣": "boxVL", "╤": "boxHd", "╥": "boxhD", "╦": "boxHD", "╧": "boxHu", "╨": "boxhU", "╩": "boxHU", "╪": "boxvH", "╫": "boxVh", "╬": "boxVH", "▀": "uhblk", "▄": "lhblk", "█": "block", "░": "blk14", "▒": "blk12", "▓": "blk34", "□": "squ", "▪": "squf", "▫": "EmptyVerySmallSquare", "▭": "rect", "▮": "marker", "▱": "fltns", "△": "xutri", "▴": "utrif", "▵": "utri", "▸": "rtrif", "▹": "rtri", "▽": "xdtri", "▾": "dtrif", "▿": "dtri", "◂": "ltrif", "◃": "ltri", "◊": "loz", "○": "cir", "◬": "tridot", "◯": "xcirc", "◸": "ultri", "◹": "urtri", "◺": "lltri", "◻": "EmptySmallSquare", "◼": "FilledSmallSquare", "★": "starf", "☆": "star", "☎": "phone", "♀": "female", "♂": "male", "♠": "spades", "♣": "clubs", "♥": "hearts", "♦": "diams", "♪": "sung", "✓": "check", "✗": "cross", "✠": "malt", "✶": "sext", "❘": "VerticalSeparator", "⟈": "bsolhsub", "⟉": "suphsol", "⟵": "xlarr", "⟶": "xrarr", "⟷": "xharr", "⟸": "xlArr", "⟹": "xrArr", "⟺": "xhArr", "⟼": "xmap", "⟿": "dzigrarr", "⤂": "nvlArr", "⤃": "nvrArr", "⤄": "nvHarr", "⤅": "Map", "⤌": "lbarr", "⤍": "rbarr", "⤎": "lBarr", "⤏": "rBarr", "⤐": "RBarr", "⤑": "DDotrahd", "⤒": "UpArrowBar", "⤓": "DownArrowBar", "⤖": "Rarrtl", "⤙": "latail", "⤚": "ratail", "⤛": "lAtail", "⤜": "rAtail", "⤝": "larrfs", "⤞": "rarrfs", "⤟": "larrbfs", "⤠": "rarrbfs", "⤣": "nwarhk", "⤤": "nearhk", "⤥": "searhk", "⤦": "swarhk", "⤧": "nwnear", "⤨": "toea", "⤩": "tosa", "⤪": "swnwar", "⤳": "rarrc", "⤳̸": "nrarrc", "⤵": "cudarrr", "⤶": "ldca", "⤷": "rdca", "⤸": "cudarrl", "⤹": "larrpl", "⤼": "curarrm", "⤽": "cularrp", "⥅": "rarrpl", "⥈": "harrcir", "⥉": "Uarrocir", "⥊": "lurdshar", "⥋": "ldrushar", "⥎": "LeftRightVector", "⥏": "RightUpDownVector", "⥐": "DownLeftRightVector", "⥑": "LeftUpDownVector", "⥒": "LeftVectorBar", "⥓": "RightVectorBar", "⥔": "RightUpVectorBar", "⥕": "RightDownVectorBar", "⥖": "DownLeftVectorBar", "⥗": "DownRightVectorBar", "⥘": "LeftUpVectorBar", "⥙": "LeftDownVectorBar", "⥚": "LeftTeeVector", "⥛": "RightTeeVector", "⥜": "RightUpTeeVector", "⥝": "RightDownTeeVector", "⥞": "DownLeftTeeVector", "⥟": "DownRightTeeVector", "⥠": "LeftUpTeeVector", "⥡": "LeftDownTeeVector", "⥢": "lHar", "⥣": "uHar", "⥤": "rHar", "⥥": "dHar", "⥦": "luruhar", "⥧": "ldrdhar", "⥨": "ruluhar", "⥩": "rdldhar", "⥪": "lharul", "⥫": "llhard", "⥬": "rharul", "⥭": "lrhard", "⥮": "udhar", "⥯": "duhar", "⥰": "RoundImplies", "⥱": "erarr", "⥲": "simrarr", "⥳": "larrsim", "⥴": "rarrsim", "⥵": "rarrap", "⥶": "ltlarr", "⥸": "gtrarr", "⥹": "subrarr", "⥻": "suplarr", "⥼": "lfisht", "⥽": "rfisht", "⥾": "ufisht", "⥿": "dfisht", "⦚": "vzigzag", "⦜": "vangrt", "⦝": "angrtvbd", "⦤": "ange", "⦥": "range", "⦦": "dwangle", "⦧": "uwangle", "⦨": "angmsdaa", "⦩": "angmsdab", "⦪": "angmsdac", "⦫": "angmsdad", "⦬": "angmsdae", "⦭": "angmsdaf", "⦮": "angmsdag", "⦯": "angmsdah", "⦰": "bemptyv", "⦱": "demptyv", "⦲": "cemptyv", "⦳": "raemptyv", "⦴": "laemptyv", "⦵": "ohbar", "⦶": "omid", "⦷": "opar", "⦹": "operp", "⦻": "olcross", "⦼": "odsold", "⦾": "olcir", "⦿": "ofcir", "⧀": "olt", "⧁": "ogt", "⧂": "cirscir", "⧃": "cirE", "⧄": "solb", "⧅": "bsolb", "⧉": "boxbox", "⧍": "trisb", "⧎": "rtriltri", "⧏": "LeftTriangleBar", "⧏̸": "NotLeftTriangleBar", "⧐": "RightTriangleBar", "⧐̸": "NotRightTriangleBar", "⧜": "iinfin", "⧝": "infintie", "⧞": "nvinfin", "⧣": "eparsl", "⧤": "smeparsl", "⧥": "eqvparsl", "⧫": "lozf", "⧴": "RuleDelayed", "⧶": "dsol", "⨀": "xodot", "⨁": "xoplus", "⨂": "xotime", "⨄": "xuplus", "⨆": "xsqcup", "⨍": "fpartint", "⨐": "cirfnint", "⨑": "awint", "⨒": "rppolint", "⨓": "scpolint", "⨔": "npolint", "⨕": "pointint", "⨖": "quatint", "⨗": "intlarhk", "⨢": "pluscir", "⨣": "plusacir", "⨤": "simplus", "⨥": "plusdu", "⨦": "plussim", "⨧": "plustwo", "⨩": "mcomma", "⨪": "minusdu", "⨭": "loplus", "⨮": "roplus", "⨯": "Cross", "⨰": "timesd", "⨱": "timesbar", "⨳": "smashp", "⨴": "lotimes", "⨵": "rotimes", "⨶": "otimesas", "⨷": "Otimes", "⨸": "odiv", "⨹": "triplus", "⨺": "triminus", "⨻": "tritime", "⨼": "iprod", "⨿": "amalg", "⩀": "capdot", "⩂": "ncup", "⩃": "ncap", "⩄": "capand", "⩅": "cupor", "⩆": "cupcap", "⩇": "capcup", "⩈": "cupbrcap", "⩉": "capbrcup", "⩊": "cupcup", "⩋": "capcap", "⩌": "ccups", "⩍": "ccaps", "⩐": "ccupssm", "⩓": "And", "⩔": "Or", "⩕": "andand", "⩖": "oror", "⩗": "orslope", "⩘": "andslope", "⩚": "andv", "⩛": "orv", "⩜": "andd", "⩝": "ord", "⩟": "wedbar", "⩦": "sdote", "⩪": "simdot", "⩭": "congdot", "⩭̸": "ncongdot", "⩮": "easter", "⩯": "apacir", "⩰": "apE", "⩰̸": "napE", "⩱": "eplus", "⩲": "pluse", "⩳": "Esim", "⩷": "eDDot", "⩸": "equivDD", "⩹": "ltcir", "⩺": "gtcir", "⩻": "ltquest", "⩼": "gtquest", "⩽": "les", "⩽̸": "nles", "⩾": "ges", "⩾̸": "nges", "⩿": "lesdot", "⪀": "gesdot", "⪁": "lesdoto", "⪂": "gesdoto", "⪃": "lesdotor", "⪄": "gesdotol", "⪅": "lap", "⪆": "gap", "⪇": "lne", "⪈": "gne", "⪉": "lnap", "⪊": "gnap", "⪋": "lEg", "⪌": "gEl", "⪍": "lsime", "⪎": "gsime", "⪏": "lsimg", "⪐": "gsiml", "⪑": "lgE", "⪒": "glE", "⪓": "lesges", "⪔": "gesles", "⪕": "els", "⪖": "egs", "⪗": "elsdot", "⪘": "egsdot", "⪙": "el", "⪚": "eg", "⪝": "siml", "⪞": "simg", "⪟": "simlE", "⪠": "simgE", "⪡": "LessLess", "⪡̸": "NotNestedLessLess", "⪢": "GreaterGreater", "⪢̸": "NotNestedGreaterGreater", "⪤": "glj", "⪥": "gla", "⪦": "ltcc", "⪧": "gtcc", "⪨": "lescc", "⪩": "gescc", "⪪": "smt", "⪫": "lat", "⪬": "smte", "⪬︀": "smtes", "⪭": "late", "⪭︀": "lates", "⪮": "bumpE", "⪯": "pre", "⪯̸": "npre", "⪰": "sce", "⪰̸": "nsce", "⪳": "prE", "⪴": "scE", "⪵": "prnE", "⪶": "scnE", "⪷": "prap", "⪸": "scap", "⪹": "prnap", "⪺": "scnap", "⪻": "Pr", "⪼": "Sc", "⪽": "subdot", "⪾": "supdot", "⪿": "subplus", "⫀": "supplus", "⫁": "submult", "⫂": "supmult", "⫃": "subedot", "⫄": "supedot", "⫅": "subE", "⫅̸": "nsubE", "⫆": "supE", "⫆̸": "nsupE", "⫇": "subsim", "⫈": "supsim", "⫋︀": "vsubnE", "⫋": "subnE", "⫌︀": "vsupnE", "⫌": "supnE", "⫏": "csub", "⫐": "csup", "⫑": "csube", "⫒": "csupe", "⫓": "subsup", "⫔": "supsub", "⫕": "subsub", "⫖": "supsup", "⫗": "suphsub", "⫘": "supdsub", "⫙": "forkv", "⫚": "topfork", "⫛": "mlcp", "⫤": "Dashv", "⫦": "Vdashl", "⫧": "Barv", "⫨": "vBar", "⫩": "vBarv", "⫫": "Vbar", "⫬": "Not", "⫭": "bNot", "⫮": "rnmid", "⫯": "cirmid", "⫰": "midcir", "⫱": "topcir", "⫲": "nhpar", "⫳": "parsim", "⫽": "parsl", "⫽⃥": "nparsl", "♭": "flat", "♮": "natur", "♯": "sharp", "¤": "curren", "¢": "cent", "$": "dollar", "£": "pound", "¥": "yen", "€": "euro", "¹": "sup1", "½": "half", "⅓": "frac13", "¼": "frac14", "⅕": "frac15", "⅙": "frac16", "⅛": "frac18", "²": "sup2", "⅔": "frac23", "⅖": "frac25", "³": "sup3", "¾": "frac34", "⅗": "frac35", "⅜": "frac38", "⅘": "frac45", "⅚": "frac56", "⅝": "frac58", "⅞": "frac78", "𝒶": "ascr", "𝕒": "aopf", "𝔞": "afr", "𝔸": "Aopf", "𝔄": "Afr", "𝒜": "Ascr", "ª": "ordf", "á": "aacute", "Á": "Aacute", "à": "agrave", "À": "Agrave", "ă": "abreve", "Ă": "Abreve", "â": "acirc", "Â": "Acirc", "å": "aring", "Å": "angst", "ä": "auml", "Ä": "Auml", "ã": "atilde", "Ã": "Atilde", "ą": "aogon", "Ą": "Aogon", "ā": "amacr", "Ā": "Amacr", "æ": "aelig", "Æ": "AElig", "𝒷": "bscr", "𝕓": "bopf", "𝔟": "bfr", "𝔹": "Bopf", "ℬ": "Bscr", "𝔅": "Bfr", "𝔠": "cfr", "𝒸": "cscr", "𝕔": "copf", "ℭ": "Cfr", "𝒞": "Cscr", "ℂ": "Copf", "ć": "cacute", "Ć": "Cacute", "ĉ": "ccirc", "Ĉ": "Ccirc", "č": "ccaron", "Č": "Ccaron", "ċ": "cdot", "Ċ": "Cdot", "ç": "ccedil", "Ç": "Ccedil", "℅": "incare", "𝔡": "dfr", "ⅆ": "dd", "𝕕": "dopf", "𝒹": "dscr", "𝒟": "Dscr", "𝔇": "Dfr", "ⅅ": "DD", "𝔻": "Dopf", "ď": "dcaron", "Ď": "Dcaron", "đ": "dstrok", "Đ": "Dstrok", "ð": "eth", "Ð": "ETH", "ⅇ": "ee", "ℯ": "escr", "𝔢": "efr", "𝕖": "eopf", "ℰ": "Escr", "𝔈": "Efr", "𝔼": "Eopf", "é": "eacute", "É": "Eacute", "è": "egrave", "È": "Egrave", "ê": "ecirc", "Ê": "Ecirc", "ě": "ecaron", "Ě": "Ecaron", "ë": "euml", "Ë": "Euml", "ė": "edot", "Ė": "Edot", "ę": "eogon", "Ę": "Eogon", "ē": "emacr", "Ē": "Emacr", "𝔣": "ffr", "𝕗": "fopf", "𝒻": "fscr", "𝔉": "Ffr", "𝔽": "Fopf", "ℱ": "Fscr", "ﬀ": "fflig", "ﬃ": "ffilig", "ﬄ": "ffllig", "ﬁ": "filig", "fj": "fjlig", "ﬂ": "fllig", "ƒ": "fnof", "ℊ": "gscr", "𝕘": "gopf", "𝔤": "gfr", "𝒢": "Gscr", "𝔾": "Gopf", "𝔊": "Gfr", "ǵ": "gacute", "ğ": "gbreve", "Ğ": "Gbreve", "ĝ": "gcirc", "Ĝ": "Gcirc", "ġ": "gdot", "Ġ": "Gdot", "Ģ": "Gcedil", "𝔥": "hfr", "ℎ": "planckh", "𝒽": "hscr", "𝕙": "hopf", "ℋ": "Hscr", "ℌ": "Hfr", "ℍ": "Hopf", "ĥ": "hcirc", "Ĥ": "Hcirc", "ℏ": "hbar", "ħ": "hstrok", "Ħ": "Hstrok", "𝕚": "iopf", "𝔦": "ifr", "𝒾": "iscr", "ⅈ": "ii", "𝕀": "Iopf", "ℐ": "Iscr", "ℑ": "Im", "í": "iacute", "Í": "Iacute", "ì": "igrave", "Ì": "Igrave", "î": "icirc", "Î": "Icirc", "ï": "iuml", "Ï": "Iuml", "ĩ": "itilde", "Ĩ": "Itilde", "İ": "Idot", "į": "iogon", "Į": "Iogon", "ī": "imacr", "Ī": "Imacr", "ĳ": "ijlig", "Ĳ": "IJlig", "ı": "imath", "𝒿": "jscr", "𝕛": "jopf", "𝔧": "jfr", "𝒥": "Jscr", "𝔍": "Jfr", "𝕁": "Jopf", "ĵ": "jcirc", "Ĵ": "Jcirc", "ȷ": "jmath", "𝕜": "kopf", "𝓀": "kscr", "𝔨": "kfr", "𝒦": "Kscr", "𝕂": "Kopf", "𝔎": "Kfr", "ķ": "kcedil", "Ķ": "Kcedil", "𝔩": "lfr", "𝓁": "lscr", "ℓ": "ell", "𝕝": "lopf", "ℒ": "Lscr", "𝔏": "Lfr", "𝕃": "Lopf", "ĺ": "lacute", "Ĺ": "Lacute", "ľ": "lcaron", "Ľ": "Lcaron", "ļ": "lcedil", "Ļ": "Lcedil", "ł": "lstrok", "Ł": "Lstrok", "ŀ": "lmidot", "Ŀ": "Lmidot", "𝔪": "mfr", "𝕞": "mopf", "𝓂": "mscr", "𝔐": "Mfr", "𝕄": "Mopf", "ℳ": "Mscr", "𝔫": "nfr", "𝕟": "nopf", "𝓃": "nscr", "ℕ": "Nopf", "𝒩": "Nscr", "𝔑": "Nfr", "ń": "nacute", "Ń": "Nacute", "ň": "ncaron", "Ň": "Ncaron", "ñ": "ntilde", "Ñ": "Ntilde", "ņ": "ncedil", "Ņ": "Ncedil", "№": "numero", "ŋ": "eng", "Ŋ": "ENG", "𝕠": "oopf", "𝔬": "ofr", "ℴ": "oscr", "𝒪": "Oscr", "𝔒": "Ofr", "𝕆": "Oopf", "º": "ordm", "ó": "oacute", "Ó": "Oacute", "ò": "ograve", "Ò": "Ograve", "ô": "ocirc", "Ô": "Ocirc", "ö": "ouml", "Ö": "Ouml", "ő": "odblac", "Ő": "Odblac", "õ": "otilde", "Õ": "Otilde", "ø": "oslash", "Ø": "Oslash", "ō": "omacr", "Ō": "Omacr", "œ": "oelig", "Œ": "OElig", "𝔭": "pfr", "𝓅": "pscr", "𝕡": "popf", "ℙ": "Popf", "𝔓": "Pfr", "𝒫": "Pscr", "𝕢": "qopf", "𝔮": "qfr", "𝓆": "qscr", "𝒬": "Qscr", "𝔔": "Qfr", "ℚ": "Qopf", "ĸ": "kgreen", "𝔯": "rfr", "𝕣": "ropf", "𝓇": "rscr", "ℛ": "Rscr", "ℜ": "Re", "ℝ": "Ropf", "ŕ": "racute", "Ŕ": "Racute", "ř": "rcaron", "Ř": "Rcaron", "ŗ": "rcedil", "Ŗ": "Rcedil", "𝕤": "sopf", "𝓈": "sscr", "𝔰": "sfr", "𝕊": "Sopf", "𝔖": "Sfr", "𝒮": "Sscr", "Ⓢ": "oS", "ś": "sacute", "Ś": "Sacute", "ŝ": "scirc", "Ŝ": "Scirc", "š": "scaron", "Š": "Scaron", "ş": "scedil", "Ş": "Scedil", "ß": "szlig", "𝔱": "tfr", "𝓉": "tscr", "𝕥": "topf", "𝒯": "Tscr", "𝔗": "Tfr", "𝕋": "Topf", "ť": "tcaron", "Ť": "Tcaron", "ţ": "tcedil", "Ţ": "Tcedil", "™": "trade", "ŧ": "tstrok", "Ŧ": "Tstrok", "𝓊": "uscr", "𝕦": "uopf", "𝔲": "ufr", "𝕌": "Uopf", "𝔘": "Ufr", "𝒰": "Uscr", "ú": "uacute", "Ú": "Uacute", "ù": "ugrave", "Ù": "Ugrave", "ŭ": "ubreve", "Ŭ": "Ubreve", "û": "ucirc", "Û": "Ucirc", "ů": "uring", "Ů": "Uring", "ü": "uuml", "Ü": "Uuml", "ű": "udblac", "Ű": "Udblac", "ũ": "utilde", "Ũ": "Utilde", "ų": "uogon", "Ų": "Uogon", "ū": "umacr", "Ū": "Umacr", "𝔳": "vfr", "𝕧": "vopf", "𝓋": "vscr", "𝔙": "Vfr", "𝕍": "Vopf", "𝒱": "Vscr", "𝕨": "wopf", "𝓌": "wscr", "𝔴": "wfr", "𝒲": "Wscr", "𝕎": "Wopf", "𝔚": "Wfr", "ŵ": "wcirc", "Ŵ": "Wcirc", "𝔵": "xfr", "𝓍": "xscr", "𝕩": "xopf", "𝕏": "Xopf", "𝔛": "Xfr", "𝒳": "Xscr", "𝔶": "yfr", "𝓎": "yscr", "𝕪": "yopf", "𝒴": "Yscr", "𝔜": "Yfr", "𝕐": "Yopf", "ý": "yacute", "Ý": "Yacute", "ŷ": "ycirc", "Ŷ": "Ycirc", "ÿ": "yuml", "Ÿ": "Yuml", "𝓏": "zscr", "𝔷": "zfr", "𝕫": "zopf", "ℨ": "Zfr", "ℤ": "Zopf", "𝒵": "Zscr", "ź": "zacute", "Ź": "Zacute", "ž": "zcaron", "Ž": "Zcaron", "ż": "zdot", "Ż": "Zdot", "Ƶ": "imped", "þ": "thorn", "Þ": "THORN", "ŉ": "napos", "α": "alpha", "Α": "Alpha", "β": "beta", "Β": "Beta", "γ": "gamma", "Γ": "Gamma", "δ": "delta", "Δ": "Delta", "ε": "epsi", "ϵ": "epsiv", "Ε": "Epsilon", "ϝ": "gammad", "Ϝ": "Gammad", "ζ": "zeta", "Ζ": "Zeta", "η": "eta", "Η": "Eta", "θ": "theta", "ϑ": "thetav", "Θ": "Theta", "ι": "iota", "Ι": "Iota", "κ": "kappa", "ϰ": "kappav", "Κ": "Kappa", "λ": "lambda", "Λ": "Lambda", "μ": "mu", "µ": "micro", "Μ": "Mu", "ν": "nu", "Ν": "Nu", "ξ": "xi", "Ξ": "Xi", "ο": "omicron", "Ο": "Omicron", "π": "pi", "ϖ": "piv", "Π": "Pi", "ρ": "rho", "ϱ": "rhov", "Ρ": "Rho", "σ": "sigma", "Σ": "Sigma", "ς": "sigmaf", "τ": "tau", "Τ": "Tau", "υ": "upsi", "Υ": "Upsilon", "ϒ": "Upsi", "φ": "phi", "ϕ": "phiv", "Φ": "Phi", "χ": "chi", "Χ": "Chi", "ψ": "psi", "Ψ": "Psi", "ω": "omega", "Ω": "ohm", "а": "acy", "А": "Acy", "б": "bcy", "Б": "Bcy", "в": "vcy", "В": "Vcy", "г": "gcy", "Г": "Gcy", "ѓ": "gjcy", "Ѓ": "GJcy", "д": "dcy", "Д": "Dcy", "ђ": "djcy", "Ђ": "DJcy", "е": "iecy", "Е": "IEcy", "ё": "iocy", "Ё": "IOcy", "є": "jukcy", "Є": "Jukcy", "ж": "zhcy", "Ж": "ZHcy", "з": "zcy", "З": "Zcy", "ѕ": "dscy", "Ѕ": "DScy", "и": "icy", "И": "Icy", "і": "iukcy", "І": "Iukcy", "ї": "yicy", "Ї": "YIcy", "й": "jcy", "Й": "Jcy", "ј": "jsercy", "Ј": "Jsercy", "к": "kcy", "К": "Kcy", "ќ": "kjcy", "Ќ": "KJcy", "л": "lcy", "Л": "Lcy", "љ": "ljcy", "Љ": "LJcy", "м": "mcy", "М": "Mcy", "н": "ncy", "Н": "Ncy", "њ": "njcy", "Њ": "NJcy", "о": "ocy", "О": "Ocy", "п": "pcy", "П": "Pcy", "р": "rcy", "Р": "Rcy", "с": "scy", "С": "Scy", "т": "tcy", "Т": "Tcy", "ћ": "tshcy", "Ћ": "TSHcy", "у": "ucy", "У": "Ucy", "ў": "ubrcy", "Ў": "Ubrcy", "ф": "fcy", "Ф": "Fcy", "х": "khcy", "Х": "KHcy", "ц": "tscy", "Ц": "TScy", "ч": "chcy", "Ч": "CHcy", "џ": "dzcy", "Џ": "DZcy", "ш": "shcy", "Ш": "SHcy", "щ": "shchcy", "Щ": "SHCHcy", "ъ": "hardcy", "Ъ": "HARDcy", "ы": "ycy", "Ы": "Ycy", "ь": "softcy", "Ь": "SOFTcy", "э": "ecy", "Э": "Ecy", "ю": "yucy", "Ю": "YUcy", "я": "yacy", "Я": "YAcy", "ℵ": "aleph", "ℶ": "beth", "ℷ": "gimel", "ℸ": "daleth" };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless it’s part of a tag or an
        // unquoted attribute value. We’re only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer ≤ 8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;"
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = { "aacute": "á", "Aacute": "Á", "abreve": "ă", "Abreve": "Ă", "ac": "∾", "acd": "∿", "acE": "∾̳", "acirc": "â", "Acirc": "Â", "acute": "´", "acy": "а", "Acy": "А", "aelig": "æ", "AElig": "Æ", "af": "⁡", "afr": "𝔞", "Afr": "𝔄", "agrave": "à", "Agrave": "À", "alefsym": "ℵ", "aleph": "ℵ", "alpha": "α", "Alpha": "Α", "amacr": "ā", "Amacr": "Ā", "amalg": "⨿", "amp": "&", "AMP": "&", "and": "∧", "And": "⩓", "andand": "⩕", "andd": "⩜", "andslope": "⩘", "andv": "⩚", "ang": "∠", "ange": "⦤", "angle": "∠", "angmsd": "∡", "angmsdaa": "⦨", "angmsdab": "⦩", "angmsdac": "⦪", "angmsdad": "⦫", "angmsdae": "⦬", "angmsdaf": "⦭", "angmsdag": "⦮", "angmsdah": "⦯", "angrt": "∟", "angrtvb": "⊾", "angrtvbd": "⦝", "angsph": "∢", "angst": "Å", "angzarr": "⍼", "aogon": "ą", "Aogon": "Ą", "aopf": "𝕒", "Aopf": "𝔸", "ap": "≈", "apacir": "⩯", "ape": "≊", "apE": "⩰", "apid": "≋", "apos": "'", "ApplyFunction": "⁡", "approx": "≈", "approxeq": "≊", "aring": "å", "Aring": "Å", "ascr": "𝒶", "Ascr": "𝒜", "Assign": "≔", "ast": "*", "asymp": "≈", "asympeq": "≍", "atilde": "ã", "Atilde": "Ã", "auml": "ä", "Auml": "Ä", "awconint": "∳", "awint": "⨑", "backcong": "≌", "backepsilon": "϶", "backprime": "‵", "backsim": "∽", "backsimeq": "⋍", "Backslash": "∖", "Barv": "⫧", "barvee": "⊽", "barwed": "⌅", "Barwed": "⌆", "barwedge": "⌅", "bbrk": "⎵", "bbrktbrk": "⎶", "bcong": "≌", "bcy": "б", "Bcy": "Б", "bdquo": "„", "becaus": "∵", "because": "∵", "Because": "∵", "bemptyv": "⦰", "bepsi": "϶", "bernou": "ℬ", "Bernoullis": "ℬ", "beta": "β", "Beta": "Β", "beth": "ℶ", "between": "≬", "bfr": "𝔟", "Bfr": "𝔅", "bigcap": "⋂", "bigcirc": "◯", "bigcup": "⋃", "bigodot": "⨀", "bigoplus": "⨁", "bigotimes": "⨂", "bigsqcup": "⨆", "bigstar": "★", "bigtriangledown": "▽", "bigtriangleup": "△", "biguplus": "⨄", "bigvee": "⋁", "bigwedge": "⋀", "bkarow": "⤍", "blacklozenge": "⧫", "blacksquare": "▪", "blacktriangle": "▴", "blacktriangledown": "▾", "blacktriangleleft": "◂", "blacktriangleright": "▸", "blank": "␣", "blk12": "▒", "blk14": "░", "blk34": "▓", "block": "█", "bne": "=⃥", "bnequiv": "≡⃥", "bnot": "⌐", "bNot": "⫭", "bopf": "𝕓", "Bopf": "𝔹", "bot": "⊥", "bottom": "⊥", "bowtie": "⋈", "boxbox": "⧉", "boxdl": "┐", "boxdL": "╕", "boxDl": "╖", "boxDL": "╗", "boxdr": "┌", "boxdR": "╒", "boxDr": "╓", "boxDR": "╔", "boxh": "─", "boxH": "═", "boxhd": "┬", "boxhD": "╥", "boxHd": "╤", "boxHD": "╦", "boxhu": "┴", "boxhU": "╨", "boxHu": "╧", "boxHU": "╩", "boxminus": "⊟", "boxplus": "⊞", "boxtimes": "⊠", "boxul": "┘", "boxuL": "╛", "boxUl": "╜", "boxUL": "╝", "boxur": "└", "boxuR": "╘", "boxUr": "╙", "boxUR": "╚", "boxv": "│", "boxV": "║", "boxvh": "┼", "boxvH": "╪", "boxVh": "╫", "boxVH": "╬", "boxvl": "┤", "boxvL": "╡", "boxVl": "╢", "boxVL": "╣", "boxvr": "├", "boxvR": "╞", "boxVr": "╟", "boxVR": "╠", "bprime": "‵", "breve": "˘", "Breve": "˘", "brvbar": "¦", "bscr": "𝒷", "Bscr": "ℬ", "bsemi": "⁏", "bsim": "∽", "bsime": "⋍", "bsol": "\\", "bsolb": "⧅", "bsolhsub": "⟈", "bull": "•", "bullet": "•", "bump": "≎", "bumpe": "≏", "bumpE": "⪮", "bumpeq": "≏", "Bumpeq": "≎", "cacute": "ć", "Cacute": "Ć", "cap": "∩", "Cap": "⋒", "capand": "⩄", "capbrcup": "⩉", "capcap": "⩋", "capcup": "⩇", "capdot": "⩀", "CapitalDifferentialD": "ⅅ", "caps": "∩︀", "caret": "⁁", "caron": "ˇ", "Cayleys": "ℭ", "ccaps": "⩍", "ccaron": "č", "Ccaron": "Č", "ccedil": "ç", "Ccedil": "Ç", "ccirc": "ĉ", "Ccirc": "Ĉ", "Cconint": "∰", "ccups": "⩌", "ccupssm": "⩐", "cdot": "ċ", "Cdot": "Ċ", "cedil": "¸", "Cedilla": "¸", "cemptyv": "⦲", "cent": "¢", "centerdot": "·", "CenterDot": "·", "cfr": "𝔠", "Cfr": "ℭ", "chcy": "ч", "CHcy": "Ч", "check": "✓", "checkmark": "✓", "chi": "χ", "Chi": "Χ", "cir": "○", "circ": "ˆ", "circeq": "≗", "circlearrowleft": "↺", "circlearrowright": "↻", "circledast": "⊛", "circledcirc": "⊚", "circleddash": "⊝", "CircleDot": "⊙", "circledR": "®", "circledS": "Ⓢ", "CircleMinus": "⊖", "CirclePlus": "⊕", "CircleTimes": "⊗", "cire": "≗", "cirE": "⧃", "cirfnint": "⨐", "cirmid": "⫯", "cirscir": "⧂", "ClockwiseContourIntegral": "∲", "CloseCurlyDoubleQuote": "”", "CloseCurlyQuote": "’", "clubs": "♣", "clubsuit": "♣", "colon": ":", "Colon": "∷", "colone": "≔", "Colone": "⩴", "coloneq": "≔", "comma": ",", "commat": "@", "comp": "∁", "compfn": "∘", "complement": "∁", "complexes": "ℂ", "cong": "≅", "congdot": "⩭", "Congruent": "≡", "conint": "∮", "Conint": "∯", "ContourIntegral": "∮", "copf": "𝕔", "Copf": "ℂ", "coprod": "∐", "Coproduct": "∐", "copy": "©", "COPY": "©", "copysr": "℗", "CounterClockwiseContourIntegral": "∳", "crarr": "↵", "cross": "✗", "Cross": "⨯", "cscr": "𝒸", "Cscr": "𝒞", "csub": "⫏", "csube": "⫑", "csup": "⫐", "csupe": "⫒", "ctdot": "⋯", "cudarrl": "⤸", "cudarrr": "⤵", "cuepr": "⋞", "cuesc": "⋟", "cularr": "↶", "cularrp": "⤽", "cup": "∪", "Cup": "⋓", "cupbrcap": "⩈", "cupcap": "⩆", "CupCap": "≍", "cupcup": "⩊", "cupdot": "⊍", "cupor": "⩅", "cups": "∪︀", "curarr": "↷", "curarrm": "⤼", "curlyeqprec": "⋞", "curlyeqsucc": "⋟", "curlyvee": "⋎", "curlywedge": "⋏", "curren": "¤", "curvearrowleft": "↶", "curvearrowright": "↷", "cuvee": "⋎", "cuwed": "⋏", "cwconint": "∲", "cwint": "∱", "cylcty": "⌭", "dagger": "†", "Dagger": "‡", "daleth": "ℸ", "darr": "↓", "dArr": "⇓", "Darr": "↡", "dash": "‐", "dashv": "⊣", "Dashv": "⫤", "dbkarow": "⤏", "dblac": "˝", "dcaron": "ď", "Dcaron": "Ď", "dcy": "д", "Dcy": "Д", "dd": "ⅆ", "DD": "ⅅ", "ddagger": "‡", "ddarr": "⇊", "DDotrahd": "⤑", "ddotseq": "⩷", "deg": "°", "Del": "∇", "delta": "δ", "Delta": "Δ", "demptyv": "⦱", "dfisht": "⥿", "dfr": "𝔡", "Dfr": "𝔇", "dHar": "⥥", "dharl": "⇃", "dharr": "⇂", "DiacriticalAcute": "´", "DiacriticalDot": "˙", "DiacriticalDoubleAcute": "˝", "DiacriticalGrave": "`", "DiacriticalTilde": "˜", "diam": "⋄", "diamond": "⋄", "Diamond": "⋄", "diamondsuit": "♦", "diams": "♦", "die": "¨", "DifferentialD": "ⅆ", "digamma": "ϝ", "disin": "⋲", "div": "÷", "divide": "÷", "divideontimes": "⋇", "divonx": "⋇", "djcy": "ђ", "DJcy": "Ђ", "dlcorn": "⌞", "dlcrop": "⌍", "dollar": "$", "dopf": "𝕕", "Dopf": "𝔻", "dot": "˙", "Dot": "¨", "DotDot": "⃜", "doteq": "≐", "doteqdot": "≑", "DotEqual": "≐", "dotminus": "∸", "dotplus": "∔", "dotsquare": "⊡", "doublebarwedge": "⌆", "DoubleContourIntegral": "∯", "DoubleDot": "¨", "DoubleDownArrow": "⇓", "DoubleLeftArrow": "⇐", "DoubleLeftRightArrow": "⇔", "DoubleLeftTee": "⫤", "DoubleLongLeftArrow": "⟸", "DoubleLongLeftRightArrow": "⟺", "DoubleLongRightArrow": "⟹", "DoubleRightArrow": "⇒", "DoubleRightTee": "⊨", "DoubleUpArrow": "⇑", "DoubleUpDownArrow": "⇕", "DoubleVerticalBar": "∥", "downarrow": "↓", "Downarrow": "⇓", "DownArrow": "↓", "DownArrowBar": "⤓", "DownArrowUpArrow": "⇵", "DownBreve": "̑", "downdownarrows": "⇊", "downharpoonleft": "⇃", "downharpoonright": "⇂", "DownLeftRightVector": "⥐", "DownLeftTeeVector": "⥞", "DownLeftVector": "↽", "DownLeftVectorBar": "⥖", "DownRightTeeVector": "⥟", "DownRightVector": "⇁", "DownRightVectorBar": "⥗", "DownTee": "⊤", "DownTeeArrow": "↧", "drbkarow": "⤐", "drcorn": "⌟", "drcrop": "⌌", "dscr": "𝒹", "Dscr": "𝒟", "dscy": "ѕ", "DScy": "Ѕ", "dsol": "⧶", "dstrok": "đ", "Dstrok": "Đ", "dtdot": "⋱", "dtri": "▿", "dtrif": "▾", "duarr": "⇵", "duhar": "⥯", "dwangle": "⦦", "dzcy": "џ", "DZcy": "Џ", "dzigrarr": "⟿", "eacute": "é", "Eacute": "É", "easter": "⩮", "ecaron": "ě", "Ecaron": "Ě", "ecir": "≖", "ecirc": "ê", "Ecirc": "Ê", "ecolon": "≕", "ecy": "э", "Ecy": "Э", "eDDot": "⩷", "edot": "ė", "eDot": "≑", "Edot": "Ė", "ee": "ⅇ", "efDot": "≒", "efr": "𝔢", "Efr": "𝔈", "eg": "⪚", "egrave": "è", "Egrave": "È", "egs": "⪖", "egsdot": "⪘", "el": "⪙", "Element": "∈", "elinters": "⏧", "ell": "ℓ", "els": "⪕", "elsdot": "⪗", "emacr": "ē", "Emacr": "Ē", "empty": "∅", "emptyset": "∅", "EmptySmallSquare": "◻", "emptyv": "∅", "EmptyVerySmallSquare": "▫", "emsp": " ", "emsp13": " ", "emsp14": " ", "eng": "ŋ", "ENG": "Ŋ", "ensp": " ", "eogon": "ę", "Eogon": "Ę", "eopf": "𝕖", "Eopf": "𝔼", "epar": "⋕", "eparsl": "⧣", "eplus": "⩱", "epsi": "ε", "epsilon": "ε", "Epsilon": "Ε", "epsiv": "ϵ", "eqcirc": "≖", "eqcolon": "≕", "eqsim": "≂", "eqslantgtr": "⪖", "eqslantless": "⪕", "Equal": "⩵", "equals": "=", "EqualTilde": "≂", "equest": "≟", "Equilibrium": "⇌", "equiv": "≡", "equivDD": "⩸", "eqvparsl": "⧥", "erarr": "⥱", "erDot": "≓", "escr": "ℯ", "Escr": "ℰ", "esdot": "≐", "esim": "≂", "Esim": "⩳", "eta": "η", "Eta": "Η", "eth": "ð", "ETH": "Ð", "euml": "ë", "Euml": "Ë", "euro": "€", "excl": "!", "exist": "∃", "Exists": "∃", "expectation": "ℰ", "exponentiale": "ⅇ", "ExponentialE": "ⅇ", "fallingdotseq": "≒", "fcy": "ф", "Fcy": "Ф", "female": "♀", "ffilig": "ﬃ", "fflig": "ﬀ", "ffllig": "ﬄ", "ffr": "𝔣", "Ffr": "𝔉", "filig": "ﬁ", "FilledSmallSquare": "◼", "FilledVerySmallSquare": "▪", "fjlig": "fj", "flat": "♭", "fllig": "ﬂ", "fltns": "▱", "fnof": "ƒ", "fopf": "𝕗", "Fopf": "𝔽", "forall": "∀", "ForAll": "∀", "fork": "⋔", "forkv": "⫙", "Fouriertrf": "ℱ", "fpartint": "⨍", "frac12": "½", "frac13": "⅓", "frac14": "¼", "frac15": "⅕", "frac16": "⅙", "frac18": "⅛", "frac23": "⅔", "frac25": "⅖", "frac34": "¾", "frac35": "⅗", "frac38": "⅜", "frac45": "⅘", "frac56": "⅚", "frac58": "⅝", "frac78": "⅞", "frasl": "⁄", "frown": "⌢", "fscr": "𝒻", "Fscr": "ℱ", "gacute": "ǵ", "gamma": "γ", "Gamma": "Γ", "gammad": "ϝ", "Gammad": "Ϝ", "gap": "⪆", "gbreve": "ğ", "Gbreve": "Ğ", "Gcedil": "Ģ", "gcirc": "ĝ", "Gcirc": "Ĝ", "gcy": "г", "Gcy": "Г", "gdot": "ġ", "Gdot": "Ġ", "ge": "≥", "gE": "≧", "gel": "⋛", "gEl": "⪌", "geq": "≥", "geqq": "≧", "geqslant": "⩾", "ges": "⩾", "gescc": "⪩", "gesdot": "⪀", "gesdoto": "⪂", "gesdotol": "⪄", "gesl": "⋛︀", "gesles": "⪔", "gfr": "𝔤", "Gfr": "𝔊", "gg": "≫", "Gg": "⋙", "ggg": "⋙", "gimel": "ℷ", "gjcy": "ѓ", "GJcy": "Ѓ", "gl": "≷", "gla": "⪥", "glE": "⪒", "glj": "⪤", "gnap": "⪊", "gnapprox": "⪊", "gne": "⪈", "gnE": "≩", "gneq": "⪈", "gneqq": "≩", "gnsim": "⋧", "gopf": "𝕘", "Gopf": "𝔾", "grave": "`", "GreaterEqual": "≥", "GreaterEqualLess": "⋛", "GreaterFullEqual": "≧", "GreaterGreater": "⪢", "GreaterLess": "≷", "GreaterSlantEqual": "⩾", "GreaterTilde": "≳", "gscr": "ℊ", "Gscr": "𝒢", "gsim": "≳", "gsime": "⪎", "gsiml": "⪐", "gt": ">", "Gt": "≫", "GT": ">", "gtcc": "⪧", "gtcir": "⩺", "gtdot": "⋗", "gtlPar": "⦕", "gtquest": "⩼", "gtrapprox": "⪆", "gtrarr": "⥸", "gtrdot": "⋗", "gtreqless": "⋛", "gtreqqless": "⪌", "gtrless": "≷", "gtrsim": "≳", "gvertneqq": "≩︀", "gvnE": "≩︀", "Hacek": "ˇ", "hairsp": " ", "half": "½", "hamilt": "ℋ", "hardcy": "ъ", "HARDcy": "Ъ", "harr": "↔", "hArr": "⇔", "harrcir": "⥈", "harrw": "↭", "Hat": "^", "hbar": "ℏ", "hcirc": "ĥ", "Hcirc": "Ĥ", "hearts": "♥", "heartsuit": "♥", "hellip": "…", "hercon": "⊹", "hfr": "𝔥", "Hfr": "ℌ", "HilbertSpace": "ℋ", "hksearow": "⤥", "hkswarow": "⤦", "hoarr": "⇿", "homtht": "∻", "hookleftarrow": "↩", "hookrightarrow": "↪", "hopf": "𝕙", "Hopf": "ℍ", "horbar": "―", "HorizontalLine": "─", "hscr": "𝒽", "Hscr": "ℋ", "hslash": "ℏ", "hstrok": "ħ", "Hstrok": "Ħ", "HumpDownHump": "≎", "HumpEqual": "≏", "hybull": "⁃", "hyphen": "‐", "iacute": "í", "Iacute": "Í", "ic": "⁣", "icirc": "î", "Icirc": "Î", "icy": "и", "Icy": "И", "Idot": "İ", "iecy": "е", "IEcy": "Е", "iexcl": "¡", "iff": "⇔", "ifr": "𝔦", "Ifr": "ℑ", "igrave": "ì", "Igrave": "Ì", "ii": "ⅈ", "iiiint": "⨌", "iiint": "∭", "iinfin": "⧜", "iiota": "℩", "ijlig": "ĳ", "IJlig": "Ĳ", "Im": "ℑ", "imacr": "ī", "Imacr": "Ī", "image": "ℑ", "ImaginaryI": "ⅈ", "imagline": "ℐ", "imagpart": "ℑ", "imath": "ı", "imof": "⊷", "imped": "Ƶ", "Implies": "⇒", "in": "∈", "incare": "℅", "infin": "∞", "infintie": "⧝", "inodot": "ı", "int": "∫", "Int": "∬", "intcal": "⊺", "integers": "ℤ", "Integral": "∫", "intercal": "⊺", "Intersection": "⋂", "intlarhk": "⨗", "intprod": "⨼", "InvisibleComma": "⁣", "InvisibleTimes": "⁢", "iocy": "ё", "IOcy": "Ё", "iogon": "į", "Iogon": "Į", "iopf": "𝕚", "Iopf": "𝕀", "iota": "ι", "Iota": "Ι", "iprod": "⨼", "iquest": "¿", "iscr": "𝒾", "Iscr": "ℐ", "isin": "∈", "isindot": "⋵", "isinE": "⋹", "isins": "⋴", "isinsv": "⋳", "isinv": "∈", "it": "⁢", "itilde": "ĩ", "Itilde": "Ĩ", "iukcy": "і", "Iukcy": "І", "iuml": "ï", "Iuml": "Ï", "jcirc": "ĵ", "Jcirc": "Ĵ", "jcy": "й", "Jcy": "Й", "jfr": "𝔧", "Jfr": "𝔍", "jmath": "ȷ", "jopf": "𝕛", "Jopf": "𝕁", "jscr": "𝒿", "Jscr": "𝒥", "jsercy": "ј", "Jsercy": "Ј", "jukcy": "є", "Jukcy": "Є", "kappa": "κ", "Kappa": "Κ", "kappav": "ϰ", "kcedil": "ķ", "Kcedil": "Ķ", "kcy": "к", "Kcy": "К", "kfr": "𝔨", "Kfr": "𝔎", "kgreen": "ĸ", "khcy": "х", "KHcy": "Х", "kjcy": "ќ", "KJcy": "Ќ", "kopf": "𝕜", "Kopf": "𝕂", "kscr": "𝓀", "Kscr": "𝒦", "lAarr": "⇚", "lacute": "ĺ", "Lacute": "Ĺ", "laemptyv": "⦴", "lagran": "ℒ", "lambda": "λ", "Lambda": "Λ", "lang": "⟨", "Lang": "⟪", "langd": "⦑", "langle": "⟨", "lap": "⪅", "Laplacetrf": "ℒ", "laquo": "«", "larr": "←", "lArr": "⇐", "Larr": "↞", "larrb": "⇤", "larrbfs": "⤟", "larrfs": "⤝", "larrhk": "↩", "larrlp": "↫", "larrpl": "⤹", "larrsim": "⥳", "larrtl": "↢", "lat": "⪫", "latail": "⤙", "lAtail": "⤛", "late": "⪭", "lates": "⪭︀", "lbarr": "⤌", "lBarr": "⤎", "lbbrk": "❲", "lbrace": "{", "lbrack": "[", "lbrke": "⦋", "lbrksld": "⦏", "lbrkslu": "⦍", "lcaron": "ľ", "Lcaron": "Ľ", "lcedil": "ļ", "Lcedil": "Ļ", "lceil": "⌈", "lcub": "{", "lcy": "л", "Lcy": "Л", "ldca": "⤶", "ldquo": "“", "ldquor": "„", "ldrdhar": "⥧", "ldrushar": "⥋", "ldsh": "↲", "le": "≤", "lE": "≦", "LeftAngleBracket": "⟨", "leftarrow": "←", "Leftarrow": "⇐", "LeftArrow": "←", "LeftArrowBar": "⇤", "LeftArrowRightArrow": "⇆", "leftarrowtail": "↢", "LeftCeiling": "⌈", "LeftDoubleBracket": "⟦", "LeftDownTeeVector": "⥡", "LeftDownVector": "⇃", "LeftDownVectorBar": "⥙", "LeftFloor": "⌊", "leftharpoondown": "↽", "leftharpoonup": "↼", "leftleftarrows": "⇇", "leftrightarrow": "↔", "Leftrightarrow": "⇔", "LeftRightArrow": "↔", "leftrightarrows": "⇆", "leftrightharpoons": "⇋", "leftrightsquigarrow": "↭", "LeftRightVector": "⥎", "LeftTee": "⊣", "LeftTeeArrow": "↤", "LeftTeeVector": "⥚", "leftthreetimes": "⋋", "LeftTriangle": "⊲", "LeftTriangleBar": "⧏", "LeftTriangleEqual": "⊴", "LeftUpDownVector": "⥑", "LeftUpTeeVector": "⥠", "LeftUpVector": "↿", "LeftUpVectorBar": "⥘", "LeftVector": "↼", "LeftVectorBar": "⥒", "leg": "⋚", "lEg": "⪋", "leq": "≤", "leqq": "≦", "leqslant": "⩽", "les": "⩽", "lescc": "⪨", "lesdot": "⩿", "lesdoto": "⪁", "lesdotor": "⪃", "lesg": "⋚︀", "lesges": "⪓", "lessapprox": "⪅", "lessdot": "⋖", "lesseqgtr": "⋚", "lesseqqgtr": "⪋", "LessEqualGreater": "⋚", "LessFullEqual": "≦", "LessGreater": "≶", "lessgtr": "≶", "LessLess": "⪡", "lesssim": "≲", "LessSlantEqual": "⩽", "LessTilde": "≲", "lfisht": "⥼", "lfloor": "⌊", "lfr": "𝔩", "Lfr": "𝔏", "lg": "≶", "lgE": "⪑", "lHar": "⥢", "lhard": "↽", "lharu": "↼", "lharul": "⥪", "lhblk": "▄", "ljcy": "љ", "LJcy": "Љ", "ll": "≪", "Ll": "⋘", "llarr": "⇇", "llcorner": "⌞", "Lleftarrow": "⇚", "llhard": "⥫", "lltri": "◺", "lmidot": "ŀ", "Lmidot": "Ŀ", "lmoust": "⎰", "lmoustache": "⎰", "lnap": "⪉", "lnapprox": "⪉", "lne": "⪇", "lnE": "≨", "lneq": "⪇", "lneqq": "≨", "lnsim": "⋦", "loang": "⟬", "loarr": "⇽", "lobrk": "⟦", "longleftarrow": "⟵", "Longleftarrow": "⟸", "LongLeftArrow": "⟵", "longleftrightarrow": "⟷", "Longleftrightarrow": "⟺", "LongLeftRightArrow": "⟷", "longmapsto": "⟼", "longrightarrow": "⟶", "Longrightarrow": "⟹", "LongRightArrow": "⟶", "looparrowleft": "↫", "looparrowright": "↬", "lopar": "⦅", "lopf": "𝕝", "Lopf": "𝕃", "loplus": "⨭", "lotimes": "⨴", "lowast": "∗", "lowbar": "_", "LowerLeftArrow": "↙", "LowerRightArrow": "↘", "loz": "◊", "lozenge": "◊", "lozf": "⧫", "lpar": "(", "lparlt": "⦓", "lrarr": "⇆", "lrcorner": "⌟", "lrhar": "⇋", "lrhard": "⥭", "lrm": "‎", "lrtri": "⊿", "lsaquo": "‹", "lscr": "𝓁", "Lscr": "ℒ", "lsh": "↰", "Lsh": "↰", "lsim": "≲", "lsime": "⪍", "lsimg": "⪏", "lsqb": "[", "lsquo": "‘", "lsquor": "‚", "lstrok": "ł", "Lstrok": "Ł", "lt": "<", "Lt": "≪", "LT": "<", "ltcc": "⪦", "ltcir": "⩹", "ltdot": "⋖", "lthree": "⋋", "ltimes": "⋉", "ltlarr": "⥶", "ltquest": "⩻", "ltri": "◃", "ltrie": "⊴", "ltrif": "◂", "ltrPar": "⦖", "lurdshar": "⥊", "luruhar": "⥦", "lvertneqq": "≨︀", "lvnE": "≨︀", "macr": "¯", "male": "♂", "malt": "✠", "maltese": "✠", "map": "↦", "Map": "⤅", "mapsto": "↦", "mapstodown": "↧", "mapstoleft": "↤", "mapstoup": "↥", "marker": "▮", "mcomma": "⨩", "mcy": "м", "Mcy": "М", "mdash": "—", "mDDot": "∺", "measuredangle": "∡", "MediumSpace": " ", "Mellintrf": "ℳ", "mfr": "𝔪", "Mfr": "𝔐", "mho": "℧", "micro": "µ", "mid": "∣", "midast": "*", "midcir": "⫰", "middot": "·", "minus": "−", "minusb": "⊟", "minusd": "∸", "minusdu": "⨪", "MinusPlus": "∓", "mlcp": "⫛", "mldr": "…", "mnplus": "∓", "models": "⊧", "mopf": "𝕞", "Mopf": "𝕄", "mp": "∓", "mscr": "𝓂", "Mscr": "ℳ", "mstpos": "∾", "mu": "μ", "Mu": "Μ", "multimap": "⊸", "mumap": "⊸", "nabla": "∇", "nacute": "ń", "Nacute": "Ń", "nang": "∠⃒", "nap": "≉", "napE": "⩰̸", "napid": "≋̸", "napos": "ŉ", "napprox": "≉", "natur": "♮", "natural": "♮", "naturals": "ℕ", "nbsp": " ", "nbump": "≎̸", "nbumpe": "≏̸", "ncap": "⩃", "ncaron": "ň", "Ncaron": "Ň", "ncedil": "ņ", "Ncedil": "Ņ", "ncong": "≇", "ncongdot": "⩭̸", "ncup": "⩂", "ncy": "н", "Ncy": "Н", "ndash": "–", "ne": "≠", "nearhk": "⤤", "nearr": "↗", "neArr": "⇗", "nearrow": "↗", "nedot": "≐̸", "NegativeMediumSpace": "​", "NegativeThickSpace": "​", "NegativeThinSpace": "​", "NegativeVeryThinSpace": "​", "nequiv": "≢", "nesear": "⤨", "nesim": "≂̸", "NestedGreaterGreater": "≫", "NestedLessLess": "≪", "NewLine": "\n", "nexist": "∄", "nexists": "∄", "nfr": "𝔫", "Nfr": "𝔑", "nge": "≱", "ngE": "≧̸", "ngeq": "≱", "ngeqq": "≧̸", "ngeqslant": "⩾̸", "nges": "⩾̸", "nGg": "⋙̸", "ngsim": "≵", "ngt": "≯", "nGt": "≫⃒", "ngtr": "≯", "nGtv": "≫̸", "nharr": "↮", "nhArr": "⇎", "nhpar": "⫲", "ni": "∋", "nis": "⋼", "nisd": "⋺", "niv": "∋", "njcy": "њ", "NJcy": "Њ", "nlarr": "↚", "nlArr": "⇍", "nldr": "‥", "nle": "≰", "nlE": "≦̸", "nleftarrow": "↚", "nLeftarrow": "⇍", "nleftrightarrow": "↮", "nLeftrightarrow": "⇎", "nleq": "≰", "nleqq": "≦̸", "nleqslant": "⩽̸", "nles": "⩽̸", "nless": "≮", "nLl": "⋘̸", "nlsim": "≴", "nlt": "≮", "nLt": "≪⃒", "nltri": "⋪", "nltrie": "⋬", "nLtv": "≪̸", "nmid": "∤", "NoBreak": "⁠", "NonBreakingSpace": " ", "nopf": "𝕟", "Nopf": "ℕ", "not": "¬", "Not": "⫬", "NotCongruent": "≢", "NotCupCap": "≭", "NotDoubleVerticalBar": "∦", "NotElement": "∉", "NotEqual": "≠", "NotEqualTilde": "≂̸", "NotExists": "∄", "NotGreater": "≯", "NotGreaterEqual": "≱", "NotGreaterFullEqual": "≧̸", "NotGreaterGreater": "≫̸", "NotGreaterLess": "≹", "NotGreaterSlantEqual": "⩾̸", "NotGreaterTilde": "≵", "NotHumpDownHump": "≎̸", "NotHumpEqual": "≏̸", "notin": "∉", "notindot": "⋵̸", "notinE": "⋹̸", "notinva": "∉", "notinvb": "⋷", "notinvc": "⋶", "NotLeftTriangle": "⋪", "NotLeftTriangleBar": "⧏̸", "NotLeftTriangleEqual": "⋬", "NotLess": "≮", "NotLessEqual": "≰", "NotLessGreater": "≸", "NotLessLess": "≪̸", "NotLessSlantEqual": "⩽̸", "NotLessTilde": "≴", "NotNestedGreaterGreater": "⪢̸", "NotNestedLessLess": "⪡̸", "notni": "∌", "notniva": "∌", "notnivb": "⋾", "notnivc": "⋽", "NotPrecedes": "⊀", "NotPrecedesEqual": "⪯̸", "NotPrecedesSlantEqual": "⋠", "NotReverseElement": "∌", "NotRightTriangle": "⋫", "NotRightTriangleBar": "⧐̸", "NotRightTriangleEqual": "⋭", "NotSquareSubset": "⊏̸", "NotSquareSubsetEqual": "⋢", "NotSquareSuperset": "⊐̸", "NotSquareSupersetEqual": "⋣", "NotSubset": "⊂⃒", "NotSubsetEqual": "⊈", "NotSucceeds": "⊁", "NotSucceedsEqual": "⪰̸", "NotSucceedsSlantEqual": "⋡", "NotSucceedsTilde": "≿̸", "NotSuperset": "⊃⃒", "NotSupersetEqual": "⊉", "NotTilde": "≁", "NotTildeEqual": "≄", "NotTildeFullEqual": "≇", "NotTildeTilde": "≉", "NotVerticalBar": "∤", "npar": "∦", "nparallel": "∦", "nparsl": "⫽⃥", "npart": "∂̸", "npolint": "⨔", "npr": "⊀", "nprcue": "⋠", "npre": "⪯̸", "nprec": "⊀", "npreceq": "⪯̸", "nrarr": "↛", "nrArr": "⇏", "nrarrc": "⤳̸", "nrarrw": "↝̸", "nrightarrow": "↛", "nRightarrow": "⇏", "nrtri": "⋫", "nrtrie": "⋭", "nsc": "⊁", "nsccue": "⋡", "nsce": "⪰̸", "nscr": "𝓃", "Nscr": "𝒩", "nshortmid": "∤", "nshortparallel": "∦", "nsim": "≁", "nsime": "≄", "nsimeq": "≄", "nsmid": "∤", "nspar": "∦", "nsqsube": "⋢", "nsqsupe": "⋣", "nsub": "⊄", "nsube": "⊈", "nsubE": "⫅̸", "nsubset": "⊂⃒", "nsubseteq": "⊈", "nsubseteqq": "⫅̸", "nsucc": "⊁", "nsucceq": "⪰̸", "nsup": "⊅", "nsupe": "⊉", "nsupE": "⫆̸", "nsupset": "⊃⃒", "nsupseteq": "⊉", "nsupseteqq": "⫆̸", "ntgl": "≹", "ntilde": "ñ", "Ntilde": "Ñ", "ntlg": "≸", "ntriangleleft": "⋪", "ntrianglelefteq": "⋬", "ntriangleright": "⋫", "ntrianglerighteq": "⋭", "nu": "ν", "Nu": "Ν", "num": "#", "numero": "№", "numsp": " ", "nvap": "≍⃒", "nvdash": "⊬", "nvDash": "⊭", "nVdash": "⊮", "nVDash": "⊯", "nvge": "≥⃒", "nvgt": ">⃒", "nvHarr": "⤄", "nvinfin": "⧞", "nvlArr": "⤂", "nvle": "≤⃒", "nvlt": "<⃒", "nvltrie": "⊴⃒", "nvrArr": "⤃", "nvrtrie": "⊵⃒", "nvsim": "∼⃒", "nwarhk": "⤣", "nwarr": "↖", "nwArr": "⇖", "nwarrow": "↖", "nwnear": "⤧", "oacute": "ó", "Oacute": "Ó", "oast": "⊛", "ocir": "⊚", "ocirc": "ô", "Ocirc": "Ô", "ocy": "о", "Ocy": "О", "odash": "⊝", "odblac": "ő", "Odblac": "Ő", "odiv": "⨸", "odot": "⊙", "odsold": "⦼", "oelig": "œ", "OElig": "Œ", "ofcir": "⦿", "ofr": "𝔬", "Ofr": "𝔒", "ogon": "˛", "ograve": "ò", "Ograve": "Ò", "ogt": "⧁", "ohbar": "⦵", "ohm": "Ω", "oint": "∮", "olarr": "↺", "olcir": "⦾", "olcross": "⦻", "oline": "‾", "olt": "⧀", "omacr": "ō", "Omacr": "Ō", "omega": "ω", "Omega": "Ω", "omicron": "ο", "Omicron": "Ο", "omid": "⦶", "ominus": "⊖", "oopf": "𝕠", "Oopf": "𝕆", "opar": "⦷", "OpenCurlyDoubleQuote": "“", "OpenCurlyQuote": "‘", "operp": "⦹", "oplus": "⊕", "or": "∨", "Or": "⩔", "orarr": "↻", "ord": "⩝", "order": "ℴ", "orderof": "ℴ", "ordf": "ª", "ordm": "º", "origof": "⊶", "oror": "⩖", "orslope": "⩗", "orv": "⩛", "oS": "Ⓢ", "oscr": "ℴ", "Oscr": "𝒪", "oslash": "ø", "Oslash": "Ø", "osol": "⊘", "otilde": "õ", "Otilde": "Õ", "otimes": "⊗", "Otimes": "⨷", "otimesas": "⨶", "ouml": "ö", "Ouml": "Ö", "ovbar": "⌽", "OverBar": "‾", "OverBrace": "⏞", "OverBracket": "⎴", "OverParenthesis": "⏜", "par": "∥", "para": "¶", "parallel": "∥", "parsim": "⫳", "parsl": "⫽", "part": "∂", "PartialD": "∂", "pcy": "п", "Pcy": "П", "percnt": "%", "period": ".", "permil": "‰", "perp": "⊥", "pertenk": "‱", "pfr": "𝔭", "Pfr": "𝔓", "phi": "φ", "Phi": "Φ", "phiv": "ϕ", "phmmat": "ℳ", "phone": "☎", "pi": "π", "Pi": "Π", "pitchfork": "⋔", "piv": "ϖ", "planck": "ℏ", "planckh": "ℎ", "plankv": "ℏ", "plus": "+", "plusacir": "⨣", "plusb": "⊞", "pluscir": "⨢", "plusdo": "∔", "plusdu": "⨥", "pluse": "⩲", "PlusMinus": "±", "plusmn": "±", "plussim": "⨦", "plustwo": "⨧", "pm": "±", "Poincareplane": "ℌ", "pointint": "⨕", "popf": "𝕡", "Popf": "ℙ", "pound": "£", "pr": "≺", "Pr": "⪻", "prap": "⪷", "prcue": "≼", "pre": "⪯", "prE": "⪳", "prec": "≺", "precapprox": "⪷", "preccurlyeq": "≼", "Precedes": "≺", "PrecedesEqual": "⪯", "PrecedesSlantEqual": "≼", "PrecedesTilde": "≾", "preceq": "⪯", "precnapprox": "⪹", "precneqq": "⪵", "precnsim": "⋨", "precsim": "≾", "prime": "′", "Prime": "″", "primes": "ℙ", "prnap": "⪹", "prnE": "⪵", "prnsim": "⋨", "prod": "∏", "Product": "∏", "profalar": "⌮", "profline": "⌒", "profsurf": "⌓", "prop": "∝", "Proportion": "∷", "Proportional": "∝", "propto": "∝", "prsim": "≾", "prurel": "⊰", "pscr": "𝓅", "Pscr": "𝒫", "psi": "ψ", "Psi": "Ψ", "puncsp": " ", "qfr": "𝔮", "Qfr": "𝔔", "qint": "⨌", "qopf": "𝕢", "Qopf": "ℚ", "qprime": "⁗", "qscr": "𝓆", "Qscr": "𝒬", "quaternions": "ℍ", "quatint": "⨖", "quest": "?", "questeq": "≟", "quot": '"', "QUOT": '"', "rAarr": "⇛", "race": "∽̱", "racute": "ŕ", "Racute": "Ŕ", "radic": "√", "raemptyv": "⦳", "rang": "⟩", "Rang": "⟫", "rangd": "⦒", "range": "⦥", "rangle": "⟩", "raquo": "»", "rarr": "→", "rArr": "⇒", "Rarr": "↠", "rarrap": "⥵", "rarrb": "⇥", "rarrbfs": "⤠", "rarrc": "⤳", "rarrfs": "⤞", "rarrhk": "↪", "rarrlp": "↬", "rarrpl": "⥅", "rarrsim": "⥴", "rarrtl": "↣", "Rarrtl": "⤖", "rarrw": "↝", "ratail": "⤚", "rAtail": "⤜", "ratio": "∶", "rationals": "ℚ", "rbarr": "⤍", "rBarr": "⤏", "RBarr": "⤐", "rbbrk": "❳", "rbrace": "}", "rbrack": "]", "rbrke": "⦌", "rbrksld": "⦎", "rbrkslu": "⦐", "rcaron": "ř", "Rcaron": "Ř", "rcedil": "ŗ", "Rcedil": "Ŗ", "rceil": "⌉", "rcub": "}", "rcy": "р", "Rcy": "Р", "rdca": "⤷", "rdldhar": "⥩", "rdquo": "”", "rdquor": "”", "rdsh": "↳", "Re": "ℜ", "real": "ℜ", "realine": "ℛ", "realpart": "ℜ", "reals": "ℝ", "rect": "▭", "reg": "®", "REG": "®", "ReverseElement": "∋", "ReverseEquilibrium": "⇋", "ReverseUpEquilibrium": "⥯", "rfisht": "⥽", "rfloor": "⌋", "rfr": "𝔯", "Rfr": "ℜ", "rHar": "⥤", "rhard": "⇁", "rharu": "⇀", "rharul": "⥬", "rho": "ρ", "Rho": "Ρ", "rhov": "ϱ", "RightAngleBracket": "⟩", "rightarrow": "→", "Rightarrow": "⇒", "RightArrow": "→", "RightArrowBar": "⇥", "RightArrowLeftArrow": "⇄", "rightarrowtail": "↣", "RightCeiling": "⌉", "RightDoubleBracket": "⟧", "RightDownTeeVector": "⥝", "RightDownVector": "⇂", "RightDownVectorBar": "⥕", "RightFloor": "⌋", "rightharpoondown": "⇁", "rightharpoonup": "⇀", "rightleftarrows": "⇄", "rightleftharpoons": "⇌", "rightrightarrows": "⇉", "rightsquigarrow": "↝", "RightTee": "⊢", "RightTeeArrow": "↦", "RightTeeVector": "⥛", "rightthreetimes": "⋌", "RightTriangle": "⊳", "RightTriangleBar": "⧐", "RightTriangleEqual": "⊵", "RightUpDownVector": "⥏", "RightUpTeeVector": "⥜", "RightUpVector": "↾", "RightUpVectorBar": "⥔", "RightVector": "⇀", "RightVectorBar": "⥓", "ring": "˚", "risingdotseq": "≓", "rlarr": "⇄", "rlhar": "⇌", "rlm": "‏", "rmoust": "⎱", "rmoustache": "⎱", "rnmid": "⫮", "roang": "⟭", "roarr": "⇾", "robrk": "⟧", "ropar": "⦆", "ropf": "𝕣", "Ropf": "ℝ", "roplus": "⨮", "rotimes": "⨵", "RoundImplies": "⥰", "rpar": ")", "rpargt": "⦔", "rppolint": "⨒", "rrarr": "⇉", "Rrightarrow": "⇛", "rsaquo": "›", "rscr": "𝓇", "Rscr": "ℛ", "rsh": "↱", "Rsh": "↱", "rsqb": "]", "rsquo": "’", "rsquor": "’", "rthree": "⋌", "rtimes": "⋊", "rtri": "▹", "rtrie": "⊵", "rtrif": "▸", "rtriltri": "⧎", "RuleDelayed": "⧴", "ruluhar": "⥨", "rx": "℞", "sacute": "ś", "Sacute": "Ś", "sbquo": "‚", "sc": "≻", "Sc": "⪼", "scap": "⪸", "scaron": "š", "Scaron": "Š", "sccue": "≽", "sce": "⪰", "scE": "⪴", "scedil": "ş", "Scedil": "Ş", "scirc": "ŝ", "Scirc": "Ŝ", "scnap": "⪺", "scnE": "⪶", "scnsim": "⋩", "scpolint": "⨓", "scsim": "≿", "scy": "с", "Scy": "С", "sdot": "⋅", "sdotb": "⊡", "sdote": "⩦", "searhk": "⤥", "searr": "↘", "seArr": "⇘", "searrow": "↘", "sect": "§", "semi": ";", "seswar": "⤩", "setminus": "∖", "setmn": "∖", "sext": "✶", "sfr": "𝔰", "Sfr": "𝔖", "sfrown": "⌢", "sharp": "♯", "shchcy": "щ", "SHCHcy": "Щ", "shcy": "ш", "SHcy": "Ш", "ShortDownArrow": "↓", "ShortLeftArrow": "←", "shortmid": "∣", "shortparallel": "∥", "ShortRightArrow": "→", "ShortUpArrow": "↑", "shy": "­", "sigma": "σ", "Sigma": "Σ", "sigmaf": "ς", "sigmav": "ς", "sim": "∼", "simdot": "⩪", "sime": "≃", "simeq": "≃", "simg": "⪞", "simgE": "⪠", "siml": "⪝", "simlE": "⪟", "simne": "≆", "simplus": "⨤", "simrarr": "⥲", "slarr": "←", "SmallCircle": "∘", "smallsetminus": "∖", "smashp": "⨳", "smeparsl": "⧤", "smid": "∣", "smile": "⌣", "smt": "⪪", "smte": "⪬", "smtes": "⪬︀", "softcy": "ь", "SOFTcy": "Ь", "sol": "/", "solb": "⧄", "solbar": "⌿", "sopf": "𝕤", "Sopf": "𝕊", "spades": "♠", "spadesuit": "♠", "spar": "∥", "sqcap": "⊓", "sqcaps": "⊓︀", "sqcup": "⊔", "sqcups": "⊔︀", "Sqrt": "√", "sqsub": "⊏", "sqsube": "⊑", "sqsubset": "⊏", "sqsubseteq": "⊑", "sqsup": "⊐", "sqsupe": "⊒", "sqsupset": "⊐", "sqsupseteq": "⊒", "squ": "□", "square": "□", "Square": "□", "SquareIntersection": "⊓", "SquareSubset": "⊏", "SquareSubsetEqual": "⊑", "SquareSuperset": "⊐", "SquareSupersetEqual": "⊒", "SquareUnion": "⊔", "squarf": "▪", "squf": "▪", "srarr": "→", "sscr": "𝓈", "Sscr": "𝒮", "ssetmn": "∖", "ssmile": "⌣", "sstarf": "⋆", "star": "☆", "Star": "⋆", "starf": "★", "straightepsilon": "ϵ", "straightphi": "ϕ", "strns": "¯", "sub": "⊂", "Sub": "⋐", "subdot": "⪽", "sube": "⊆", "subE": "⫅", "subedot": "⫃", "submult": "⫁", "subne": "⊊", "subnE": "⫋", "subplus": "⪿", "subrarr": "⥹", "subset": "⊂", "Subset": "⋐", "subseteq": "⊆", "subseteqq": "⫅", "SubsetEqual": "⊆", "subsetneq": "⊊", "subsetneqq": "⫋", "subsim": "⫇", "subsub": "⫕", "subsup": "⫓", "succ": "≻", "succapprox": "⪸", "succcurlyeq": "≽", "Succeeds": "≻", "SucceedsEqual": "⪰", "SucceedsSlantEqual": "≽", "SucceedsTilde": "≿", "succeq": "⪰", "succnapprox": "⪺", "succneqq": "⪶", "succnsim": "⋩", "succsim": "≿", "SuchThat": "∋", "sum": "∑", "Sum": "∑", "sung": "♪", "sup": "⊃", "Sup": "⋑", "sup1": "¹", "sup2": "²", "sup3": "³", "supdot": "⪾", "supdsub": "⫘", "supe": "⊇", "supE": "⫆", "supedot": "⫄", "Superset": "⊃", "SupersetEqual": "⊇", "suphsol": "⟉", "suphsub": "⫗", "suplarr": "⥻", "supmult": "⫂", "supne": "⊋", "supnE": "⫌", "supplus": "⫀", "supset": "⊃", "Supset": "⋑", "supseteq": "⊇", "supseteqq": "⫆", "supsetneq": "⊋", "supsetneqq": "⫌", "supsim": "⫈", "supsub": "⫔", "supsup": "⫖", "swarhk": "⤦", "swarr": "↙", "swArr": "⇙", "swarrow": "↙", "swnwar": "⤪", "szlig": "ß", "Tab": "	", "target": "⌖", "tau": "τ", "Tau": "Τ", "tbrk": "⎴", "tcaron": "ť", "Tcaron": "Ť", "tcedil": "ţ", "Tcedil": "Ţ", "tcy": "т", "Tcy": "Т", "tdot": "⃛", "telrec": "⌕", "tfr": "𝔱", "Tfr": "𝔗", "there4": "∴", "therefore": "∴", "Therefore": "∴", "theta": "θ", "Theta": "Θ", "thetasym": "ϑ", "thetav": "ϑ", "thickapprox": "≈", "thicksim": "∼", "ThickSpace": "  ", "thinsp": " ", "ThinSpace": " ", "thkap": "≈", "thksim": "∼", "thorn": "þ", "THORN": "Þ", "tilde": "˜", "Tilde": "∼", "TildeEqual": "≃", "TildeFullEqual": "≅", "TildeTilde": "≈", "times": "×", "timesb": "⊠", "timesbar": "⨱", "timesd": "⨰", "tint": "∭", "toea": "⤨", "top": "⊤", "topbot": "⌶", "topcir": "⫱", "topf": "𝕥", "Topf": "𝕋", "topfork": "⫚", "tosa": "⤩", "tprime": "‴", "trade": "™", "TRADE": "™", "triangle": "▵", "triangledown": "▿", "triangleleft": "◃", "trianglelefteq": "⊴", "triangleq": "≜", "triangleright": "▹", "trianglerighteq": "⊵", "tridot": "◬", "trie": "≜", "triminus": "⨺", "TripleDot": "⃛", "triplus": "⨹", "trisb": "⧍", "tritime": "⨻", "trpezium": "⏢", "tscr": "𝓉", "Tscr": "𝒯", "tscy": "ц", "TScy": "Ц", "tshcy": "ћ", "TSHcy": "Ћ", "tstrok": "ŧ", "Tstrok": "Ŧ", "twixt": "≬", "twoheadleftarrow": "↞", "twoheadrightarrow": "↠", "uacute": "ú", "Uacute": "Ú", "uarr": "↑", "uArr": "⇑", "Uarr": "↟", "Uarrocir": "⥉", "ubrcy": "ў", "Ubrcy": "Ў", "ubreve": "ŭ", "Ubreve": "Ŭ", "ucirc": "û", "Ucirc": "Û", "ucy": "у", "Ucy": "У", "udarr": "⇅", "udblac": "ű", "Udblac": "Ű", "udhar": "⥮", "ufisht": "⥾", "ufr": "𝔲", "Ufr": "𝔘", "ugrave": "ù", "Ugrave": "Ù", "uHar": "⥣", "uharl": "↿", "uharr": "↾", "uhblk": "▀", "ulcorn": "⌜", "ulcorner": "⌜", "ulcrop": "⌏", "ultri": "◸", "umacr": "ū", "Umacr": "Ū", "uml": "¨", "UnderBar": "_", "UnderBrace": "⏟", "UnderBracket": "⎵", "UnderParenthesis": "⏝", "Union": "⋃", "UnionPlus": "⊎", "uogon": "ų", "Uogon": "Ų", "uopf": "𝕦", "Uopf": "𝕌", "uparrow": "↑", "Uparrow": "⇑", "UpArrow": "↑", "UpArrowBar": "⤒", "UpArrowDownArrow": "⇅", "updownarrow": "↕", "Updownarrow": "⇕", "UpDownArrow": "↕", "UpEquilibrium": "⥮", "upharpoonleft": "↿", "upharpoonright": "↾", "uplus": "⊎", "UpperLeftArrow": "↖", "UpperRightArrow": "↗", "upsi": "υ", "Upsi": "ϒ", "upsih": "ϒ", "upsilon": "υ", "Upsilon": "Υ", "UpTee": "⊥", "UpTeeArrow": "↥", "upuparrows": "⇈", "urcorn": "⌝", "urcorner": "⌝", "urcrop": "⌎", "uring": "ů", "Uring": "Ů", "urtri": "◹", "uscr": "𝓊", "Uscr": "𝒰", "utdot": "⋰", "utilde": "ũ", "Utilde": "Ũ", "utri": "▵", "utrif": "▴", "uuarr": "⇈", "uuml": "ü", "Uuml": "Ü", "uwangle": "⦧", "vangrt": "⦜", "varepsilon": "ϵ", "varkappa": "ϰ", "varnothing": "∅", "varphi": "ϕ", "varpi": "ϖ", "varpropto": "∝", "varr": "↕", "vArr": "⇕", "varrho": "ϱ", "varsigma": "ς", "varsubsetneq": "⊊︀", "varsubsetneqq": "⫋︀", "varsupsetneq": "⊋︀", "varsupsetneqq": "⫌︀", "vartheta": "ϑ", "vartriangleleft": "⊲", "vartriangleright": "⊳", "vBar": "⫨", "Vbar": "⫫", "vBarv": "⫩", "vcy": "в", "Vcy": "В", "vdash": "⊢", "vDash": "⊨", "Vdash": "⊩", "VDash": "⊫", "Vdashl": "⫦", "vee": "∨", "Vee": "⋁", "veebar": "⊻", "veeeq": "≚", "vellip": "⋮", "verbar": "|", "Verbar": "‖", "vert": "|", "Vert": "‖", "VerticalBar": "∣", "VerticalLine": "|", "VerticalSeparator": "❘", "VerticalTilde": "≀", "VeryThinSpace": " ", "vfr": "𝔳", "Vfr": "𝔙", "vltri": "⊲", "vnsub": "⊂⃒", "vnsup": "⊃⃒", "vopf": "𝕧", "Vopf": "𝕍", "vprop": "∝", "vrtri": "⊳", "vscr": "𝓋", "Vscr": "𝒱", "vsubne": "⊊︀", "vsubnE": "⫋︀", "vsupne": "⊋︀", "vsupnE": "⫌︀", "Vvdash": "⊪", "vzigzag": "⦚", "wcirc": "ŵ", "Wcirc": "Ŵ", "wedbar": "⩟", "wedge": "∧", "Wedge": "⋀", "wedgeq": "≙", "weierp": "℘", "wfr": "𝔴", "Wfr": "𝔚", "wopf": "𝕨", "Wopf": "𝕎", "wp": "℘", "wr": "≀", "wreath": "≀", "wscr": "𝓌", "Wscr": "𝒲", "xcap": "⋂", "xcirc": "◯", "xcup": "⋃", "xdtri": "▽", "xfr": "𝔵", "Xfr": "𝔛", "xharr": "⟷", "xhArr": "⟺", "xi": "ξ", "Xi": "Ξ", "xlarr": "⟵", "xlArr": "⟸", "xmap": "⟼", "xnis": "⋻", "xodot": "⨀", "xopf": "𝕩", "Xopf": "𝕏", "xoplus": "⨁", "xotime": "⨂", "xrarr": "⟶", "xrArr": "⟹", "xscr": "𝓍", "Xscr": "𝒳", "xsqcup": "⨆", "xuplus": "⨄", "xutri": "△", "xvee": "⋁", "xwedge": "⋀", "yacute": "ý", "Yacute": "Ý", "yacy": "я", "YAcy": "Я", "ycirc": "ŷ", "Ycirc": "Ŷ", "ycy": "ы", "Ycy": "Ы", "yen": "¥", "yfr": "𝔶", "Yfr": "𝔜", "yicy": "ї", "YIcy": "Ї", "yopf": "𝕪", "Yopf": "𝕐", "yscr": "𝓎", "Yscr": "𝒴", "yucy": "ю", "YUcy": "Ю", "yuml": "ÿ", "Yuml": "Ÿ", "zacute": "ź", "Zacute": "Ź", "zcaron": "ž", "Zcaron": "Ž", "zcy": "з", "Zcy": "З", "zdot": "ż", "Zdot": "Ż", "zeetrf": "ℨ", "ZeroWidthSpace": "​", "zeta": "ζ", "Zeta": "Ζ", "zfr": "𝔷", "Zfr": "ℨ", "zhcy": "ж", "ZHcy": "Ж", "zigrarr": "⇝", "zopf": "𝕫", "Zopf": "ℤ", "zscr": "𝓏", "Zscr": "𝒵", "zwj": "‍", "zwnj": "‌" };
      var decodeMapLegacy = { "aacute": "á", "Aacute": "Á", "acirc": "â", "Acirc": "Â", "acute": "´", "aelig": "æ", "AElig": "Æ", "agrave": "à", "Agrave": "À", "amp": "&", "AMP": "&", "aring": "å", "Aring": "Å", "atilde": "ã", "Atilde": "Ã", "auml": "ä", "Auml": "Ä", "brvbar": "¦", "ccedil": "ç", "Ccedil": "Ç", "cedil": "¸", "cent": "¢", "copy": "©", "COPY": "©", "curren": "¤", "deg": "°", "divide": "÷", "eacute": "é", "Eacute": "É", "ecirc": "ê", "Ecirc": "Ê", "egrave": "è", "Egrave": "È", "eth": "ð", "ETH": "Ð", "euml": "ë", "Euml": "Ë", "frac12": "½", "frac14": "¼", "frac34": "¾", "gt": ">", "GT": ">", "iacute": "í", "Iacute": "Í", "icirc": "î", "Icirc": "Î", "iexcl": "¡", "igrave": "ì", "Igrave": "Ì", "iquest": "¿", "iuml": "ï", "Iuml": "Ï", "laquo": "«", "lt": "<", "LT": "<", "macr": "¯", "micro": "µ", "middot": "·", "nbsp": " ", "not": "¬", "ntilde": "ñ", "Ntilde": "Ñ", "oacute": "ó", "Oacute": "Ó", "ocirc": "ô", "Ocirc": "Ô", "ograve": "ò", "Ograve": "Ò", "ordf": "ª", "ordm": "º", "oslash": "ø", "Oslash": "Ø", "otilde": "õ", "Otilde": "Õ", "ouml": "ö", "Ouml": "Ö", "para": "¶", "plusmn": "±", "pound": "£", "quot": '"', "QUOT": '"', "raquo": "»", "reg": "®", "REG": "®", "sect": "§", "shy": "­", "sup1": "¹", "sup2": "²", "sup3": "³", "szlig": "ß", "thorn": "þ", "THORN": "Þ", "times": "×", "uacute": "ú", "Uacute": "Ú", "ucirc": "û", "Ucirc": "Û", "ugrave": "ù", "Ugrave": "Ù", "uml": "¨", "uuml": "ü", "Uuml": "Ü", "yacute": "ý", "Yacute": "Ý", "yen": "¥", "yuml": "ÿ" };
      var decodeMapNumeric = { "0": "�", "128": "€", "130": "‚", "131": "ƒ", "132": "„", "133": "…", "134": "†", "135": "‡", "136": "ˆ", "137": "‰", "138": "Š", "139": "‹", "140": "Œ", "142": "Ž", "145": "‘", "146": "’", "147": "“", "148": "”", "149": "•", "150": "–", "151": "—", "152": "˜", "153": "™", "154": "š", "155": "›", "156": "œ", "158": "ž", "159": "Ÿ" };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var has = function(object2, propertyName) {
        return hasOwnProperty.call(object2, propertyName);
      };
      var contains = function(array, value) {
        var index2 = -1;
        var length = array.length;
        while (++index2 < length) {
          if (array[index2] == value) {
            return true;
          }
        }
        return false;
      };
      var merge = function(options, defaults2) {
        if (!options) {
          return defaults2;
        }
        var result = {};
        var key2;
        for (key2 in defaults2) {
          result[key2] = has(options, key2) ? options[key2] : defaults2[key2];
        }
        return result;
      };
      var codePointToSymbol = function(codePoint, strict) {
        var output = "";
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          if (strict) {
            parseError("character reference outside the permissible Unicode range");
          }
          return "�";
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError("disallowed character reference");
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError("disallowed character reference");
        }
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function(codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      };
      var decEscape = function(codePoint) {
        return "&#" + codePoint + ";";
      };
      var parseError = function(message2) {
        throw Error("Parse error: " + message2);
      };
      var encode2 = function(string, options) {
        options = merge(options, encode2.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError("forbidden code point");
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function(symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
          string = string.replace(regexAsciiWhitelist, function(symbol) {
            if (useNamedReferences && has(encodeMap, symbol)) {
              return "&" + encodeMap[symbol] + ";";
            }
            return escapeBmpSymbol(symbol);
          });
          if (useNamedReferences) {
            string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
          }
          if (useNamedReferences) {
            string = string.replace(regexEncodeNonAscii, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        } else if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function($0) {
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
          return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      encode2.options = {
        "allowUnsafeSymbols": false,
        "encodeEverything": false,
        "strict": false,
        "useNamedReferences": false,
        "decimal": false
      };
      var decode2 = function(html2, options) {
        options = merge(options, decode2.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html2)) {
          parseError("malformed character reference");
        }
        return html2.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;
          if ($1) {
            reference = $1;
            return decodeMap[reference];
          }
          if ($2) {
            reference = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == "=") {
                parseError("`&` did not start a character reference");
              }
              return $0;
            } else {
              if (strict) {
                parseError(
                  "named character reference was not terminated by a semicolon"
                );
              }
              return decodeMapLegacy[reference] + (next || "");
            }
          }
          if ($4) {
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }
          if (strict) {
            parseError(
              "named character reference was not terminated by a semicolon"
            );
          }
          return $0;
        });
      };
      decode2.options = {
        "isAttributeValue": false,
        "strict": false
      };
      var escape = function(string) {
        return string.replace(regexEscape, function($0) {
          return escapeMap[$0];
        });
      };
      var he2 = {
        "version": "1.2.0",
        "encode": encode2,
        "decode": decode2,
        "escape": escape,
        "unescape": decode2
      };
      if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = he2;
        } else {
          for (var key in he2) {
            has(he2, key) && (freeExports[key] = he2[key]);
          }
        }
      } else {
        root.he = he2;
      }
    })(he);
  })(he$1, he$1.exports);
  return he$1.exports;
}
var lib$4 = {};
var Parser = {};
var Tokenizer = {};
var decode_codepoint = {};
const require$$0$1 = {
  "0": 65533,
  "128": 8364,
  "130": 8218,
  "131": 402,
  "132": 8222,
  "133": 8230,
  "134": 8224,
  "135": 8225,
  "136": 710,
  "137": 8240,
  "138": 352,
  "139": 8249,
  "140": 338,
  "142": 381,
  "145": 8216,
  "146": 8217,
  "147": 8220,
  "148": 8221,
  "149": 8226,
  "150": 8211,
  "151": 8212,
  "152": 732,
  "153": 8482,
  "154": 353,
  "155": 8250,
  "156": 339,
  "158": 382,
  "159": 376
};
var hasRequiredDecode_codepoint;
function requireDecode_codepoint() {
  if (hasRequiredDecode_codepoint) return decode_codepoint;
  hasRequiredDecode_codepoint = 1;
  var __importDefault = decode_codepoint && decode_codepoint.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(decode_codepoint, "__esModule", { value: true });
  var decode_json_1 = __importDefault(require$$0$1);
  var fromCodePoint = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.fromCodePoint || function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    }
  );
  function decodeCodePoint(codePoint) {
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return "�";
    }
    if (codePoint in decode_json_1.default) {
      codePoint = decode_json_1.default[codePoint];
    }
    return fromCodePoint(codePoint);
  }
  decode_codepoint.default = decodeCodePoint;
  return decode_codepoint;
}
const Aacute$1 = "Á";
const aacute$1 = "á";
const Abreve = "Ă";
const abreve = "ă";
const ac = "∾";
const acd = "∿";
const acE = "∾̳";
const Acirc$1 = "Â";
const acirc$1 = "â";
const acute$1 = "´";
const Acy = "А";
const acy = "а";
const AElig$1 = "Æ";
const aelig$1 = "æ";
const af = "⁡";
const Afr = "𝔄";
const afr = "𝔞";
const Agrave$1 = "À";
const agrave$1 = "à";
const alefsym = "ℵ";
const aleph = "ℵ";
const Alpha = "Α";
const alpha = "α";
const Amacr = "Ā";
const amacr = "ā";
const amalg = "⨿";
const amp$2 = "&";
const AMP$1 = "&";
const andand = "⩕";
const And = "⩓";
const and = "∧";
const andd = "⩜";
const andslope = "⩘";
const andv = "⩚";
const ang = "∠";
const ange = "⦤";
const angle = "∠";
const angmsdaa = "⦨";
const angmsdab = "⦩";
const angmsdac = "⦪";
const angmsdad = "⦫";
const angmsdae = "⦬";
const angmsdaf = "⦭";
const angmsdag = "⦮";
const angmsdah = "⦯";
const angmsd = "∡";
const angrt = "∟";
const angrtvb = "⊾";
const angrtvbd = "⦝";
const angsph = "∢";
const angst = "Å";
const angzarr = "⍼";
const Aogon = "Ą";
const aogon = "ą";
const Aopf = "𝔸";
const aopf = "𝕒";
const apacir = "⩯";
const ap = "≈";
const apE = "⩰";
const ape = "≊";
const apid = "≋";
const apos$1 = "'";
const ApplyFunction = "⁡";
const approx = "≈";
const approxeq = "≊";
const Aring$1 = "Å";
const aring$1 = "å";
const Ascr = "𝒜";
const ascr = "𝒶";
const Assign = "≔";
const ast = "*";
const asymp = "≈";
const asympeq = "≍";
const Atilde$1 = "Ã";
const atilde$1 = "ã";
const Auml$1 = "Ä";
const auml$1 = "ä";
const awconint = "∳";
const awint = "⨑";
const backcong = "≌";
const backepsilon = "϶";
const backprime = "‵";
const backsim = "∽";
const backsimeq = "⋍";
const Backslash = "∖";
const Barv = "⫧";
const barvee = "⊽";
const barwed = "⌅";
const Barwed = "⌆";
const barwedge = "⌅";
const bbrk = "⎵";
const bbrktbrk = "⎶";
const bcong = "≌";
const Bcy = "Б";
const bcy = "б";
const bdquo = "„";
const becaus = "∵";
const because = "∵";
const Because = "∵";
const bemptyv = "⦰";
const bepsi = "϶";
const bernou = "ℬ";
const Bernoullis = "ℬ";
const Beta = "Β";
const beta = "β";
const beth = "ℶ";
const between = "≬";
const Bfr = "𝔅";
const bfr = "𝔟";
const bigcap = "⋂";
const bigcirc = "◯";
const bigcup = "⋃";
const bigodot = "⨀";
const bigoplus = "⨁";
const bigotimes = "⨂";
const bigsqcup = "⨆";
const bigstar = "★";
const bigtriangledown = "▽";
const bigtriangleup = "△";
const biguplus = "⨄";
const bigvee = "⋁";
const bigwedge = "⋀";
const bkarow = "⤍";
const blacklozenge = "⧫";
const blacksquare = "▪";
const blacktriangle = "▴";
const blacktriangledown = "▾";
const blacktriangleleft = "◂";
const blacktriangleright = "▸";
const blank = "␣";
const blk12 = "▒";
const blk14 = "░";
const blk34 = "▓";
const block = "█";
const bne = "=⃥";
const bnequiv = "≡⃥";
const bNot = "⫭";
const bnot = "⌐";
const Bopf = "𝔹";
const bopf = "𝕓";
const bot = "⊥";
const bottom = "⊥";
const bowtie = "⋈";
const boxbox = "⧉";
const boxdl = "┐";
const boxdL = "╕";
const boxDl = "╖";
const boxDL = "╗";
const boxdr = "┌";
const boxdR = "╒";
const boxDr = "╓";
const boxDR = "╔";
const boxh = "─";
const boxH = "═";
const boxhd = "┬";
const boxHd = "╤";
const boxhD = "╥";
const boxHD = "╦";
const boxhu = "┴";
const boxHu = "╧";
const boxhU = "╨";
const boxHU = "╩";
const boxminus = "⊟";
const boxplus = "⊞";
const boxtimes = "⊠";
const boxul = "┘";
const boxuL = "╛";
const boxUl = "╜";
const boxUL = "╝";
const boxur = "└";
const boxuR = "╘";
const boxUr = "╙";
const boxUR = "╚";
const boxv = "│";
const boxV = "║";
const boxvh = "┼";
const boxvH = "╪";
const boxVh = "╫";
const boxVH = "╬";
const boxvl = "┤";
const boxvL = "╡";
const boxVl = "╢";
const boxVL = "╣";
const boxvr = "├";
const boxvR = "╞";
const boxVr = "╟";
const boxVR = "╠";
const bprime = "‵";
const breve = "˘";
const Breve = "˘";
const brvbar$1 = "¦";
const bscr = "𝒷";
const Bscr = "ℬ";
const bsemi = "⁏";
const bsim = "∽";
const bsime = "⋍";
const bsolb = "⧅";
const bsol = "\\";
const bsolhsub = "⟈";
const bull = "•";
const bullet = "•";
const bump = "≎";
const bumpE = "⪮";
const bumpe = "≏";
const Bumpeq = "≎";
const bumpeq = "≏";
const Cacute = "Ć";
const cacute = "ć";
const capand = "⩄";
const capbrcup = "⩉";
const capcap = "⩋";
const cap = "∩";
const Cap = "⋒";
const capcup = "⩇";
const capdot = "⩀";
const CapitalDifferentialD = "ⅅ";
const caps = "∩︀";
const caret$1 = "⁁";
const caron = "ˇ";
const Cayleys = "ℭ";
const ccaps = "⩍";
const Ccaron = "Č";
const ccaron = "č";
const Ccedil$1 = "Ç";
const ccedil$1 = "ç";
const Ccirc = "Ĉ";
const ccirc = "ĉ";
const Cconint = "∰";
const ccups = "⩌";
const ccupssm = "⩐";
const Cdot = "Ċ";
const cdot = "ċ";
const cedil$1 = "¸";
const Cedilla = "¸";
const cemptyv = "⦲";
const cent$1 = "¢";
const centerdot = "·";
const CenterDot = "·";
const cfr = "𝔠";
const Cfr = "ℭ";
const CHcy = "Ч";
const chcy = "ч";
const check = "✓";
const checkmark = "✓";
const Chi = "Χ";
const chi = "χ";
const circ = "ˆ";
const circeq = "≗";
const circlearrowleft = "↺";
const circlearrowright = "↻";
const circledast = "⊛";
const circledcirc = "⊚";
const circleddash = "⊝";
const CircleDot = "⊙";
const circledR = "®";
const circledS = "Ⓢ";
const CircleMinus = "⊖";
const CirclePlus = "⊕";
const CircleTimes = "⊗";
const cir = "○";
const cirE = "⧃";
const cire = "≗";
const cirfnint = "⨐";
const cirmid = "⫯";
const cirscir = "⧂";
const ClockwiseContourIntegral = "∲";
const CloseCurlyDoubleQuote = "”";
const CloseCurlyQuote = "’";
const clubs = "♣";
const clubsuit = "♣";
const colon = ":";
const Colon = "∷";
const Colone = "⩴";
const colone = "≔";
const coloneq = "≔";
const comma$1 = ",";
const commat = "@";
const comp = "∁";
const compfn = "∘";
const complement = "∁";
const complexes = "ℂ";
const cong = "≅";
const congdot = "⩭";
const Congruent = "≡";
const conint = "∮";
const Conint = "∯";
const ContourIntegral = "∮";
const copf = "𝕔";
const Copf = "ℂ";
const coprod = "∐";
const Coproduct = "∐";
const copy$1 = "©";
const COPY$1 = "©";
const copysr = "℗";
const CounterClockwiseContourIntegral = "∳";
const crarr = "↵";
const cross = "✗";
const Cross = "⨯";
const Cscr = "𝒞";
const cscr = "𝒸";
const csub = "⫏";
const csube = "⫑";
const csup = "⫐";
const csupe = "⫒";
const ctdot = "⋯";
const cudarrl = "⤸";
const cudarrr = "⤵";
const cuepr = "⋞";
const cuesc = "⋟";
const cularr = "↶";
const cularrp = "⤽";
const cupbrcap = "⩈";
const cupcap = "⩆";
const CupCap = "≍";
const cup = "∪";
const Cup = "⋓";
const cupcup = "⩊";
const cupdot = "⊍";
const cupor = "⩅";
const cups = "∪︀";
const curarr = "↷";
const curarrm = "⤼";
const curlyeqprec = "⋞";
const curlyeqsucc = "⋟";
const curlyvee = "⋎";
const curlywedge = "⋏";
const curren$1 = "¤";
const curvearrowleft = "↶";
const curvearrowright = "↷";
const cuvee = "⋎";
const cuwed = "⋏";
const cwconint = "∲";
const cwint = "∱";
const cylcty = "⌭";
const dagger = "†";
const Dagger = "‡";
const daleth = "ℸ";
const darr = "↓";
const Darr = "↡";
const dArr = "⇓";
const dash = "‐";
const Dashv = "⫤";
const dashv = "⊣";
const dbkarow = "⤏";
const dblac = "˝";
const Dcaron = "Ď";
const dcaron = "ď";
const Dcy = "Д";
const dcy = "д";
const ddagger = "‡";
const ddarr = "⇊";
const DD = "ⅅ";
const dd = "ⅆ";
const DDotrahd = "⤑";
const ddotseq = "⩷";
const deg$1 = "°";
const Del = "∇";
const Delta = "Δ";
const delta = "δ";
const demptyv = "⦱";
const dfisht = "⥿";
const Dfr = "𝔇";
const dfr = "𝔡";
const dHar = "⥥";
const dharl = "⇃";
const dharr = "⇂";
const DiacriticalAcute = "´";
const DiacriticalDot = "˙";
const DiacriticalDoubleAcute = "˝";
const DiacriticalGrave = "`";
const DiacriticalTilde = "˜";
const diam = "⋄";
const diamond = "⋄";
const Diamond = "⋄";
const diamondsuit = "♦";
const diams = "♦";
const die = "¨";
const DifferentialD = "ⅆ";
const digamma = "ϝ";
const disin = "⋲";
const div = "÷";
const divide$1 = "÷";
const divideontimes = "⋇";
const divonx = "⋇";
const DJcy = "Ђ";
const djcy = "ђ";
const dlcorn = "⌞";
const dlcrop = "⌍";
const dollar$1 = "$";
const Dopf = "𝔻";
const dopf = "𝕕";
const Dot = "¨";
const dot = "˙";
const DotDot = "⃜";
const doteq = "≐";
const doteqdot = "≑";
const DotEqual = "≐";
const dotminus = "∸";
const dotplus = "∔";
const dotsquare = "⊡";
const doublebarwedge = "⌆";
const DoubleContourIntegral = "∯";
const DoubleDot = "¨";
const DoubleDownArrow = "⇓";
const DoubleLeftArrow = "⇐";
const DoubleLeftRightArrow = "⇔";
const DoubleLeftTee = "⫤";
const DoubleLongLeftArrow = "⟸";
const DoubleLongLeftRightArrow = "⟺";
const DoubleLongRightArrow = "⟹";
const DoubleRightArrow = "⇒";
const DoubleRightTee = "⊨";
const DoubleUpArrow = "⇑";
const DoubleUpDownArrow = "⇕";
const DoubleVerticalBar = "∥";
const DownArrowBar = "⤓";
const downarrow = "↓";
const DownArrow = "↓";
const Downarrow = "⇓";
const DownArrowUpArrow = "⇵";
const DownBreve = "̑";
const downdownarrows = "⇊";
const downharpoonleft = "⇃";
const downharpoonright = "⇂";
const DownLeftRightVector = "⥐";
const DownLeftTeeVector = "⥞";
const DownLeftVectorBar = "⥖";
const DownLeftVector = "↽";
const DownRightTeeVector = "⥟";
const DownRightVectorBar = "⥗";
const DownRightVector = "⇁";
const DownTeeArrow = "↧";
const DownTee = "⊤";
const drbkarow = "⤐";
const drcorn = "⌟";
const drcrop = "⌌";
const Dscr = "𝒟";
const dscr = "𝒹";
const DScy = "Ѕ";
const dscy = "ѕ";
const dsol = "⧶";
const Dstrok = "Đ";
const dstrok = "đ";
const dtdot = "⋱";
const dtri = "▿";
const dtrif = "▾";
const duarr = "⇵";
const duhar = "⥯";
const dwangle = "⦦";
const DZcy = "Џ";
const dzcy = "џ";
const dzigrarr = "⟿";
const Eacute$1 = "É";
const eacute$1 = "é";
const easter = "⩮";
const Ecaron = "Ě";
const ecaron = "ě";
const Ecirc$1 = "Ê";
const ecirc$1 = "ê";
const ecir = "≖";
const ecolon = "≕";
const Ecy = "Э";
const ecy = "э";
const eDDot = "⩷";
const Edot = "Ė";
const edot = "ė";
const eDot = "≑";
const ee = "ⅇ";
const efDot = "≒";
const Efr = "𝔈";
const efr = "𝔢";
const eg = "⪚";
const Egrave$1 = "È";
const egrave$1 = "è";
const egs = "⪖";
const egsdot = "⪘";
const el = "⪙";
const Element = "∈";
const elinters = "⏧";
const ell = "ℓ";
const els = "⪕";
const elsdot = "⪗";
const Emacr = "Ē";
const emacr = "ē";
const empty = "∅";
const emptyset = "∅";
const EmptySmallSquare = "◻";
const emptyv = "∅";
const EmptyVerySmallSquare = "▫";
const emsp13 = " ";
const emsp14 = " ";
const emsp = " ";
const ENG = "Ŋ";
const eng = "ŋ";
const ensp = " ";
const Eogon = "Ę";
const eogon = "ę";
const Eopf = "𝔼";
const eopf = "𝕖";
const epar = "⋕";
const eparsl = "⧣";
const eplus = "⩱";
const epsi = "ε";
const Epsilon = "Ε";
const epsilon = "ε";
const epsiv = "ϵ";
const eqcirc = "≖";
const eqcolon = "≕";
const eqsim = "≂";
const eqslantgtr = "⪖";
const eqslantless = "⪕";
const Equal = "⩵";
const equals = "=";
const EqualTilde = "≂";
const equest = "≟";
const Equilibrium = "⇌";
const equiv = "≡";
const equivDD = "⩸";
const eqvparsl = "⧥";
const erarr = "⥱";
const erDot = "≓";
const escr = "ℯ";
const Escr = "ℰ";
const esdot = "≐";
const Esim = "⩳";
const esim = "≂";
const Eta = "Η";
const eta = "η";
const ETH$1 = "Ð";
const eth$1 = "ð";
const Euml$1 = "Ë";
const euml$1 = "ë";
const euro = "€";
const excl = "!";
const exist = "∃";
const Exists = "∃";
const expectation = "ℰ";
const exponentiale = "ⅇ";
const ExponentialE = "ⅇ";
const fallingdotseq = "≒";
const Fcy = "Ф";
const fcy = "ф";
const female = "♀";
const ffilig = "ﬃ";
const fflig = "ﬀ";
const ffllig = "ﬄ";
const Ffr = "𝔉";
const ffr = "𝔣";
const filig = "ﬁ";
const FilledSmallSquare = "◼";
const FilledVerySmallSquare = "▪";
const fjlig = "fj";
const flat = "♭";
const fllig = "ﬂ";
const fltns = "▱";
const fnof = "ƒ";
const Fopf = "𝔽";
const fopf = "𝕗";
const forall = "∀";
const ForAll = "∀";
const fork = "⋔";
const forkv = "⫙";
const Fouriertrf = "ℱ";
const fpartint = "⨍";
const frac12$1 = "½";
const frac13 = "⅓";
const frac14$1 = "¼";
const frac15 = "⅕";
const frac16 = "⅙";
const frac18 = "⅛";
const frac23 = "⅔";
const frac25 = "⅖";
const frac34$1 = "¾";
const frac35 = "⅗";
const frac38 = "⅜";
const frac45 = "⅘";
const frac56 = "⅚";
const frac58 = "⅝";
const frac78 = "⅞";
const frasl = "⁄";
const frown = "⌢";
const fscr = "𝒻";
const Fscr = "ℱ";
const gacute = "ǵ";
const Gamma = "Γ";
const gamma = "γ";
const Gammad = "Ϝ";
const gammad = "ϝ";
const gap = "⪆";
const Gbreve = "Ğ";
const gbreve = "ğ";
const Gcedil = "Ģ";
const Gcirc = "Ĝ";
const gcirc = "ĝ";
const Gcy = "Г";
const gcy = "г";
const Gdot = "Ġ";
const gdot = "ġ";
const ge = "≥";
const gE = "≧";
const gEl = "⪌";
const gel = "⋛";
const geq = "≥";
const geqq = "≧";
const geqslant = "⩾";
const gescc = "⪩";
const ges = "⩾";
const gesdot = "⪀";
const gesdoto = "⪂";
const gesdotol = "⪄";
const gesl = "⋛︀";
const gesles = "⪔";
const Gfr = "𝔊";
const gfr = "𝔤";
const gg = "≫";
const Gg = "⋙";
const ggg = "⋙";
const gimel = "ℷ";
const GJcy = "Ѓ";
const gjcy = "ѓ";
const gla = "⪥";
const gl = "≷";
const glE = "⪒";
const glj = "⪤";
const gnap = "⪊";
const gnapprox = "⪊";
const gne = "⪈";
const gnE = "≩";
const gneq = "⪈";
const gneqq = "≩";
const gnsim = "⋧";
const Gopf = "𝔾";
const gopf = "𝕘";
const grave = "`";
const GreaterEqual = "≥";
const GreaterEqualLess = "⋛";
const GreaterFullEqual = "≧";
const GreaterGreater = "⪢";
const GreaterLess = "≷";
const GreaterSlantEqual = "⩾";
const GreaterTilde = "≳";
const Gscr = "𝒢";
const gscr = "ℊ";
const gsim = "≳";
const gsime = "⪎";
const gsiml = "⪐";
const gtcc = "⪧";
const gtcir = "⩺";
const gt$3 = ">";
const GT$1 = ">";
const Gt = "≫";
const gtdot = "⋗";
const gtlPar = "⦕";
const gtquest = "⩼";
const gtrapprox = "⪆";
const gtrarr = "⥸";
const gtrdot = "⋗";
const gtreqless = "⋛";
const gtreqqless = "⪌";
const gtrless = "≷";
const gtrsim = "≳";
const gvertneqq = "≩︀";
const gvnE = "≩︀";
const Hacek = "ˇ";
const hairsp = " ";
const half = "½";
const hamilt = "ℋ";
const HARDcy = "Ъ";
const hardcy = "ъ";
const harrcir = "⥈";
const harr = "↔";
const hArr = "⇔";
const harrw = "↭";
const Hat = "^";
const hbar = "ℏ";
const Hcirc = "Ĥ";
const hcirc = "ĥ";
const hearts = "♥";
const heartsuit = "♥";
const hellip = "…";
const hercon = "⊹";
const hfr = "𝔥";
const Hfr = "ℌ";
const HilbertSpace = "ℋ";
const hksearow = "⤥";
const hkswarow = "⤦";
const hoarr = "⇿";
const homtht = "∻";
const hookleftarrow = "↩";
const hookrightarrow = "↪";
const hopf = "𝕙";
const Hopf = "ℍ";
const horbar = "―";
const HorizontalLine = "─";
const hscr = "𝒽";
const Hscr = "ℋ";
const hslash = "ℏ";
const Hstrok = "Ħ";
const hstrok = "ħ";
const HumpDownHump = "≎";
const HumpEqual = "≏";
const hybull = "⁃";
const hyphen = "‐";
const Iacute$1 = "Í";
const iacute$1 = "í";
const ic = "⁣";
const Icirc$1 = "Î";
const icirc$1 = "î";
const Icy = "И";
const icy = "и";
const Idot = "İ";
const IEcy = "Е";
const iecy = "е";
const iexcl$1 = "¡";
const iff = "⇔";
const ifr = "𝔦";
const Ifr = "ℑ";
const Igrave$1 = "Ì";
const igrave$1 = "ì";
const ii = "ⅈ";
const iiiint = "⨌";
const iiint = "∭";
const iinfin = "⧜";
const iiota = "℩";
const IJlig = "Ĳ";
const ijlig = "ĳ";
const Imacr = "Ī";
const imacr = "ī";
const image = "ℑ";
const ImaginaryI = "ⅈ";
const imagline = "ℐ";
const imagpart = "ℑ";
const imath = "ı";
const Im = "ℑ";
const imof = "⊷";
const imped = "Ƶ";
const Implies = "⇒";
const incare = "℅";
const infin = "∞";
const infintie = "⧝";
const inodot = "ı";
const intcal = "⊺";
const int = "∫";
const Int = "∬";
const integers = "ℤ";
const Integral = "∫";
const intercal = "⊺";
const Intersection = "⋂";
const intlarhk = "⨗";
const intprod = "⨼";
const InvisibleComma = "⁣";
const InvisibleTimes = "⁢";
const IOcy = "Ё";
const iocy = "ё";
const Iogon = "Į";
const iogon = "į";
const Iopf = "𝕀";
const iopf = "𝕚";
const Iota = "Ι";
const iota = "ι";
const iprod = "⨼";
const iquest$1 = "¿";
const iscr = "𝒾";
const Iscr = "ℐ";
const isin = "∈";
const isindot = "⋵";
const isinE = "⋹";
const isins = "⋴";
const isinsv = "⋳";
const isinv = "∈";
const it = "⁢";
const Itilde = "Ĩ";
const itilde = "ĩ";
const Iukcy = "І";
const iukcy = "і";
const Iuml$1 = "Ï";
const iuml$1 = "ï";
const Jcirc = "Ĵ";
const jcirc = "ĵ";
const Jcy = "Й";
const jcy = "й";
const Jfr = "𝔍";
const jfr = "𝔧";
const jmath = "ȷ";
const Jopf = "𝕁";
const jopf = "𝕛";
const Jscr = "𝒥";
const jscr = "𝒿";
const Jsercy = "Ј";
const jsercy = "ј";
const Jukcy = "Є";
const jukcy = "є";
const Kappa = "Κ";
const kappa = "κ";
const kappav = "ϰ";
const Kcedil = "Ķ";
const kcedil = "ķ";
const Kcy = "К";
const kcy = "к";
const Kfr = "𝔎";
const kfr = "𝔨";
const kgreen = "ĸ";
const KHcy = "Х";
const khcy = "х";
const KJcy = "Ќ";
const kjcy = "ќ";
const Kopf = "𝕂";
const kopf = "𝕜";
const Kscr = "𝒦";
const kscr = "𝓀";
const lAarr = "⇚";
const Lacute = "Ĺ";
const lacute = "ĺ";
const laemptyv = "⦴";
const lagran = "ℒ";
const Lambda = "Λ";
const lambda = "λ";
const lang = "⟨";
const Lang = "⟪";
const langd = "⦑";
const langle = "⟨";
const lap = "⪅";
const Laplacetrf = "ℒ";
const laquo$1 = "«";
const larrb = "⇤";
const larrbfs = "⤟";
const larr = "←";
const Larr = "↞";
const lArr = "⇐";
const larrfs = "⤝";
const larrhk = "↩";
const larrlp = "↫";
const larrpl = "⤹";
const larrsim = "⥳";
const larrtl = "↢";
const latail = "⤙";
const lAtail = "⤛";
const lat = "⪫";
const late = "⪭";
const lates = "⪭︀";
const lbarr = "⤌";
const lBarr = "⤎";
const lbbrk = "❲";
const lbrace = "{";
const lbrack = "[";
const lbrke = "⦋";
const lbrksld = "⦏";
const lbrkslu = "⦍";
const Lcaron = "Ľ";
const lcaron = "ľ";
const Lcedil = "Ļ";
const lcedil = "ļ";
const lceil = "⌈";
const lcub = "{";
const Lcy = "Л";
const lcy = "л";
const ldca = "⤶";
const ldquo = "“";
const ldquor = "„";
const ldrdhar = "⥧";
const ldrushar = "⥋";
const ldsh = "↲";
const le = "≤";
const lE = "≦";
const LeftAngleBracket = "⟨";
const LeftArrowBar = "⇤";
const leftarrow = "←";
const LeftArrow = "←";
const Leftarrow = "⇐";
const LeftArrowRightArrow = "⇆";
const leftarrowtail = "↢";
const LeftCeiling = "⌈";
const LeftDoubleBracket = "⟦";
const LeftDownTeeVector = "⥡";
const LeftDownVectorBar = "⥙";
const LeftDownVector = "⇃";
const LeftFloor = "⌊";
const leftharpoondown = "↽";
const leftharpoonup = "↼";
const leftleftarrows = "⇇";
const leftrightarrow = "↔";
const LeftRightArrow = "↔";
const Leftrightarrow = "⇔";
const leftrightarrows = "⇆";
const leftrightharpoons = "⇋";
const leftrightsquigarrow = "↭";
const LeftRightVector = "⥎";
const LeftTeeArrow = "↤";
const LeftTee = "⊣";
const LeftTeeVector = "⥚";
const leftthreetimes = "⋋";
const LeftTriangleBar = "⧏";
const LeftTriangle = "⊲";
const LeftTriangleEqual = "⊴";
const LeftUpDownVector = "⥑";
const LeftUpTeeVector = "⥠";
const LeftUpVectorBar = "⥘";
const LeftUpVector = "↿";
const LeftVectorBar = "⥒";
const LeftVector = "↼";
const lEg = "⪋";
const leg = "⋚";
const leq = "≤";
const leqq = "≦";
const leqslant = "⩽";
const lescc = "⪨";
const les = "⩽";
const lesdot = "⩿";
const lesdoto = "⪁";
const lesdotor = "⪃";
const lesg = "⋚︀";
const lesges = "⪓";
const lessapprox = "⪅";
const lessdot = "⋖";
const lesseqgtr = "⋚";
const lesseqqgtr = "⪋";
const LessEqualGreater = "⋚";
const LessFullEqual = "≦";
const LessGreater = "≶";
const lessgtr = "≶";
const LessLess = "⪡";
const lesssim = "≲";
const LessSlantEqual = "⩽";
const LessTilde = "≲";
const lfisht = "⥼";
const lfloor = "⌊";
const Lfr = "𝔏";
const lfr = "𝔩";
const lg = "≶";
const lgE = "⪑";
const lHar = "⥢";
const lhard = "↽";
const lharu = "↼";
const lharul = "⥪";
const lhblk = "▄";
const LJcy = "Љ";
const ljcy = "љ";
const llarr = "⇇";
const ll = "≪";
const Ll = "⋘";
const llcorner = "⌞";
const Lleftarrow = "⇚";
const llhard = "⥫";
const lltri = "◺";
const Lmidot = "Ŀ";
const lmidot = "ŀ";
const lmoustache = "⎰";
const lmoust = "⎰";
const lnap = "⪉";
const lnapprox = "⪉";
const lne = "⪇";
const lnE = "≨";
const lneq = "⪇";
const lneqq = "≨";
const lnsim = "⋦";
const loang = "⟬";
const loarr = "⇽";
const lobrk = "⟦";
const longleftarrow = "⟵";
const LongLeftArrow = "⟵";
const Longleftarrow = "⟸";
const longleftrightarrow = "⟷";
const LongLeftRightArrow = "⟷";
const Longleftrightarrow = "⟺";
const longmapsto = "⟼";
const longrightarrow = "⟶";
const LongRightArrow = "⟶";
const Longrightarrow = "⟹";
const looparrowleft = "↫";
const looparrowright = "↬";
const lopar = "⦅";
const Lopf = "𝕃";
const lopf = "𝕝";
const loplus = "⨭";
const lotimes = "⨴";
const lowast = "∗";
const lowbar = "_";
const LowerLeftArrow = "↙";
const LowerRightArrow = "↘";
const loz = "◊";
const lozenge = "◊";
const lozf = "⧫";
const lpar = "(";
const lparlt = "⦓";
const lrarr = "⇆";
const lrcorner = "⌟";
const lrhar = "⇋";
const lrhard = "⥭";
const lrm = "‎";
const lrtri = "⊿";
const lsaquo = "‹";
const lscr = "𝓁";
const Lscr = "ℒ";
const lsh = "↰";
const Lsh = "↰";
const lsim = "≲";
const lsime = "⪍";
const lsimg = "⪏";
const lsqb = "[";
const lsquo = "‘";
const lsquor = "‚";
const Lstrok = "Ł";
const lstrok = "ł";
const ltcc = "⪦";
const ltcir = "⩹";
const lt$2 = "<";
const LT$1 = "<";
const Lt = "≪";
const ltdot = "⋖";
const lthree = "⋋";
const ltimes = "⋉";
const ltlarr = "⥶";
const ltquest = "⩻";
const ltri = "◃";
const ltrie = "⊴";
const ltrif = "◂";
const ltrPar = "⦖";
const lurdshar = "⥊";
const luruhar = "⥦";
const lvertneqq = "≨︀";
const lvnE = "≨︀";
const macr$1 = "¯";
const male = "♂";
const malt = "✠";
const maltese = "✠";
const map = "↦";
const mapsto = "↦";
const mapstodown = "↧";
const mapstoleft = "↤";
const mapstoup = "↥";
const marker = "▮";
const mcomma = "⨩";
const Mcy = "М";
const mcy = "м";
const mdash = "—";
const mDDot = "∺";
const measuredangle = "∡";
const MediumSpace = " ";
const Mellintrf = "ℳ";
const Mfr = "𝔐";
const mfr = "𝔪";
const mho = "℧";
const micro$1 = "µ";
const midast = "*";
const midcir = "⫰";
const mid = "∣";
const middot$1 = "·";
const minusb = "⊟";
const minus = "−";
const minusd = "∸";
const minusdu = "⨪";
const MinusPlus = "∓";
const mlcp = "⫛";
const mldr = "…";
const mnplus = "∓";
const models$1 = "⊧";
const Mopf = "𝕄";
const mopf = "𝕞";
const mp = "∓";
const mscr = "𝓂";
const Mscr = "ℳ";
const mstpos = "∾";
const Mu = "Μ";
const mu = "μ";
const multimap = "⊸";
const mumap = "⊸";
const nabla = "∇";
const Nacute = "Ń";
const nacute = "ń";
const nang = "∠⃒";
const nap = "≉";
const napE = "⩰̸";
const napid = "≋̸";
const napos = "ŉ";
const napprox = "≉";
const natural = "♮";
const naturals = "ℕ";
const natur = "♮";
const nbsp$1 = " ";
const nbump = "≎̸";
const nbumpe = "≏̸";
const ncap = "⩃";
const Ncaron = "Ň";
const ncaron = "ň";
const Ncedil = "Ņ";
const ncedil = "ņ";
const ncong = "≇";
const ncongdot = "⩭̸";
const ncup = "⩂";
const Ncy = "Н";
const ncy = "н";
const ndash = "–";
const nearhk = "⤤";
const nearr = "↗";
const neArr = "⇗";
const nearrow = "↗";
const ne2 = "≠";
const nedot = "≐̸";
const NegativeMediumSpace = "​";
const NegativeThickSpace = "​";
const NegativeThinSpace = "​";
const NegativeVeryThinSpace = "​";
const nequiv = "≢";
const nesear = "⤨";
const nesim = "≂̸";
const NestedGreaterGreater = "≫";
const NestedLessLess = "≪";
const NewLine = "\n";
const nexist = "∄";
const nexists = "∄";
const Nfr = "𝔑";
const nfr = "𝔫";
const ngE = "≧̸";
const nge = "≱";
const ngeq = "≱";
const ngeqq = "≧̸";
const ngeqslant = "⩾̸";
const nges = "⩾̸";
const nGg = "⋙̸";
const ngsim = "≵";
const nGt = "≫⃒";
const ngt = "≯";
const ngtr = "≯";
const nGtv = "≫̸";
const nharr = "↮";
const nhArr = "⇎";
const nhpar = "⫲";
const ni = "∋";
const nis = "⋼";
const nisd = "⋺";
const niv = "∋";
const NJcy = "Њ";
const njcy = "њ";
const nlarr = "↚";
const nlArr = "⇍";
const nldr = "‥";
const nlE = "≦̸";
const nle = "≰";
const nleftarrow = "↚";
const nLeftarrow = "⇍";
const nleftrightarrow = "↮";
const nLeftrightarrow = "⇎";
const nleq = "≰";
const nleqq = "≦̸";
const nleqslant = "⩽̸";
const nles = "⩽̸";
const nless = "≮";
const nLl = "⋘̸";
const nlsim = "≴";
const nLt = "≪⃒";
const nlt = "≮";
const nltri = "⋪";
const nltrie = "⋬";
const nLtv = "≪̸";
const nmid = "∤";
const NoBreak = "⁠";
const NonBreakingSpace = " ";
const nopf = "𝕟";
const Nopf = "ℕ";
const Not = "⫬";
const not$1 = "¬";
const NotCongruent = "≢";
const NotCupCap = "≭";
const NotDoubleVerticalBar = "∦";
const NotElement = "∉";
const NotEqual = "≠";
const NotEqualTilde = "≂̸";
const NotExists = "∄";
const NotGreater = "≯";
const NotGreaterEqual = "≱";
const NotGreaterFullEqual = "≧̸";
const NotGreaterGreater = "≫̸";
const NotGreaterLess = "≹";
const NotGreaterSlantEqual = "⩾̸";
const NotGreaterTilde = "≵";
const NotHumpDownHump = "≎̸";
const NotHumpEqual = "≏̸";
const notin = "∉";
const notindot = "⋵̸";
const notinE = "⋹̸";
const notinva = "∉";
const notinvb = "⋷";
const notinvc = "⋶";
const NotLeftTriangleBar = "⧏̸";
const NotLeftTriangle = "⋪";
const NotLeftTriangleEqual = "⋬";
const NotLess = "≮";
const NotLessEqual = "≰";
const NotLessGreater = "≸";
const NotLessLess = "≪̸";
const NotLessSlantEqual = "⩽̸";
const NotLessTilde = "≴";
const NotNestedGreaterGreater = "⪢̸";
const NotNestedLessLess = "⪡̸";
const notni = "∌";
const notniva = "∌";
const notnivb = "⋾";
const notnivc = "⋽";
const NotPrecedes = "⊀";
const NotPrecedesEqual = "⪯̸";
const NotPrecedesSlantEqual = "⋠";
const NotReverseElement = "∌";
const NotRightTriangleBar = "⧐̸";
const NotRightTriangle = "⋫";
const NotRightTriangleEqual = "⋭";
const NotSquareSubset = "⊏̸";
const NotSquareSubsetEqual = "⋢";
const NotSquareSuperset = "⊐̸";
const NotSquareSupersetEqual = "⋣";
const NotSubset = "⊂⃒";
const NotSubsetEqual = "⊈";
const NotSucceeds = "⊁";
const NotSucceedsEqual = "⪰̸";
const NotSucceedsSlantEqual = "⋡";
const NotSucceedsTilde = "≿̸";
const NotSuperset = "⊃⃒";
const NotSupersetEqual = "⊉";
const NotTilde = "≁";
const NotTildeEqual = "≄";
const NotTildeFullEqual = "≇";
const NotTildeTilde = "≉";
const NotVerticalBar = "∤";
const nparallel = "∦";
const npar = "∦";
const nparsl = "⫽⃥";
const npart = "∂̸";
const npolint = "⨔";
const npr = "⊀";
const nprcue = "⋠";
const nprec = "⊀";
const npreceq = "⪯̸";
const npre = "⪯̸";
const nrarrc = "⤳̸";
const nrarr = "↛";
const nrArr = "⇏";
const nrarrw = "↝̸";
const nrightarrow = "↛";
const nRightarrow = "⇏";
const nrtri = "⋫";
const nrtrie = "⋭";
const nsc = "⊁";
const nsccue = "⋡";
const nsce = "⪰̸";
const Nscr = "𝒩";
const nscr = "𝓃";
const nshortmid = "∤";
const nshortparallel = "∦";
const nsim = "≁";
const nsime = "≄";
const nsimeq = "≄";
const nsmid = "∤";
const nspar = "∦";
const nsqsube = "⋢";
const nsqsupe = "⋣";
const nsub = "⊄";
const nsubE = "⫅̸";
const nsube = "⊈";
const nsubset = "⊂⃒";
const nsubseteq = "⊈";
const nsubseteqq = "⫅̸";
const nsucc = "⊁";
const nsucceq = "⪰̸";
const nsup = "⊅";
const nsupE = "⫆̸";
const nsupe = "⊉";
const nsupset = "⊃⃒";
const nsupseteq = "⊉";
const nsupseteqq = "⫆̸";
const ntgl = "≹";
const Ntilde$1 = "Ñ";
const ntilde$1 = "ñ";
const ntlg = "≸";
const ntriangleleft = "⋪";
const ntrianglelefteq = "⋬";
const ntriangleright = "⋫";
const ntrianglerighteq = "⋭";
const Nu = "Ν";
const nu = "ν";
const num = "#";
const numero = "№";
const numsp = " ";
const nvap = "≍⃒";
const nvdash = "⊬";
const nvDash = "⊭";
const nVdash = "⊮";
const nVDash = "⊯";
const nvge = "≥⃒";
const nvgt = ">⃒";
const nvHarr = "⤄";
const nvinfin = "⧞";
const nvlArr = "⤂";
const nvle = "≤⃒";
const nvlt = "<⃒";
const nvltrie = "⊴⃒";
const nvrArr = "⤃";
const nvrtrie = "⊵⃒";
const nvsim = "∼⃒";
const nwarhk = "⤣";
const nwarr = "↖";
const nwArr = "⇖";
const nwarrow = "↖";
const nwnear = "⤧";
const Oacute$1 = "Ó";
const oacute$1 = "ó";
const oast = "⊛";
const Ocirc$1 = "Ô";
const ocirc$1 = "ô";
const ocir = "⊚";
const Ocy = "О";
const ocy = "о";
const odash = "⊝";
const Odblac = "Ő";
const odblac = "ő";
const odiv = "⨸";
const odot = "⊙";
const odsold = "⦼";
const OElig = "Œ";
const oelig = "œ";
const ofcir = "⦿";
const Ofr = "𝔒";
const ofr = "𝔬";
const ogon = "˛";
const Ograve$1 = "Ò";
const ograve$1 = "ò";
const ogt = "⧁";
const ohbar = "⦵";
const ohm = "Ω";
const oint = "∮";
const olarr = "↺";
const olcir = "⦾";
const olcross = "⦻";
const oline = "‾";
const olt = "⧀";
const Omacr = "Ō";
const omacr = "ō";
const Omega = "Ω";
const omega = "ω";
const Omicron = "Ο";
const omicron = "ο";
const omid = "⦶";
const ominus = "⊖";
const Oopf = "𝕆";
const oopf = "𝕠";
const opar = "⦷";
const OpenCurlyDoubleQuote = "“";
const OpenCurlyQuote = "‘";
const operp = "⦹";
const oplus = "⊕";
const orarr = "↻";
const Or = "⩔";
const or = "∨";
const ord = "⩝";
const order = "ℴ";
const orderof = "ℴ";
const ordf$1 = "ª";
const ordm$1 = "º";
const origof = "⊶";
const oror = "⩖";
const orslope = "⩗";
const orv = "⩛";
const oS = "Ⓢ";
const Oscr = "𝒪";
const oscr = "ℴ";
const Oslash$1 = "Ø";
const oslash$1 = "ø";
const osol = "⊘";
const Otilde$1 = "Õ";
const otilde$1 = "õ";
const otimesas = "⨶";
const Otimes = "⨷";
const otimes = "⊗";
const Ouml$1 = "Ö";
const ouml$1 = "ö";
const ovbar = "⌽";
const OverBar = "‾";
const OverBrace = "⏞";
const OverBracket = "⎴";
const OverParenthesis = "⏜";
const para$1 = "¶";
const parallel = "∥";
const par = "∥";
const parsim = "⫳";
const parsl = "⫽";
const part = "∂";
const PartialD = "∂";
const Pcy = "П";
const pcy = "п";
const percnt = "%";
const period = ".";
const permil = "‰";
const perp = "⊥";
const pertenk = "‱";
const Pfr = "𝔓";
const pfr = "𝔭";
const Phi = "Φ";
const phi = "φ";
const phiv = "ϕ";
const phmmat = "ℳ";
const phone = "☎";
const Pi = "Π";
const pi = "π";
const pitchfork = "⋔";
const piv = "ϖ";
const planck = "ℏ";
const planckh = "ℎ";
const plankv = "ℏ";
const plusacir = "⨣";
const plusb = "⊞";
const pluscir = "⨢";
const plus$1 = "+";
const plusdo = "∔";
const plusdu = "⨥";
const pluse = "⩲";
const PlusMinus = "±";
const plusmn$1 = "±";
const plussim = "⨦";
const plustwo = "⨧";
const pm = "±";
const Poincareplane = "ℌ";
const pointint = "⨕";
const popf = "𝕡";
const Popf = "ℙ";
const pound$1 = "£";
const prap = "⪷";
const Pr2 = "⪻";
const pr = "≺";
const prcue = "≼";
const precapprox = "⪷";
const prec = "≺";
const preccurlyeq = "≼";
const Precedes = "≺";
const PrecedesEqual = "⪯";
const PrecedesSlantEqual = "≼";
const PrecedesTilde = "≾";
const preceq = "⪯";
const precnapprox = "⪹";
const precneqq = "⪵";
const precnsim = "⋨";
const pre = "⪯";
const prE = "⪳";
const precsim = "≾";
const prime = "′";
const Prime = "″";
const primes = "ℙ";
const prnap = "⪹";
const prnE = "⪵";
const prnsim = "⋨";
const prod = "∏";
const Product = "∏";
const profalar = "⌮";
const profline = "⌒";
const profsurf = "⌓";
const prop = "∝";
const Proportional = "∝";
const Proportion = "∷";
const propto = "∝";
const prsim = "≾";
const prurel = "⊰";
const Pscr = "𝒫";
const pscr = "𝓅";
const Psi = "Ψ";
const psi = "ψ";
const puncsp = " ";
const Qfr = "𝔔";
const qfr = "𝔮";
const qint = "⨌";
const qopf = "𝕢";
const Qopf = "ℚ";
const qprime = "⁗";
const Qscr = "𝒬";
const qscr = "𝓆";
const quaternions = "ℍ";
const quatint = "⨖";
const quest = "?";
const questeq = "≟";
const quot$2 = '"';
const QUOT$1 = '"';
const rAarr = "⇛";
const race = "∽̱";
const Racute = "Ŕ";
const racute = "ŕ";
const radic = "√";
const raemptyv = "⦳";
const rang = "⟩";
const Rang = "⟫";
const rangd = "⦒";
const range = "⦥";
const rangle = "⟩";
const raquo$1 = "»";
const rarrap = "⥵";
const rarrb = "⇥";
const rarrbfs = "⤠";
const rarrc = "⤳";
const rarr = "→";
const Rarr = "↠";
const rArr = "⇒";
const rarrfs = "⤞";
const rarrhk = "↪";
const rarrlp = "↬";
const rarrpl = "⥅";
const rarrsim = "⥴";
const Rarrtl = "⤖";
const rarrtl = "↣";
const rarrw = "↝";
const ratail = "⤚";
const rAtail = "⤜";
const ratio = "∶";
const rationals = "ℚ";
const rbarr = "⤍";
const rBarr = "⤏";
const RBarr = "⤐";
const rbbrk = "❳";
const rbrace = "}";
const rbrack = "]";
const rbrke = "⦌";
const rbrksld = "⦎";
const rbrkslu = "⦐";
const Rcaron = "Ř";
const rcaron = "ř";
const Rcedil = "Ŗ";
const rcedil = "ŗ";
const rceil = "⌉";
const rcub = "}";
const Rcy = "Р";
const rcy = "р";
const rdca = "⤷";
const rdldhar = "⥩";
const rdquo = "”";
const rdquor = "”";
const rdsh = "↳";
const real = "ℜ";
const realine = "ℛ";
const realpart = "ℜ";
const reals = "ℝ";
const Re = "ℜ";
const rect = "▭";
const reg$1 = "®";
const REG$1 = "®";
const ReverseElement = "∋";
const ReverseEquilibrium = "⇋";
const ReverseUpEquilibrium = "⥯";
const rfisht = "⥽";
const rfloor = "⌋";
const rfr = "𝔯";
const Rfr = "ℜ";
const rHar = "⥤";
const rhard = "⇁";
const rharu = "⇀";
const rharul = "⥬";
const Rho = "Ρ";
const rho = "ρ";
const rhov = "ϱ";
const RightAngleBracket = "⟩";
const RightArrowBar = "⇥";
const rightarrow = "→";
const RightArrow = "→";
const Rightarrow = "⇒";
const RightArrowLeftArrow = "⇄";
const rightarrowtail = "↣";
const RightCeiling = "⌉";
const RightDoubleBracket = "⟧";
const RightDownTeeVector = "⥝";
const RightDownVectorBar = "⥕";
const RightDownVector = "⇂";
const RightFloor = "⌋";
const rightharpoondown = "⇁";
const rightharpoonup = "⇀";
const rightleftarrows = "⇄";
const rightleftharpoons = "⇌";
const rightrightarrows = "⇉";
const rightsquigarrow = "↝";
const RightTeeArrow = "↦";
const RightTee = "⊢";
const RightTeeVector = "⥛";
const rightthreetimes = "⋌";
const RightTriangleBar = "⧐";
const RightTriangle = "⊳";
const RightTriangleEqual = "⊵";
const RightUpDownVector = "⥏";
const RightUpTeeVector = "⥜";
const RightUpVectorBar = "⥔";
const RightUpVector = "↾";
const RightVectorBar = "⥓";
const RightVector = "⇀";
const ring = "˚";
const risingdotseq = "≓";
const rlarr = "⇄";
const rlhar = "⇌";
const rlm = "‏";
const rmoustache = "⎱";
const rmoust = "⎱";
const rnmid = "⫮";
const roang = "⟭";
const roarr = "⇾";
const robrk = "⟧";
const ropar = "⦆";
const ropf = "𝕣";
const Ropf = "ℝ";
const roplus = "⨮";
const rotimes = "⨵";
const RoundImplies = "⥰";
const rpar = ")";
const rpargt = "⦔";
const rppolint = "⨒";
const rrarr = "⇉";
const Rrightarrow = "⇛";
const rsaquo = "›";
const rscr = "𝓇";
const Rscr = "ℛ";
const rsh = "↱";
const Rsh = "↱";
const rsqb = "]";
const rsquo = "’";
const rsquor = "’";
const rthree = "⋌";
const rtimes = "⋊";
const rtri = "▹";
const rtrie = "⊵";
const rtrif = "▸";
const rtriltri = "⧎";
const RuleDelayed = "⧴";
const ruluhar = "⥨";
const rx = "℞";
const Sacute = "Ś";
const sacute = "ś";
const sbquo = "‚";
const scap = "⪸";
const Scaron = "Š";
const scaron = "š";
const Sc = "⪼";
const sc = "≻";
const sccue = "≽";
const sce = "⪰";
const scE = "⪴";
const Scedil = "Ş";
const scedil = "ş";
const Scirc = "Ŝ";
const scirc = "ŝ";
const scnap = "⪺";
const scnE = "⪶";
const scnsim = "⋩";
const scpolint = "⨓";
const scsim = "≿";
const Scy = "С";
const scy = "с";
const sdotb = "⊡";
const sdot = "⋅";
const sdote = "⩦";
const searhk = "⤥";
const searr = "↘";
const seArr = "⇘";
const searrow = "↘";
const sect$1 = "§";
const semi = ";";
const seswar = "⤩";
const setminus = "∖";
const setmn = "∖";
const sext = "✶";
const Sfr = "𝔖";
const sfr = "𝔰";
const sfrown = "⌢";
const sharp = "♯";
const SHCHcy = "Щ";
const shchcy = "щ";
const SHcy = "Ш";
const shcy = "ш";
const ShortDownArrow = "↓";
const ShortLeftArrow = "←";
const shortmid = "∣";
const shortparallel = "∥";
const ShortRightArrow = "→";
const ShortUpArrow = "↑";
const shy$1 = "­";
const Sigma = "Σ";
const sigma = "σ";
const sigmaf = "ς";
const sigmav = "ς";
const sim = "∼";
const simdot = "⩪";
const sime = "≃";
const simeq = "≃";
const simg = "⪞";
const simgE = "⪠";
const siml = "⪝";
const simlE = "⪟";
const simne = "≆";
const simplus = "⨤";
const simrarr = "⥲";
const slarr = "←";
const SmallCircle = "∘";
const smallsetminus = "∖";
const smashp = "⨳";
const smeparsl = "⧤";
const smid = "∣";
const smile = "⌣";
const smt = "⪪";
const smte = "⪬";
const smtes = "⪬︀";
const SOFTcy = "Ь";
const softcy = "ь";
const solbar = "⌿";
const solb = "⧄";
const sol = "/";
const Sopf = "𝕊";
const sopf = "𝕤";
const spades = "♠";
const spadesuit = "♠";
const spar = "∥";
const sqcap = "⊓";
const sqcaps = "⊓︀";
const sqcup = "⊔";
const sqcups = "⊔︀";
const Sqrt = "√";
const sqsub = "⊏";
const sqsube = "⊑";
const sqsubset = "⊏";
const sqsubseteq = "⊑";
const sqsup = "⊐";
const sqsupe = "⊒";
const sqsupset = "⊐";
const sqsupseteq = "⊒";
const square = "□";
const Square = "□";
const SquareIntersection = "⊓";
const SquareSubset = "⊏";
const SquareSubsetEqual = "⊑";
const SquareSuperset = "⊐";
const SquareSupersetEqual = "⊒";
const SquareUnion = "⊔";
const squarf = "▪";
const squ = "□";
const squf = "▪";
const srarr = "→";
const Sscr = "𝒮";
const sscr = "𝓈";
const ssetmn = "∖";
const ssmile = "⌣";
const sstarf = "⋆";
const Star = "⋆";
const star = "☆";
const starf = "★";
const straightepsilon = "ϵ";
const straightphi = "ϕ";
const strns = "¯";
const sub = "⊂";
const Sub = "⋐";
const subdot = "⪽";
const subE = "⫅";
const sube = "⊆";
const subedot = "⫃";
const submult = "⫁";
const subnE = "⫋";
const subne = "⊊";
const subplus = "⪿";
const subrarr = "⥹";
const subset = "⊂";
const Subset = "⋐";
const subseteq = "⊆";
const subseteqq = "⫅";
const SubsetEqual = "⊆";
const subsetneq = "⊊";
const subsetneqq = "⫋";
const subsim = "⫇";
const subsub = "⫕";
const subsup = "⫓";
const succapprox = "⪸";
const succ = "≻";
const succcurlyeq = "≽";
const Succeeds = "≻";
const SucceedsEqual = "⪰";
const SucceedsSlantEqual = "≽";
const SucceedsTilde = "≿";
const succeq = "⪰";
const succnapprox = "⪺";
const succneqq = "⪶";
const succnsim = "⋩";
const succsim = "≿";
const SuchThat = "∋";
const sum = "∑";
const Sum = "∑";
const sung = "♪";
const sup1$1 = "¹";
const sup2$1 = "²";
const sup3$1 = "³";
const sup = "⊃";
const Sup = "⋑";
const supdot = "⪾";
const supdsub = "⫘";
const supE = "⫆";
const supe = "⊇";
const supedot = "⫄";
const Superset = "⊃";
const SupersetEqual = "⊇";
const suphsol = "⟉";
const suphsub = "⫗";
const suplarr = "⥻";
const supmult = "⫂";
const supnE = "⫌";
const supne = "⊋";
const supplus = "⫀";
const supset = "⊃";
const Supset = "⋑";
const supseteq = "⊇";
const supseteqq = "⫆";
const supsetneq = "⊋";
const supsetneqq = "⫌";
const supsim = "⫈";
const supsub = "⫔";
const supsup = "⫖";
const swarhk = "⤦";
const swarr = "↙";
const swArr = "⇙";
const swarrow = "↙";
const swnwar = "⤪";
const szlig$1 = "ß";
const Tab = "	";
const target = "⌖";
const Tau = "Τ";
const tau = "τ";
const tbrk = "⎴";
const Tcaron = "Ť";
const tcaron = "ť";
const Tcedil = "Ţ";
const tcedil = "ţ";
const Tcy = "Т";
const tcy = "т";
const tdot = "⃛";
const telrec = "⌕";
const Tfr = "𝔗";
const tfr = "𝔱";
const there4 = "∴";
const therefore = "∴";
const Therefore = "∴";
const Theta = "Θ";
const theta = "θ";
const thetasym = "ϑ";
const thetav = "ϑ";
const thickapprox = "≈";
const thicksim = "∼";
const ThickSpace = "  ";
const ThinSpace = " ";
const thinsp = " ";
const thkap = "≈";
const thksim = "∼";
const THORN$1 = "Þ";
const thorn$1 = "þ";
const tilde$1 = "˜";
const Tilde = "∼";
const TildeEqual = "≃";
const TildeFullEqual = "≅";
const TildeTilde = "≈";
const timesbar = "⨱";
const timesb = "⊠";
const times$1 = "×";
const timesd = "⨰";
const tint = "∭";
const toea = "⤨";
const topbot = "⌶";
const topcir = "⫱";
const top = "⊤";
const Topf = "𝕋";
const topf = "𝕥";
const topfork = "⫚";
const tosa = "⤩";
const tprime = "‴";
const trade = "™";
const TRADE = "™";
const triangle = "▵";
const triangledown = "▿";
const triangleleft = "◃";
const trianglelefteq = "⊴";
const triangleq = "≜";
const triangleright = "▹";
const trianglerighteq = "⊵";
const tridot = "◬";
const trie = "≜";
const triminus = "⨺";
const TripleDot = "⃛";
const triplus = "⨹";
const trisb = "⧍";
const tritime = "⨻";
const trpezium = "⏢";
const Tscr = "𝒯";
const tscr = "𝓉";
const TScy = "Ц";
const tscy = "ц";
const TSHcy = "Ћ";
const tshcy = "ћ";
const Tstrok = "Ŧ";
const tstrok = "ŧ";
const twixt = "≬";
const twoheadleftarrow = "↞";
const twoheadrightarrow = "↠";
const Uacute$1 = "Ú";
const uacute$1 = "ú";
const uarr = "↑";
const Uarr = "↟";
const uArr = "⇑";
const Uarrocir = "⥉";
const Ubrcy = "Ў";
const ubrcy = "ў";
const Ubreve = "Ŭ";
const ubreve = "ŭ";
const Ucirc$1 = "Û";
const ucirc$1 = "û";
const Ucy = "У";
const ucy = "у";
const udarr = "⇅";
const Udblac = "Ű";
const udblac = "ű";
const udhar = "⥮";
const ufisht = "⥾";
const Ufr = "𝔘";
const ufr = "𝔲";
const Ugrave$1 = "Ù";
const ugrave$1 = "ù";
const uHar = "⥣";
const uharl = "↿";
const uharr = "↾";
const uhblk = "▀";
const ulcorn = "⌜";
const ulcorner = "⌜";
const ulcrop = "⌏";
const ultri = "◸";
const Umacr = "Ū";
const umacr = "ū";
const uml$1 = "¨";
const UnderBar = "_";
const UnderBrace = "⏟";
const UnderBracket = "⎵";
const UnderParenthesis = "⏝";
const Union = "⋃";
const UnionPlus = "⊎";
const Uogon = "Ų";
const uogon = "ų";
const Uopf = "𝕌";
const uopf = "𝕦";
const UpArrowBar = "⤒";
const uparrow = "↑";
const UpArrow = "↑";
const Uparrow = "⇑";
const UpArrowDownArrow = "⇅";
const updownarrow = "↕";
const UpDownArrow = "↕";
const Updownarrow = "⇕";
const UpEquilibrium = "⥮";
const upharpoonleft = "↿";
const upharpoonright = "↾";
const uplus = "⊎";
const UpperLeftArrow = "↖";
const UpperRightArrow = "↗";
const upsi = "υ";
const Upsi = "ϒ";
const upsih = "ϒ";
const Upsilon = "Υ";
const upsilon = "υ";
const UpTeeArrow = "↥";
const UpTee = "⊥";
const upuparrows = "⇈";
const urcorn = "⌝";
const urcorner = "⌝";
const urcrop = "⌎";
const Uring = "Ů";
const uring = "ů";
const urtri = "◹";
const Uscr = "𝒰";
const uscr = "𝓊";
const utdot = "⋰";
const Utilde = "Ũ";
const utilde = "ũ";
const utri = "▵";
const utrif = "▴";
const uuarr = "⇈";
const Uuml$1 = "Ü";
const uuml$1 = "ü";
const uwangle = "⦧";
const vangrt = "⦜";
const varepsilon = "ϵ";
const varkappa = "ϰ";
const varnothing = "∅";
const varphi = "ϕ";
const varpi = "ϖ";
const varpropto = "∝";
const varr = "↕";
const vArr = "⇕";
const varrho = "ϱ";
const varsigma = "ς";
const varsubsetneq = "⊊︀";
const varsubsetneqq = "⫋︀";
const varsupsetneq = "⊋︀";
const varsupsetneqq = "⫌︀";
const vartheta = "ϑ";
const vartriangleleft = "⊲";
const vartriangleright = "⊳";
const vBar = "⫨";
const Vbar = "⫫";
const vBarv = "⫩";
const Vcy = "В";
const vcy = "в";
const vdash = "⊢";
const vDash = "⊨";
const Vdash = "⊩";
const VDash = "⊫";
const Vdashl = "⫦";
const veebar = "⊻";
const vee = "∨";
const Vee = "⋁";
const veeeq = "≚";
const vellip = "⋮";
const verbar = "|";
const Verbar = "‖";
const vert = "|";
const Vert = "‖";
const VerticalBar = "∣";
const VerticalLine = "|";
const VerticalSeparator = "❘";
const VerticalTilde = "≀";
const VeryThinSpace = " ";
const Vfr = "𝔙";
const vfr = "𝔳";
const vltri = "⊲";
const vnsub = "⊂⃒";
const vnsup = "⊃⃒";
const Vopf = "𝕍";
const vopf = "𝕧";
const vprop = "∝";
const vrtri = "⊳";
const Vscr = "𝒱";
const vscr = "𝓋";
const vsubnE = "⫋︀";
const vsubne = "⊊︀";
const vsupnE = "⫌︀";
const vsupne = "⊋︀";
const Vvdash = "⊪";
const vzigzag = "⦚";
const Wcirc = "Ŵ";
const wcirc = "ŵ";
const wedbar = "⩟";
const wedge = "∧";
const Wedge = "⋀";
const wedgeq = "≙";
const weierp = "℘";
const Wfr = "𝔚";
const wfr = "𝔴";
const Wopf = "𝕎";
const wopf = "𝕨";
const wp = "℘";
const wr = "≀";
const wreath = "≀";
const Wscr = "𝒲";
const wscr = "𝓌";
const xcap = "⋂";
const xcirc = "◯";
const xcup = "⋃";
const xdtri = "▽";
const Xfr = "𝔛";
const xfr = "𝔵";
const xharr = "⟷";
const xhArr = "⟺";
const Xi = "Ξ";
const xi = "ξ";
const xlarr = "⟵";
const xlArr = "⟸";
const xmap = "⟼";
const xnis = "⋻";
const xodot = "⨀";
const Xopf = "𝕏";
const xopf = "𝕩";
const xoplus = "⨁";
const xotime = "⨂";
const xrarr = "⟶";
const xrArr = "⟹";
const Xscr = "𝒳";
const xscr = "𝓍";
const xsqcup = "⨆";
const xuplus = "⨄";
const xutri = "△";
const xvee = "⋁";
const xwedge = "⋀";
const Yacute$1 = "Ý";
const yacute$1 = "ý";
const YAcy = "Я";
const yacy = "я";
const Ycirc = "Ŷ";
const ycirc = "ŷ";
const Ycy = "Ы";
const ycy = "ы";
const yen$1 = "¥";
const Yfr = "𝔜";
const yfr = "𝔶";
const YIcy = "Ї";
const yicy = "ї";
const Yopf = "𝕐";
const yopf = "𝕪";
const Yscr = "𝒴";
const yscr = "𝓎";
const YUcy = "Ю";
const yucy = "ю";
const yuml$1 = "ÿ";
const Yuml = "Ÿ";
const Zacute = "Ź";
const zacute = "ź";
const Zcaron = "Ž";
const zcaron = "ž";
const Zcy = "З";
const zcy = "з";
const Zdot = "Ż";
const zdot = "ż";
const zeetrf = "ℨ";
const ZeroWidthSpace = "​";
const Zeta = "Ζ";
const zeta = "ζ";
const zfr = "𝔷";
const Zfr = "ℨ";
const ZHcy = "Ж";
const zhcy = "ж";
const zigrarr = "⇝";
const zopf = "𝕫";
const Zopf = "ℤ";
const Zscr = "𝒵";
const zscr = "𝓏";
const zwj = "‍";
const zwnj = "‌";
const require$$1$1 = {
  Aacute: Aacute$1,
  aacute: aacute$1,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc: Acirc$1,
  acirc: acirc$1,
  acute: acute$1,
  Acy,
  acy,
  AElig: AElig$1,
  aelig: aelig$1,
  af,
  Afr,
  afr,
  Agrave: Agrave$1,
  agrave: agrave$1,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp: amp$2,
  AMP: AMP$1,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos: apos$1,
  ApplyFunction,
  approx,
  approxeq,
  Aring: Aring$1,
  aring: aring$1,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde: Atilde$1,
  atilde: atilde$1,
  Auml: Auml$1,
  auml: auml$1,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar: brvbar$1,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret: caret$1,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil: Ccedil$1,
  ccedil: ccedil$1,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil: cedil$1,
  Cedilla,
  cemptyv,
  cent: cent$1,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon,
  Colon,
  Colone,
  colone,
  coloneq,
  comma: comma$1,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy: copy$1,
  COPY: COPY$1,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren: curren$1,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg: deg$1,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div,
  divide: divide$1,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar: dollar$1,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute: Eacute$1,
  eacute: eacute$1,
  easter,
  Ecaron,
  ecaron,
  Ecirc: Ecirc$1,
  ecirc: ecirc$1,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave: Egrave$1,
  egrave: egrave$1,
  egs,
  egsdot,
  el,
  Element,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH: ETH$1,
  eth: eth$1,
  Euml: Euml$1,
  euml: euml$1,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12: frac12$1,
  frac13,
  frac14: frac14$1,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34: frac34$1,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma,
  Gammad,
  gammad,
  gap,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt: gt$3,
  GT: GT$1,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute: Iacute$1,
  iacute: iacute$1,
  ic,
  Icirc: Icirc$1,
  icirc: icirc$1,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl: iexcl$1,
  iff,
  ifr,
  Ifr,
  Igrave: Igrave$1,
  igrave: igrave$1,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  "in": "∈",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest: iquest$1,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml: Iuml$1,
  iuml: iuml$1,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo: laquo$1,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt: lt$2,
  LT: LT$1,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr: macr$1,
  male,
  malt,
  maltese,
  "Map": "⤅",
  map,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro: micro$1,
  midast,
  midcir,
  mid,
  middot: middot$1,
  minusb,
  minus,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models: models$1,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp: nbsp$1,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne: ne2,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not: not$1,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde: Ntilde$1,
  ntilde: ntilde$1,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute: Oacute$1,
  oacute: oacute$1,
  oast,
  Ocirc: Ocirc$1,
  ocirc: ocirc$1,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve: Ograve$1,
  ograve: ograve$1,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order,
  orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash: Oslash$1,
  oslash: oslash$1,
  osol,
  Otilde: Otilde$1,
  otilde: otilde$1,
  otimesas,
  Otimes,
  otimes,
  Ouml: Ouml$1,
  ouml: ouml$1,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para: para$1,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus: plus$1,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn: plusmn$1,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound: pound$1,
  prap,
  Pr: Pr2,
  pr,
  prcue,
  precapprox,
  prec,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot: quot$2,
  QUOT: QUOT$1,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo: raquo$1,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg: reg$1,
  REG: REG$1,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect: sect$1,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy: shy$1,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig: szlig$1,
  Tab,
  target,
  Tau,
  tau,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN: THORN$1,
  thorn: thorn$1,
  tilde: tilde$1,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times: times$1,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute: Uacute$1,
  uacute: uacute$1,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc: Ucirc$1,
  ucirc: ucirc$1,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave: Ugrave$1,
  ugrave: ugrave$1,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml: uml$1,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml: Uuml$1,
  uuml: uuml$1,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute: Yacute$1,
  yacute: yacute$1,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen: yen$1,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml: yuml$1,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj
};
const Aacute = "Á";
const aacute = "á";
const Acirc = "Â";
const acirc = "â";
const acute = "´";
const AElig = "Æ";
const aelig = "æ";
const Agrave = "À";
const agrave = "à";
const amp$1 = "&";
const AMP = "&";
const Aring = "Å";
const aring = "å";
const Atilde = "Ã";
const atilde = "ã";
const Auml = "Ä";
const auml = "ä";
const brvbar = "¦";
const Ccedil = "Ç";
const ccedil = "ç";
const cedil = "¸";
const cent = "¢";
const copy = "©";
const COPY = "©";
const curren = "¤";
const deg = "°";
const divide = "÷";
const Eacute = "É";
const eacute = "é";
const Ecirc = "Ê";
const ecirc = "ê";
const Egrave = "È";
const egrave = "è";
const ETH = "Ð";
const eth = "ð";
const Euml = "Ë";
const euml = "ë";
const frac12 = "½";
const frac14 = "¼";
const frac34 = "¾";
const gt$2 = ">";
const GT = ">";
const Iacute = "Í";
const iacute = "í";
const Icirc = "Î";
const icirc = "î";
const iexcl = "¡";
const Igrave = "Ì";
const igrave = "ì";
const iquest = "¿";
const Iuml = "Ï";
const iuml = "ï";
const laquo = "«";
const lt$1 = "<";
const LT = "<";
const macr = "¯";
const micro = "µ";
const middot = "·";
const nbsp = " ";
const not = "¬";
const Ntilde = "Ñ";
const ntilde = "ñ";
const Oacute = "Ó";
const oacute = "ó";
const Ocirc = "Ô";
const ocirc = "ô";
const Ograve = "Ò";
const ograve = "ò";
const ordf = "ª";
const ordm = "º";
const Oslash = "Ø";
const oslash = "ø";
const Otilde = "Õ";
const otilde = "õ";
const Ouml = "Ö";
const ouml = "ö";
const para = "¶";
const plusmn = "±";
const pound = "£";
const quot$1 = '"';
const QUOT = '"';
const raquo = "»";
const reg = "®";
const REG = "®";
const sect = "§";
const shy = "­";
const sup1 = "¹";
const sup2 = "²";
const sup3 = "³";
const szlig = "ß";
const THORN = "Þ";
const thorn = "þ";
const times = "×";
const Uacute = "Ú";
const uacute = "ú";
const Ucirc = "Û";
const ucirc = "û";
const Ugrave = "Ù";
const ugrave = "ù";
const uml = "¨";
const Uuml = "Ü";
const uuml = "ü";
const Yacute = "Ý";
const yacute = "ý";
const yen = "¥";
const yuml = "ÿ";
const require$$1 = {
  Aacute,
  aacute,
  Acirc,
  acirc,
  acute,
  AElig,
  aelig,
  Agrave,
  agrave,
  amp: amp$1,
  AMP,
  Aring,
  aring,
  Atilde,
  atilde,
  Auml,
  auml,
  brvbar,
  Ccedil,
  ccedil,
  cedil,
  cent,
  copy,
  COPY,
  curren,
  deg,
  divide,
  Eacute,
  eacute,
  Ecirc,
  ecirc,
  Egrave,
  egrave,
  ETH,
  eth,
  Euml,
  euml,
  frac12,
  frac14,
  frac34,
  gt: gt$2,
  GT,
  Iacute,
  iacute,
  Icirc,
  icirc,
  iexcl,
  Igrave,
  igrave,
  iquest,
  Iuml,
  iuml,
  laquo,
  lt: lt$1,
  LT,
  macr,
  micro,
  middot,
  nbsp,
  not,
  Ntilde,
  ntilde,
  Oacute,
  oacute,
  Ocirc,
  ocirc,
  Ograve,
  ograve,
  ordf,
  ordm,
  Oslash,
  oslash,
  Otilde,
  otilde,
  Ouml,
  ouml,
  para,
  plusmn,
  pound,
  quot: quot$1,
  QUOT,
  raquo,
  reg,
  REG,
  sect,
  shy,
  sup1,
  sup2,
  sup3,
  szlig,
  THORN,
  thorn,
  times,
  Uacute,
  uacute,
  Ucirc,
  ucirc,
  Ugrave,
  ugrave,
  uml,
  Uuml,
  uuml,
  Yacute,
  yacute,
  yen,
  yuml
};
const amp = "&";
const apos = "'";
const gt$1 = ">";
const lt2 = "<";
const quot = '"';
const require$$0 = {
  amp,
  apos,
  gt: gt$1,
  lt: lt2,
  quot
};
var hasRequiredTokenizer;
function requireTokenizer() {
  if (hasRequiredTokenizer) return Tokenizer;
  hasRequiredTokenizer = 1;
  var __importDefault = Tokenizer && Tokenizer.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(Tokenizer, "__esModule", { value: true });
  var decode_codepoint_1 = __importDefault(/* @__PURE__ */ requireDecode_codepoint());
  var entities_json_1 = __importDefault(require$$1$1);
  var legacy_json_1 = __importDefault(require$$1);
  var xml_json_1 = __importDefault(require$$0);
  function whitespace(c) {
    return c === " " || c === "\n" || c === "	" || c === "\f" || c === "\r";
  }
  function isASCIIAlpha(c) {
    return c >= "a" && c <= "z" || c >= "A" && c <= "Z";
  }
  function ifElseState(upper, SUCCESS, FAILURE) {
    var lower = upper.toLowerCase();
    if (upper === lower) {
      return function(t, c) {
        if (c === lower) {
          t._state = SUCCESS;
        } else {
          t._state = FAILURE;
          t._index--;
        }
      };
    }
    return function(t, c) {
      if (c === lower || c === upper) {
        t._state = SUCCESS;
      } else {
        t._state = FAILURE;
        t._index--;
      }
    };
  }
  function consumeSpecialNameChar(upper, NEXT_STATE) {
    var lower = upper.toLowerCase();
    return function(t, c) {
      if (c === lower || c === upper) {
        t._state = NEXT_STATE;
      } else {
        t._state = 3;
        t._index--;
      }
    };
  }
  var stateBeforeCdata1 = ifElseState(
    "C",
    24,
    16
    /* InDeclaration */
  );
  var stateBeforeCdata2 = ifElseState(
    "D",
    25,
    16
    /* InDeclaration */
  );
  var stateBeforeCdata3 = ifElseState(
    "A",
    26,
    16
    /* InDeclaration */
  );
  var stateBeforeCdata4 = ifElseState(
    "T",
    27,
    16
    /* InDeclaration */
  );
  var stateBeforeCdata5 = ifElseState(
    "A",
    28,
    16
    /* InDeclaration */
  );
  var stateBeforeScript1 = consumeSpecialNameChar(
    "R",
    35
    /* BeforeScript2 */
  );
  var stateBeforeScript2 = consumeSpecialNameChar(
    "I",
    36
    /* BeforeScript3 */
  );
  var stateBeforeScript3 = consumeSpecialNameChar(
    "P",
    37
    /* BeforeScript4 */
  );
  var stateBeforeScript4 = consumeSpecialNameChar(
    "T",
    38
    /* BeforeScript5 */
  );
  var stateAfterScript1 = ifElseState(
    "R",
    40,
    1
    /* Text */
  );
  var stateAfterScript2 = ifElseState(
    "I",
    41,
    1
    /* Text */
  );
  var stateAfterScript3 = ifElseState(
    "P",
    42,
    1
    /* Text */
  );
  var stateAfterScript4 = ifElseState(
    "T",
    43,
    1
    /* Text */
  );
  var stateBeforeStyle1 = consumeSpecialNameChar(
    "Y",
    45
    /* BeforeStyle2 */
  );
  var stateBeforeStyle2 = consumeSpecialNameChar(
    "L",
    46
    /* BeforeStyle3 */
  );
  var stateBeforeStyle3 = consumeSpecialNameChar(
    "E",
    47
    /* BeforeStyle4 */
  );
  var stateAfterStyle1 = ifElseState(
    "Y",
    49,
    1
    /* Text */
  );
  var stateAfterStyle2 = ifElseState(
    "L",
    50,
    1
    /* Text */
  );
  var stateAfterStyle3 = ifElseState(
    "E",
    51,
    1
    /* Text */
  );
  var stateBeforeSpecialT = consumeSpecialNameChar(
    "I",
    54
    /* BeforeTitle1 */
  );
  var stateBeforeTitle1 = consumeSpecialNameChar(
    "T",
    55
    /* BeforeTitle2 */
  );
  var stateBeforeTitle2 = consumeSpecialNameChar(
    "L",
    56
    /* BeforeTitle3 */
  );
  var stateBeforeTitle3 = consumeSpecialNameChar(
    "E",
    57
    /* BeforeTitle4 */
  );
  var stateAfterSpecialTEnd = ifElseState(
    "I",
    58,
    1
    /* Text */
  );
  var stateAfterTitle1 = ifElseState(
    "T",
    59,
    1
    /* Text */
  );
  var stateAfterTitle2 = ifElseState(
    "L",
    60,
    1
    /* Text */
  );
  var stateAfterTitle3 = ifElseState(
    "E",
    61,
    1
    /* Text */
  );
  var stateBeforeEntity = ifElseState(
    "#",
    63,
    64
    /* InNamedEntity */
  );
  var stateBeforeNumericEntity = ifElseState(
    "X",
    66,
    65
    /* InNumericEntity */
  );
  var Tokenizer$1 = (
    /** @class */
    (function() {
      function Tokenizer2(options, cbs) {
        var _a2;
        this._state = 1;
        this.buffer = "";
        this.sectionStart = 0;
        this._index = 0;
        this.bufferOffset = 0;
        this.baseState = 1;
        this.special = 1;
        this.running = true;
        this.ended = false;
        this.cbs = cbs;
        this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);
        this.decodeEntities = (_a2 = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a2 !== void 0 ? _a2 : true;
      }
      Tokenizer2.prototype.reset = function() {
        this._state = 1;
        this.buffer = "";
        this.sectionStart = 0;
        this._index = 0;
        this.bufferOffset = 0;
        this.baseState = 1;
        this.special = 1;
        this.running = true;
        this.ended = false;
      };
      Tokenizer2.prototype.write = function(chunk) {
        if (this.ended)
          this.cbs.onerror(Error(".write() after done!"));
        this.buffer += chunk;
        this.parse();
      };
      Tokenizer2.prototype.end = function(chunk) {
        if (this.ended)
          this.cbs.onerror(Error(".end() after done!"));
        if (chunk)
          this.write(chunk);
        this.ended = true;
        if (this.running)
          this.finish();
      };
      Tokenizer2.prototype.pause = function() {
        this.running = false;
      };
      Tokenizer2.prototype.resume = function() {
        this.running = true;
        if (this._index < this.buffer.length) {
          this.parse();
        }
        if (this.ended) {
          this.finish();
        }
      };
      Tokenizer2.prototype.getAbsoluteIndex = function() {
        return this.bufferOffset + this._index;
      };
      Tokenizer2.prototype.stateText = function(c) {
        if (c === "<") {
          if (this._index > this.sectionStart) {
            this.cbs.ontext(this.getSection());
          }
          this._state = 2;
          this.sectionStart = this._index;
        } else if (this.decodeEntities && c === "&" && (this.special === 1 || this.special === 4)) {
          if (this._index > this.sectionStart) {
            this.cbs.ontext(this.getSection());
          }
          this.baseState = 1;
          this._state = 62;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.isTagStartChar = function(c) {
        return isASCIIAlpha(c) || this.xmlMode && !whitespace(c) && c !== "/" && c !== ">";
      };
      Tokenizer2.prototype.stateBeforeTagName = function(c) {
        if (c === "/") {
          this._state = 5;
        } else if (c === "<") {
          this.cbs.ontext(this.getSection());
          this.sectionStart = this._index;
        } else if (c === ">" || this.special !== 1 || whitespace(c)) {
          this._state = 1;
        } else if (c === "!") {
          this._state = 15;
          this.sectionStart = this._index + 1;
        } else if (c === "?") {
          this._state = 17;
          this.sectionStart = this._index + 1;
        } else if (!this.isTagStartChar(c)) {
          this._state = 1;
        } else {
          this._state = !this.xmlMode && (c === "s" || c === "S") ? 32 : !this.xmlMode && (c === "t" || c === "T") ? 52 : 3;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.stateInTagName = function(c) {
        if (c === "/" || c === ">" || whitespace(c)) {
          this.emitToken("onopentagname");
          this._state = 8;
          this._index--;
        }
      };
      Tokenizer2.prototype.stateBeforeClosingTagName = function(c) {
        if (whitespace(c)) ;
        else if (c === ">") {
          this._state = 1;
        } else if (this.special !== 1) {
          if (this.special !== 4 && (c === "s" || c === "S")) {
            this._state = 33;
          } else if (this.special === 4 && (c === "t" || c === "T")) {
            this._state = 53;
          } else {
            this._state = 1;
            this._index--;
          }
        } else if (!this.isTagStartChar(c)) {
          this._state = 20;
          this.sectionStart = this._index;
        } else {
          this._state = 6;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.stateInClosingTagName = function(c) {
        if (c === ">" || whitespace(c)) {
          this.emitToken("onclosetag");
          this._state = 7;
          this._index--;
        }
      };
      Tokenizer2.prototype.stateAfterClosingTagName = function(c) {
        if (c === ">") {
          this._state = 1;
          this.sectionStart = this._index + 1;
        }
      };
      Tokenizer2.prototype.stateBeforeAttributeName = function(c) {
        if (c === ">") {
          this.cbs.onopentagend();
          this._state = 1;
          this.sectionStart = this._index + 1;
        } else if (c === "/") {
          this._state = 4;
        } else if (!whitespace(c)) {
          this._state = 9;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.stateInSelfClosingTag = function(c) {
        if (c === ">") {
          this.cbs.onselfclosingtag();
          this._state = 1;
          this.sectionStart = this._index + 1;
          this.special = 1;
        } else if (!whitespace(c)) {
          this._state = 8;
          this._index--;
        }
      };
      Tokenizer2.prototype.stateInAttributeName = function(c) {
        if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
          this.cbs.onattribname(this.getSection());
          this.sectionStart = -1;
          this._state = 10;
          this._index--;
        }
      };
      Tokenizer2.prototype.stateAfterAttributeName = function(c) {
        if (c === "=") {
          this._state = 11;
        } else if (c === "/" || c === ">") {
          this.cbs.onattribend(void 0);
          this._state = 8;
          this._index--;
        } else if (!whitespace(c)) {
          this.cbs.onattribend(void 0);
          this._state = 9;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.stateBeforeAttributeValue = function(c) {
        if (c === '"') {
          this._state = 12;
          this.sectionStart = this._index + 1;
        } else if (c === "'") {
          this._state = 13;
          this.sectionStart = this._index + 1;
        } else if (!whitespace(c)) {
          this._state = 14;
          this.sectionStart = this._index;
          this._index--;
        }
      };
      Tokenizer2.prototype.handleInAttributeValue = function(c, quote) {
        if (c === quote) {
          this.emitToken("onattribdata");
          this.cbs.onattribend(quote);
          this._state = 8;
        } else if (this.decodeEntities && c === "&") {
          this.emitToken("onattribdata");
          this.baseState = this._state;
          this._state = 62;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c) {
        this.handleInAttributeValue(c, '"');
      };
      Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c) {
        this.handleInAttributeValue(c, "'");
      };
      Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c) {
        if (whitespace(c) || c === ">") {
          this.emitToken("onattribdata");
          this.cbs.onattribend(null);
          this._state = 8;
          this._index--;
        } else if (this.decodeEntities && c === "&") {
          this.emitToken("onattribdata");
          this.baseState = this._state;
          this._state = 62;
          this.sectionStart = this._index;
        }
      };
      Tokenizer2.prototype.stateBeforeDeclaration = function(c) {
        this._state = c === "[" ? 23 : c === "-" ? 18 : 16;
      };
      Tokenizer2.prototype.stateInDeclaration = function(c) {
        if (c === ">") {
          this.cbs.ondeclaration(this.getSection());
          this._state = 1;
          this.sectionStart = this._index + 1;
        }
      };
      Tokenizer2.prototype.stateInProcessingInstruction = function(c) {
        if (c === ">") {
          this.cbs.onprocessinginstruction(this.getSection());
          this._state = 1;
          this.sectionStart = this._index + 1;
        }
      };
      Tokenizer2.prototype.stateBeforeComment = function(c) {
        if (c === "-") {
          this._state = 19;
          this.sectionStart = this._index + 1;
        } else {
          this._state = 16;
        }
      };
      Tokenizer2.prototype.stateInComment = function(c) {
        if (c === "-")
          this._state = 21;
      };
      Tokenizer2.prototype.stateInSpecialComment = function(c) {
        if (c === ">") {
          this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));
          this._state = 1;
          this.sectionStart = this._index + 1;
        }
      };
      Tokenizer2.prototype.stateAfterComment1 = function(c) {
        if (c === "-") {
          this._state = 22;
        } else {
          this._state = 19;
        }
      };
      Tokenizer2.prototype.stateAfterComment2 = function(c) {
        if (c === ">") {
          this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));
          this._state = 1;
          this.sectionStart = this._index + 1;
        } else if (c !== "-") {
          this._state = 19;
        }
      };
      Tokenizer2.prototype.stateBeforeCdata6 = function(c) {
        if (c === "[") {
          this._state = 29;
          this.sectionStart = this._index + 1;
        } else {
          this._state = 16;
          this._index--;
        }
      };
      Tokenizer2.prototype.stateInCdata = function(c) {
        if (c === "]")
          this._state = 30;
      };
      Tokenizer2.prototype.stateAfterCdata1 = function(c) {
        if (c === "]")
          this._state = 31;
        else
          this._state = 29;
      };
      Tokenizer2.prototype.stateAfterCdata2 = function(c) {
        if (c === ">") {
          this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));
          this._state = 1;
          this.sectionStart = this._index + 1;
        } else if (c !== "]") {
          this._state = 29;
        }
      };
      Tokenizer2.prototype.stateBeforeSpecialS = function(c) {
        if (c === "c" || c === "C") {
          this._state = 34;
        } else if (c === "t" || c === "T") {
          this._state = 44;
        } else {
          this._state = 3;
          this._index--;
        }
      };
      Tokenizer2.prototype.stateBeforeSpecialSEnd = function(c) {
        if (this.special === 2 && (c === "c" || c === "C")) {
          this._state = 39;
        } else if (this.special === 3 && (c === "t" || c === "T")) {
          this._state = 48;
        } else
          this._state = 1;
      };
      Tokenizer2.prototype.stateBeforeSpecialLast = function(c, special) {
        if (c === "/" || c === ">" || whitespace(c)) {
          this.special = special;
        }
        this._state = 3;
        this._index--;
      };
      Tokenizer2.prototype.stateAfterSpecialLast = function(c, sectionStartOffset) {
        if (c === ">" || whitespace(c)) {
          this.special = 1;
          this._state = 6;
          this.sectionStart = this._index - sectionStartOffset;
          this._index--;
        } else
          this._state = 1;
      };
      Tokenizer2.prototype.parseFixedEntity = function(map2) {
        if (map2 === void 0) {
          map2 = this.xmlMode ? xml_json_1.default : entities_json_1.default;
        }
        if (this.sectionStart + 1 < this._index) {
          var entity = this.buffer.substring(this.sectionStart + 1, this._index);
          if (Object.prototype.hasOwnProperty.call(map2, entity)) {
            this.emitPartial(map2[entity]);
            this.sectionStart = this._index + 1;
          }
        }
      };
      Tokenizer2.prototype.parseLegacyEntity = function() {
        var start = this.sectionStart + 1;
        var limit = Math.min(this._index - start, 6);
        while (limit >= 2) {
          var entity = this.buffer.substr(start, limit);
          if (Object.prototype.hasOwnProperty.call(legacy_json_1.default, entity)) {
            this.emitPartial(legacy_json_1.default[entity]);
            this.sectionStart += limit + 1;
            return;
          }
          limit--;
        }
      };
      Tokenizer2.prototype.stateInNamedEntity = function(c) {
        if (c === ";") {
          this.parseFixedEntity();
          if (this.baseState === 1 && this.sectionStart + 1 < this._index && !this.xmlMode) {
            this.parseLegacyEntity();
          }
          this._state = this.baseState;
        } else if ((c < "0" || c > "9") && !isASCIIAlpha(c)) {
          if (this.xmlMode || this.sectionStart + 1 === this._index) ;
          else if (this.baseState !== 1) {
            if (c !== "=") {
              this.parseFixedEntity(legacy_json_1.default);
            }
          } else {
            this.parseLegacyEntity();
          }
          this._state = this.baseState;
          this._index--;
        }
      };
      Tokenizer2.prototype.decodeNumericEntity = function(offset, base, strict) {
        var sectionStart = this.sectionStart + offset;
        if (sectionStart !== this._index) {
          var entity = this.buffer.substring(sectionStart, this._index);
          var parsed = parseInt(entity, base);
          this.emitPartial(decode_codepoint_1.default(parsed));
          this.sectionStart = strict ? this._index + 1 : this._index;
        }
        this._state = this.baseState;
      };
      Tokenizer2.prototype.stateInNumericEntity = function(c) {
        if (c === ";") {
          this.decodeNumericEntity(2, 10, true);
        } else if (c < "0" || c > "9") {
          if (!this.xmlMode) {
            this.decodeNumericEntity(2, 10, false);
          } else {
            this._state = this.baseState;
          }
          this._index--;
        }
      };
      Tokenizer2.prototype.stateInHexEntity = function(c) {
        if (c === ";") {
          this.decodeNumericEntity(3, 16, true);
        } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
          if (!this.xmlMode) {
            this.decodeNumericEntity(3, 16, false);
          } else {
            this._state = this.baseState;
          }
          this._index--;
        }
      };
      Tokenizer2.prototype.cleanup = function() {
        if (this.sectionStart < 0) {
          this.buffer = "";
          this.bufferOffset += this._index;
          this._index = 0;
        } else if (this.running) {
          if (this._state === 1) {
            if (this.sectionStart !== this._index) {
              this.cbs.ontext(this.buffer.substr(this.sectionStart));
            }
            this.buffer = "";
            this.bufferOffset += this._index;
            this._index = 0;
          } else if (this.sectionStart === this._index) {
            this.buffer = "";
            this.bufferOffset += this._index;
            this._index = 0;
          } else {
            this.buffer = this.buffer.substr(this.sectionStart);
            this._index -= this.sectionStart;
            this.bufferOffset += this.sectionStart;
          }
          this.sectionStart = 0;
        }
      };
      Tokenizer2.prototype.parse = function() {
        while (this._index < this.buffer.length && this.running) {
          var c = this.buffer.charAt(this._index);
          if (this._state === 1) {
            this.stateText(c);
          } else if (this._state === 12) {
            this.stateInAttributeValueDoubleQuotes(c);
          } else if (this._state === 9) {
            this.stateInAttributeName(c);
          } else if (this._state === 19) {
            this.stateInComment(c);
          } else if (this._state === 20) {
            this.stateInSpecialComment(c);
          } else if (this._state === 8) {
            this.stateBeforeAttributeName(c);
          } else if (this._state === 3) {
            this.stateInTagName(c);
          } else if (this._state === 6) {
            this.stateInClosingTagName(c);
          } else if (this._state === 2) {
            this.stateBeforeTagName(c);
          } else if (this._state === 10) {
            this.stateAfterAttributeName(c);
          } else if (this._state === 13) {
            this.stateInAttributeValueSingleQuotes(c);
          } else if (this._state === 11) {
            this.stateBeforeAttributeValue(c);
          } else if (this._state === 5) {
            this.stateBeforeClosingTagName(c);
          } else if (this._state === 7) {
            this.stateAfterClosingTagName(c);
          } else if (this._state === 32) {
            this.stateBeforeSpecialS(c);
          } else if (this._state === 21) {
            this.stateAfterComment1(c);
          } else if (this._state === 14) {
            this.stateInAttributeValueNoQuotes(c);
          } else if (this._state === 4) {
            this.stateInSelfClosingTag(c);
          } else if (this._state === 16) {
            this.stateInDeclaration(c);
          } else if (this._state === 15) {
            this.stateBeforeDeclaration(c);
          } else if (this._state === 22) {
            this.stateAfterComment2(c);
          } else if (this._state === 18) {
            this.stateBeforeComment(c);
          } else if (this._state === 33) {
            this.stateBeforeSpecialSEnd(c);
          } else if (this._state === 53) {
            stateAfterSpecialTEnd(this, c);
          } else if (this._state === 39) {
            stateAfterScript1(this, c);
          } else if (this._state === 40) {
            stateAfterScript2(this, c);
          } else if (this._state === 41) {
            stateAfterScript3(this, c);
          } else if (this._state === 34) {
            stateBeforeScript1(this, c);
          } else if (this._state === 35) {
            stateBeforeScript2(this, c);
          } else if (this._state === 36) {
            stateBeforeScript3(this, c);
          } else if (this._state === 37) {
            stateBeforeScript4(this, c);
          } else if (this._state === 38) {
            this.stateBeforeSpecialLast(
              c,
              2
              /* Script */
            );
          } else if (this._state === 42) {
            stateAfterScript4(this, c);
          } else if (this._state === 43) {
            this.stateAfterSpecialLast(c, 6);
          } else if (this._state === 44) {
            stateBeforeStyle1(this, c);
          } else if (this._state === 29) {
            this.stateInCdata(c);
          } else if (this._state === 45) {
            stateBeforeStyle2(this, c);
          } else if (this._state === 46) {
            stateBeforeStyle3(this, c);
          } else if (this._state === 47) {
            this.stateBeforeSpecialLast(
              c,
              3
              /* Style */
            );
          } else if (this._state === 48) {
            stateAfterStyle1(this, c);
          } else if (this._state === 49) {
            stateAfterStyle2(this, c);
          } else if (this._state === 50) {
            stateAfterStyle3(this, c);
          } else if (this._state === 51) {
            this.stateAfterSpecialLast(c, 5);
          } else if (this._state === 52) {
            stateBeforeSpecialT(this, c);
          } else if (this._state === 54) {
            stateBeforeTitle1(this, c);
          } else if (this._state === 55) {
            stateBeforeTitle2(this, c);
          } else if (this._state === 56) {
            stateBeforeTitle3(this, c);
          } else if (this._state === 57) {
            this.stateBeforeSpecialLast(
              c,
              4
              /* Title */
            );
          } else if (this._state === 58) {
            stateAfterTitle1(this, c);
          } else if (this._state === 59) {
            stateAfterTitle2(this, c);
          } else if (this._state === 60) {
            stateAfterTitle3(this, c);
          } else if (this._state === 61) {
            this.stateAfterSpecialLast(c, 5);
          } else if (this._state === 17) {
            this.stateInProcessingInstruction(c);
          } else if (this._state === 64) {
            this.stateInNamedEntity(c);
          } else if (this._state === 23) {
            stateBeforeCdata1(this, c);
          } else if (this._state === 62) {
            stateBeforeEntity(this, c);
          } else if (this._state === 24) {
            stateBeforeCdata2(this, c);
          } else if (this._state === 25) {
            stateBeforeCdata3(this, c);
          } else if (this._state === 30) {
            this.stateAfterCdata1(c);
          } else if (this._state === 31) {
            this.stateAfterCdata2(c);
          } else if (this._state === 26) {
            stateBeforeCdata4(this, c);
          } else if (this._state === 27) {
            stateBeforeCdata5(this, c);
          } else if (this._state === 28) {
            this.stateBeforeCdata6(c);
          } else if (this._state === 66) {
            this.stateInHexEntity(c);
          } else if (this._state === 65) {
            this.stateInNumericEntity(c);
          } else if (this._state === 63) {
            stateBeforeNumericEntity(this, c);
          } else {
            this.cbs.onerror(Error("unknown _state"), this._state);
          }
          this._index++;
        }
        this.cleanup();
      };
      Tokenizer2.prototype.finish = function() {
        if (this.sectionStart < this._index) {
          this.handleTrailingData();
        }
        this.cbs.onend();
      };
      Tokenizer2.prototype.handleTrailingData = function() {
        var data = this.buffer.substr(this.sectionStart);
        if (this._state === 29 || this._state === 30 || this._state === 31) {
          this.cbs.oncdata(data);
        } else if (this._state === 19 || this._state === 21 || this._state === 22) {
          this.cbs.oncomment(data);
        } else if (this._state === 64 && !this.xmlMode) {
          this.parseLegacyEntity();
          if (this.sectionStart < this._index) {
            this._state = this.baseState;
            this.handleTrailingData();
          }
        } else if (this._state === 65 && !this.xmlMode) {
          this.decodeNumericEntity(2, 10, false);
          if (this.sectionStart < this._index) {
            this._state = this.baseState;
            this.handleTrailingData();
          }
        } else if (this._state === 66 && !this.xmlMode) {
          this.decodeNumericEntity(3, 16, false);
          if (this.sectionStart < this._index) {
            this._state = this.baseState;
            this.handleTrailingData();
          }
        } else if (this._state !== 3 && this._state !== 8 && this._state !== 11 && this._state !== 10 && this._state !== 9 && this._state !== 13 && this._state !== 12 && this._state !== 14 && this._state !== 6) {
          this.cbs.ontext(data);
        }
      };
      Tokenizer2.prototype.getSection = function() {
        return this.buffer.substring(this.sectionStart, this._index);
      };
      Tokenizer2.prototype.emitToken = function(name) {
        this.cbs[name](this.getSection());
        this.sectionStart = -1;
      };
      Tokenizer2.prototype.emitPartial = function(value) {
        if (this.baseState !== 1) {
          this.cbs.onattribdata(value);
        } else {
          this.cbs.ontext(value);
        }
      };
      return Tokenizer2;
    })()
  );
  Tokenizer.default = Tokenizer$1;
  return Tokenizer;
}
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return Parser;
  hasRequiredParser = 1;
  var __importDefault = Parser && Parser.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(Parser, "__esModule", { value: true });
  Parser.Parser = void 0;
  var Tokenizer_1 = __importDefault(/* @__PURE__ */ requireTokenizer());
  var formTags = /* @__PURE__ */ new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
  ]);
  var pTag = /* @__PURE__ */ new Set(["p"]);
  var openImpliesClose = {
    tr: /* @__PURE__ */ new Set(["tr", "th", "td"]),
    th: /* @__PURE__ */ new Set(["th"]),
    td: /* @__PURE__ */ new Set(["thead", "th", "td"]),
    body: /* @__PURE__ */ new Set(["head", "link", "script"]),
    li: /* @__PURE__ */ new Set(["li"]),
    p: pTag,
    h1: pTag,
    h2: pTag,
    h3: pTag,
    h4: pTag,
    h5: pTag,
    h6: pTag,
    select: formTags,
    input: formTags,
    output: formTags,
    button: formTags,
    datalist: formTags,
    textarea: formTags,
    option: /* @__PURE__ */ new Set(["option"]),
    optgroup: /* @__PURE__ */ new Set(["optgroup", "option"]),
    dd: /* @__PURE__ */ new Set(["dt", "dd"]),
    dt: /* @__PURE__ */ new Set(["dt", "dd"]),
    address: pTag,
    article: pTag,
    aside: pTag,
    blockquote: pTag,
    details: pTag,
    div: pTag,
    dl: pTag,
    fieldset: pTag,
    figcaption: pTag,
    figure: pTag,
    footer: pTag,
    form: pTag,
    header: pTag,
    hr: pTag,
    main: pTag,
    nav: pTag,
    ol: pTag,
    pre: pTag,
    section: pTag,
    table: pTag,
    ul: pTag,
    rt: /* @__PURE__ */ new Set(["rt", "rp"]),
    rp: /* @__PURE__ */ new Set(["rt", "rp"]),
    tbody: /* @__PURE__ */ new Set(["thead", "tbody"]),
    tfoot: /* @__PURE__ */ new Set(["thead", "tbody"])
  };
  var voidElements = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
  var htmlIntegrationElements = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]);
  var reNameEnd = /\s|\//;
  var Parser$1 = (
    /** @class */
    (function() {
      function Parser2(cbs, options) {
        if (options === void 0) {
          options = {};
        }
        var _a2, _b, _c, _d, _e2;
        this.startIndex = 0;
        this.endIndex = null;
        this.tagname = "";
        this.attribname = "";
        this.attribvalue = "";
        this.attribs = null;
        this.stack = [];
        this.foreignContext = [];
        this.options = options;
        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
        this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== void 0 ? _a2 : !options.xmlMode;
        this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1.default)(this.options, this);
        (_e2 = (_d = this.cbs).onparserinit) === null || _e2 === void 0 ? void 0 : _e2.call(_d, this);
      }
      Parser2.prototype.updatePosition = function(initialOffset) {
        if (this.endIndex === null) {
          if (this.tokenizer.sectionStart <= initialOffset) {
            this.startIndex = 0;
          } else {
            this.startIndex = this.tokenizer.sectionStart - initialOffset;
          }
        } else {
          this.startIndex = this.endIndex + 1;
        }
        this.endIndex = this.tokenizer.getAbsoluteIndex();
      };
      Parser2.prototype.ontext = function(data) {
        var _a2, _b;
        this.updatePosition(1);
        this.endIndex--;
        (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, data);
      };
      Parser2.prototype.onopentagname = function(name) {
        var _a2, _b;
        if (this.lowerCaseTagNames) {
          name = name.toLowerCase();
        }
        this.tagname = name;
        if (!this.options.xmlMode && Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {
          var el2 = void 0;
          while (this.stack.length > 0 && openImpliesClose[name].has(el2 = this.stack[this.stack.length - 1])) {
            this.onclosetag(el2);
          }
        }
        if (this.options.xmlMode || !voidElements.has(name)) {
          this.stack.push(name);
          if (foreignContextElements.has(name)) {
            this.foreignContext.push(true);
          } else if (htmlIntegrationElements.has(name)) {
            this.foreignContext.push(false);
          }
        }
        (_b = (_a2 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a2, name);
        if (this.cbs.onopentag)
          this.attribs = {};
      };
      Parser2.prototype.onopentagend = function() {
        var _a2, _b;
        this.updatePosition(1);
        if (this.attribs) {
          (_b = (_a2 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a2, this.tagname, this.attribs);
          this.attribs = null;
        }
        if (!this.options.xmlMode && this.cbs.onclosetag && voidElements.has(this.tagname)) {
          this.cbs.onclosetag(this.tagname);
        }
        this.tagname = "";
      };
      Parser2.prototype.onclosetag = function(name) {
        this.updatePosition(1);
        if (this.lowerCaseTagNames) {
          name = name.toLowerCase();
        }
        if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
          this.foreignContext.pop();
        }
        if (this.stack.length && (this.options.xmlMode || !voidElements.has(name))) {
          var pos = this.stack.lastIndexOf(name);
          if (pos !== -1) {
            if (this.cbs.onclosetag) {
              pos = this.stack.length - pos;
              while (pos--) {
                this.cbs.onclosetag(this.stack.pop());
              }
            } else
              this.stack.length = pos;
          } else if (name === "p" && !this.options.xmlMode) {
            this.onopentagname(name);
            this.closeCurrentTag();
          }
        } else if (!this.options.xmlMode && (name === "br" || name === "p")) {
          this.onopentagname(name);
          this.closeCurrentTag();
        }
      };
      Parser2.prototype.onselfclosingtag = function() {
        if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
          this.closeCurrentTag();
        } else {
          this.onopentagend();
        }
      };
      Parser2.prototype.closeCurrentTag = function() {
        var _a2, _b;
        var name = this.tagname;
        this.onopentagend();
        if (this.stack[this.stack.length - 1] === name) {
          (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, name);
          this.stack.pop();
        }
      };
      Parser2.prototype.onattribname = function(name) {
        if (this.lowerCaseAttributeNames) {
          name = name.toLowerCase();
        }
        this.attribname = name;
      };
      Parser2.prototype.onattribdata = function(value) {
        this.attribvalue += value;
      };
      Parser2.prototype.onattribend = function(quote) {
        var _a2, _b;
        (_b = (_a2 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attribname, this.attribvalue, quote);
        if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
          this.attribs[this.attribname] = this.attribvalue;
        }
        this.attribname = "";
        this.attribvalue = "";
      };
      Parser2.prototype.getInstructionName = function(value) {
        var idx = value.search(reNameEnd);
        var name = idx < 0 ? value : value.substr(0, idx);
        if (this.lowerCaseTagNames) {
          name = name.toLowerCase();
        }
        return name;
      };
      Parser2.prototype.ondeclaration = function(value) {
        if (this.cbs.onprocessinginstruction) {
          var name_1 = this.getInstructionName(value);
          this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
        }
      };
      Parser2.prototype.onprocessinginstruction = function(value) {
        if (this.cbs.onprocessinginstruction) {
          var name_2 = this.getInstructionName(value);
          this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
        }
      };
      Parser2.prototype.oncomment = function(value) {
        var _a2, _b, _c, _d;
        this.updatePosition(4);
        (_b = (_a2 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a2, value);
        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
      };
      Parser2.prototype.oncdata = function(value) {
        var _a2, _b, _c, _d, _e2, _f;
        this.updatePosition(1);
        if (this.options.xmlMode || this.options.recognizeCDATA) {
          (_b = (_a2 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a2);
          (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
          (_f = (_e2 = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e2);
        } else {
          this.oncomment("[CDATA[" + value + "]]");
        }
      };
      Parser2.prototype.onerror = function(err) {
        var _a2, _b;
        (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, err);
      };
      Parser2.prototype.onend = function() {
        var _a2, _b;
        if (this.cbs.onclosetag) {
          for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i]))
            ;
        }
        (_b = (_a2 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a2);
      };
      Parser2.prototype.reset = function() {
        var _a2, _b, _c, _d;
        (_b = (_a2 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a2);
        this.tokenizer.reset();
        this.tagname = "";
        this.attribname = "";
        this.attribs = null;
        this.stack = [];
        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
      };
      Parser2.prototype.parseComplete = function(data) {
        this.reset();
        this.end(data);
      };
      Parser2.prototype.write = function(chunk) {
        this.tokenizer.write(chunk);
      };
      Parser2.prototype.end = function(chunk) {
        this.tokenizer.end(chunk);
      };
      Parser2.prototype.pause = function() {
        this.tokenizer.pause();
      };
      Parser2.prototype.resume = function() {
        this.tokenizer.resume();
      };
      Parser2.prototype.parseChunk = function(chunk) {
        this.write(chunk);
      };
      Parser2.prototype.done = function(chunk) {
        this.end(chunk);
      };
      return Parser2;
    })()
  );
  Parser.Parser = Parser$1;
  return Parser;
}
var lib$3 = {};
var node = {};
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var __extends = node && node.__extends || /* @__PURE__ */ (function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
  })();
  var __assign = node && node.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(node, "__esModule", { value: true });
  node.cloneNode = node.hasChildren = node.isDocument = node.isDirective = node.isComment = node.isText = node.isCDATA = node.isTag = node.Element = node.Document = node.NodeWithChildren = node.ProcessingInstruction = node.Comment = node.Text = node.DataNode = node.Node = void 0;
  var domelementtype_1 = /* @__PURE__ */ requireLib$6();
  var nodeTypes = /* @__PURE__ */ new Map([
    [domelementtype_1.ElementType.Tag, 1],
    [domelementtype_1.ElementType.Script, 1],
    [domelementtype_1.ElementType.Style, 1],
    [domelementtype_1.ElementType.Directive, 1],
    [domelementtype_1.ElementType.Text, 3],
    [domelementtype_1.ElementType.CDATA, 4],
    [domelementtype_1.ElementType.Comment, 8],
    [domelementtype_1.ElementType.Root, 9]
  ]);
  var Node = (
    /** @class */
    (function() {
      function Node2(type) {
        this.type = type;
        this.parent = null;
        this.prev = null;
        this.next = null;
        this.startIndex = null;
        this.endIndex = null;
      }
      Object.defineProperty(Node2.prototype, "nodeType", {
        // Read-only aliases
        /**
         * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
         * node {@link type}.
         */
        get: function() {
          var _a2;
          return (_a2 = nodeTypes.get(this.type)) !== null && _a2 !== void 0 ? _a2 : 1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.parent;
        },
        set: function(parent) {
          this.parent = parent;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.prev;
        },
        set: function(prev) {
          this.prev = prev;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.next;
        },
        set: function(next) {
          this.next = next;
        },
        enumerable: false,
        configurable: true
      });
      Node2.prototype.cloneNode = function(recursive) {
        if (recursive === void 0) {
          recursive = false;
        }
        return cloneNode(this, recursive);
      };
      return Node2;
    })()
  );
  node.Node = Node;
  var DataNode = (
    /** @class */
    (function(_super) {
      __extends(DataNode2, _super);
      function DataNode2(type, data) {
        var _this = _super.call(this, type) || this;
        _this.data = data;
        return _this;
      }
      Object.defineProperty(DataNode2.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.data;
        },
        set: function(data) {
          this.data = data;
        },
        enumerable: false,
        configurable: true
      });
      return DataNode2;
    })(Node)
  );
  node.DataNode = DataNode;
  var Text2 = (
    /** @class */
    (function(_super) {
      __extends(Text3, _super);
      function Text3(data) {
        return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
      }
      return Text3;
    })(DataNode)
  );
  node.Text = Text2;
  var Comment = (
    /** @class */
    (function(_super) {
      __extends(Comment2, _super);
      function Comment2(data) {
        return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
      }
      return Comment2;
    })(DataNode)
  );
  node.Comment = Comment;
  var ProcessingInstruction = (
    /** @class */
    (function(_super) {
      __extends(ProcessingInstruction2, _super);
      function ProcessingInstruction2(name, data) {
        var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
        _this.name = name;
        return _this;
      }
      return ProcessingInstruction2;
    })(DataNode)
  );
  node.ProcessingInstruction = ProcessingInstruction;
  var NodeWithChildren = (
    /** @class */
    (function(_super) {
      __extends(NodeWithChildren2, _super);
      function NodeWithChildren2(type, children) {
        var _this = _super.call(this, type) || this;
        _this.children = children;
        return _this;
      }
      Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */
        get: function() {
          var _a2;
          return (_a2 = this.children[0]) !== null && _a2 !== void 0 ? _a2 : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
        /** Last child of the node. */
        get: function() {
          return this.children.length > 0 ? this.children[this.children.length - 1] : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.children;
        },
        set: function(children) {
          this.children = children;
        },
        enumerable: false,
        configurable: true
      });
      return NodeWithChildren2;
    })(Node)
  );
  node.NodeWithChildren = NodeWithChildren;
  var Document = (
    /** @class */
    (function(_super) {
      __extends(Document2, _super);
      function Document2(children) {
        return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
      }
      return Document2;
    })(NodeWithChildren)
  );
  node.Document = Document;
  var Element2 = (
    /** @class */
    (function(_super) {
      __extends(Element3, _super);
      function Element3(name, attribs, children, type) {
        if (children === void 0) {
          children = [];
        }
        if (type === void 0) {
          type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
        }
        var _this = _super.call(this, type, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        return _this;
      }
      Object.defineProperty(Element3.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function() {
          return this.name;
        },
        set: function(name) {
          this.name = name;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element3.prototype, "attributes", {
        get: function() {
          var _this = this;
          return Object.keys(this.attribs).map(function(name) {
            var _a2, _b;
            return {
              name,
              value: _this.attribs[name],
              namespace: (_a2 = _this["x-attribsNamespace"]) === null || _a2 === void 0 ? void 0 : _a2[name],
              prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
            };
          });
        },
        enumerable: false,
        configurable: true
      });
      return Element3;
    })(NodeWithChildren)
  );
  node.Element = Element2;
  function isTag(node2) {
    return (0, domelementtype_1.isTag)(node2);
  }
  node.isTag = isTag;
  function isCDATA(node2) {
    return node2.type === domelementtype_1.ElementType.CDATA;
  }
  node.isCDATA = isCDATA;
  function isText(node2) {
    return node2.type === domelementtype_1.ElementType.Text;
  }
  node.isText = isText;
  function isComment(node2) {
    return node2.type === domelementtype_1.ElementType.Comment;
  }
  node.isComment = isComment;
  function isDirective(node2) {
    return node2.type === domelementtype_1.ElementType.Directive;
  }
  node.isDirective = isDirective;
  function isDocument(node2) {
    return node2.type === domelementtype_1.ElementType.Root;
  }
  node.isDocument = isDocument;
  function hasChildren(node2) {
    return Object.prototype.hasOwnProperty.call(node2, "children");
  }
  node.hasChildren = hasChildren;
  function cloneNode(node2, recursive) {
    if (recursive === void 0) {
      recursive = false;
    }
    var result;
    if (isText(node2)) {
      result = new Text2(node2.data);
    } else if (isComment(node2)) {
      result = new Comment(node2.data);
    } else if (isTag(node2)) {
      var children = recursive ? cloneChildren(node2.children) : [];
      var clone_1 = new Element2(node2.name, __assign({}, node2.attribs), children);
      children.forEach(function(child) {
        return child.parent = clone_1;
      });
      if (node2.namespace != null) {
        clone_1.namespace = node2.namespace;
      }
      if (node2["x-attribsNamespace"]) {
        clone_1["x-attribsNamespace"] = __assign({}, node2["x-attribsNamespace"]);
      }
      if (node2["x-attribsPrefix"]) {
        clone_1["x-attribsPrefix"] = __assign({}, node2["x-attribsPrefix"]);
      }
      result = clone_1;
    } else if (isCDATA(node2)) {
      var children = recursive ? cloneChildren(node2.children) : [];
      var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
      children.forEach(function(child) {
        return child.parent = clone_2;
      });
      result = clone_2;
    } else if (isDocument(node2)) {
      var children = recursive ? cloneChildren(node2.children) : [];
      var clone_3 = new Document(children);
      children.forEach(function(child) {
        return child.parent = clone_3;
      });
      if (node2["x-mode"]) {
        clone_3["x-mode"] = node2["x-mode"];
      }
      result = clone_3;
    } else if (isDirective(node2)) {
      var instruction = new ProcessingInstruction(node2.name, node2.data);
      if (node2["x-name"] != null) {
        instruction["x-name"] = node2["x-name"];
        instruction["x-publicId"] = node2["x-publicId"];
        instruction["x-systemId"] = node2["x-systemId"];
      }
      result = instruction;
    } else {
      throw new Error("Not implemented yet: ".concat(node2.type));
    }
    result.startIndex = node2.startIndex;
    result.endIndex = node2.endIndex;
    if (node2.sourceCodeLocation != null) {
      result.sourceCodeLocation = node2.sourceCodeLocation;
    }
    return result;
  }
  node.cloneNode = cloneNode;
  function cloneChildren(childs) {
    var children = childs.map(function(child) {
      return cloneNode(child, true);
    });
    for (var i = 1; i < children.length; i++) {
      children[i].prev = children[i - 1];
      children[i - 1].next = children[i];
    }
    return children;
  }
  return node;
}
var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$3;
  hasRequiredLib$4 = 1;
  (function(exports$1) {
    var __createBinding = lib$3 && lib$3.__createBinding || (Object.create ? (function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    }) : (function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    }));
    var __exportStar = lib$3 && lib$3.__exportStar || function(m, exports$12) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.DomHandler = void 0;
    var domelementtype_1 = /* @__PURE__ */ requireLib$6();
    var node_1 = /* @__PURE__ */ requireNode();
    __exportStar(/* @__PURE__ */ requireNode(), exports$1);
    var reWhitespace = /\s+/g;
    var defaultOpts = {
      normalizeWhitespace: false,
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = (
      /** @class */
      (function() {
        function DomHandler2(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler2.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function(name, attribs) {
          var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element = new node_1.Element(name, attribs, void 0, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler2.prototype.ontext = function(data) {
          var normalizeWhitespace = this.options.normalizeWhitespace;
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            if (normalizeWhitespace) {
              lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
            } else {
              lastNode.data += data;
            }
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            if (normalizeWhitespace) {
              data = data.replace(reWhitespace, " ");
            }
            var node2 = new node_1.Text(data);
            this.addNode(node2);
            this.lastNode = node2;
          }
        };
        DomHandler2.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node2 = new node_1.Comment(data);
          this.addNode(node2);
          this.lastNode = node2;
        };
        DomHandler2.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function() {
          var text = new node_1.Text("");
          var node2 = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
          this.addNode(node2);
          text.parent = node2;
          this.lastNode = text;
        };
        DomHandler2.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function(name, data) {
          var node2 = new node_1.ProcessingInstruction(name, data);
          this.addNode(node2);
        };
        DomHandler2.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler2.prototype.addNode = function(node2) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node2.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node2.endIndex = this.parser.endIndex;
          }
          parent.children.push(node2);
          if (previousSibling) {
            node2.prev = previousSibling;
            previousSibling.next = node2;
          }
          node2.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      })()
    );
    exports$1.DomHandler = DomHandler;
    exports$1.default = DomHandler;
  })(lib$3);
  return lib$3;
}
var FeedHandler = {};
var lib$2 = {};
var stringify$1 = {};
var lib$1 = {};
var lib = {};
var decode = {};
var hasRequiredDecode;
function requireDecode() {
  if (hasRequiredDecode) return decode;
  hasRequiredDecode = 1;
  var __importDefault = decode && decode.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(decode, "__esModule", { value: true });
  decode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;
  var entities_json_1 = __importDefault(require$$1$1);
  var legacy_json_1 = __importDefault(require$$1);
  var xml_json_1 = __importDefault(require$$0);
  var decode_codepoint_1 = __importDefault(/* @__PURE__ */ requireDecode_codepoint());
  var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  decode.decodeXML = getStrictDecoder(xml_json_1.default);
  decode.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
  function getStrictDecoder(map2) {
    var replace = getReplacer(map2);
    return function(str) {
      return String(str).replace(strictEntityRe, replace);
    };
  }
  var sorter = function(a, b2) {
    return a < b2 ? 1 : -1;
  };
  decode.decodeHTML = (function() {
    var legacy2 = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);
    for (var i = 0, j2 = 0; i < keys.length; i++) {
      if (legacy2[j2] === keys[i]) {
        keys[i] += ";?";
        j2++;
      } else {
        keys[i] += ";";
      }
    }
    var re2 = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);
    function replacer(str) {
      if (str.substr(-1) !== ";")
        str += ";";
      return replace(str);
    }
    return function(str) {
      return String(str).replace(re2, replacer);
    };
  })();
  function getReplacer(map2) {
    return function replace(str) {
      if (str.charAt(1) === "#") {
        var secondChar = str.charAt(2);
        if (secondChar === "X" || secondChar === "x") {
          return decode_codepoint_1.default(parseInt(str.substr(3), 16));
        }
        return decode_codepoint_1.default(parseInt(str.substr(2), 10));
      }
      return map2[str.slice(1, -1)] || str;
    };
  }
  return decode;
}
var encode = {};
var hasRequiredEncode;
function requireEncode() {
  if (hasRequiredEncode) return encode;
  hasRequiredEncode = 1;
  var __importDefault = encode && encode.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(encode, "__esModule", { value: true });
  encode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;
  var xml_json_1 = __importDefault(require$$0);
  var inverseXML = getInverseObj(xml_json_1.default);
  var xmlReplacer = getInverseReplacer(inverseXML);
  encode.encodeXML = getASCIIEncoder(inverseXML);
  var entities_json_1 = __importDefault(require$$1$1);
  var inverseHTML = getInverseObj(entities_json_1.default);
  var htmlReplacer = getInverseReplacer(inverseHTML);
  encode.encodeHTML = getInverse(inverseHTML, htmlReplacer);
  encode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
  function getInverseObj(obj) {
    return Object.keys(obj).sort().reduce(function(inverse, name) {
      inverse[obj[name]] = "&" + name + ";";
      return inverse;
    }, {});
  }
  function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i2 = 0, _a2 = Object.keys(inverse); _i2 < _a2.length; _i2++) {
      var k2 = _a2[_i2];
      if (k2.length === 1) {
        single.push("\\" + k2);
      } else {
        multiple.push(k2);
      }
    }
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
      var end = start;
      while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
        end += 1;
      }
      var count = 1 + end - start;
      if (count < 3)
        continue;
      single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
  }
  var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
  var getCodePoint = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      (function(str) {
        return str.codePointAt(0);
      })
    ) : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      (function(c) {
        return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
      })
    )
  );
  function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  function getInverse(inverse, re2) {
    return function(data) {
      return data.replace(re2, function(name) {
        return inverse[name];
      }).replace(reNonASCII, singleCharReplacer);
    };
  }
  var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
  function escape(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
  }
  encode.escape = escape;
  function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
  }
  encode.escapeUTF8 = escapeUTF8;
  function getASCIIEncoder(obj) {
    return function(data) {
      return data.replace(reEscapeChars, function(c) {
        return obj[c] || singleCharReplacer(c);
      });
    };
  }
  return encode;
}
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib;
  hasRequiredLib$3 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.decodeXMLStrict = exports$1.decodeHTML5Strict = exports$1.decodeHTML4Strict = exports$1.decodeHTML5 = exports$1.decodeHTML4 = exports$1.decodeHTMLStrict = exports$1.decodeHTML = exports$1.decodeXML = exports$1.encodeHTML5 = exports$1.encodeHTML4 = exports$1.escapeUTF8 = exports$1.escape = exports$1.encodeNonAsciiHTML = exports$1.encodeHTML = exports$1.encodeXML = exports$1.encode = exports$1.decodeStrict = exports$1.decode = void 0;
    var decode_1 = /* @__PURE__ */ requireDecode();
    var encode_1 = /* @__PURE__ */ requireEncode();
    function decode2(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    exports$1.decode = decode2;
    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    exports$1.decodeStrict = decodeStrict;
    function encode2(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    exports$1.encode = encode2;
    var encode_2 = /* @__PURE__ */ requireEncode();
    Object.defineProperty(exports$1, "encodeXML", { enumerable: true, get: function() {
      return encode_2.encodeXML;
    } });
    Object.defineProperty(exports$1, "encodeHTML", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports$1, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports$1, "escape", { enumerable: true, get: function() {
      return encode_2.escape;
    } });
    Object.defineProperty(exports$1, "escapeUTF8", { enumerable: true, get: function() {
      return encode_2.escapeUTF8;
    } });
    Object.defineProperty(exports$1, "encodeHTML4", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports$1, "encodeHTML5", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    var decode_2 = /* @__PURE__ */ requireDecode();
    Object.defineProperty(exports$1, "decodeXML", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
    Object.defineProperty(exports$1, "decodeHTML", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports$1, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports$1, "decodeHTML4", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports$1, "decodeHTML5", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports$1, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports$1, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports$1, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
  })(lib);
  return lib;
}
var foreignNames = {};
var hasRequiredForeignNames;
function requireForeignNames() {
  if (hasRequiredForeignNames) return foreignNames;
  hasRequiredForeignNames = 1;
  Object.defineProperty(foreignNames, "__esModule", { value: true });
  foreignNames.attributeNames = foreignNames.elementNames = void 0;
  foreignNames.elementNames = /* @__PURE__ */ new Map([
    ["altglyph", "altGlyph"],
    ["altglyphdef", "altGlyphDef"],
    ["altglyphitem", "altGlyphItem"],
    ["animatecolor", "animateColor"],
    ["animatemotion", "animateMotion"],
    ["animatetransform", "animateTransform"],
    ["clippath", "clipPath"],
    ["feblend", "feBlend"],
    ["fecolormatrix", "feColorMatrix"],
    ["fecomponenttransfer", "feComponentTransfer"],
    ["fecomposite", "feComposite"],
    ["feconvolvematrix", "feConvolveMatrix"],
    ["fediffuselighting", "feDiffuseLighting"],
    ["fedisplacementmap", "feDisplacementMap"],
    ["fedistantlight", "feDistantLight"],
    ["fedropshadow", "feDropShadow"],
    ["feflood", "feFlood"],
    ["fefunca", "feFuncA"],
    ["fefuncb", "feFuncB"],
    ["fefuncg", "feFuncG"],
    ["fefuncr", "feFuncR"],
    ["fegaussianblur", "feGaussianBlur"],
    ["feimage", "feImage"],
    ["femerge", "feMerge"],
    ["femergenode", "feMergeNode"],
    ["femorphology", "feMorphology"],
    ["feoffset", "feOffset"],
    ["fepointlight", "fePointLight"],
    ["fespecularlighting", "feSpecularLighting"],
    ["fespotlight", "feSpotLight"],
    ["fetile", "feTile"],
    ["feturbulence", "feTurbulence"],
    ["foreignobject", "foreignObject"],
    ["glyphref", "glyphRef"],
    ["lineargradient", "linearGradient"],
    ["radialgradient", "radialGradient"],
    ["textpath", "textPath"]
  ]);
  foreignNames.attributeNames = /* @__PURE__ */ new Map([
    ["definitionurl", "definitionURL"],
    ["attributename", "attributeName"],
    ["attributetype", "attributeType"],
    ["basefrequency", "baseFrequency"],
    ["baseprofile", "baseProfile"],
    ["calcmode", "calcMode"],
    ["clippathunits", "clipPathUnits"],
    ["diffuseconstant", "diffuseConstant"],
    ["edgemode", "edgeMode"],
    ["filterunits", "filterUnits"],
    ["glyphref", "glyphRef"],
    ["gradienttransform", "gradientTransform"],
    ["gradientunits", "gradientUnits"],
    ["kernelmatrix", "kernelMatrix"],
    ["kernelunitlength", "kernelUnitLength"],
    ["keypoints", "keyPoints"],
    ["keysplines", "keySplines"],
    ["keytimes", "keyTimes"],
    ["lengthadjust", "lengthAdjust"],
    ["limitingconeangle", "limitingConeAngle"],
    ["markerheight", "markerHeight"],
    ["markerunits", "markerUnits"],
    ["markerwidth", "markerWidth"],
    ["maskcontentunits", "maskContentUnits"],
    ["maskunits", "maskUnits"],
    ["numoctaves", "numOctaves"],
    ["pathlength", "pathLength"],
    ["patterncontentunits", "patternContentUnits"],
    ["patterntransform", "patternTransform"],
    ["patternunits", "patternUnits"],
    ["pointsatx", "pointsAtX"],
    ["pointsaty", "pointsAtY"],
    ["pointsatz", "pointsAtZ"],
    ["preservealpha", "preserveAlpha"],
    ["preserveaspectratio", "preserveAspectRatio"],
    ["primitiveunits", "primitiveUnits"],
    ["refx", "refX"],
    ["refy", "refY"],
    ["repeatcount", "repeatCount"],
    ["repeatdur", "repeatDur"],
    ["requiredextensions", "requiredExtensions"],
    ["requiredfeatures", "requiredFeatures"],
    ["specularconstant", "specularConstant"],
    ["specularexponent", "specularExponent"],
    ["spreadmethod", "spreadMethod"],
    ["startoffset", "startOffset"],
    ["stddeviation", "stdDeviation"],
    ["stitchtiles", "stitchTiles"],
    ["surfacescale", "surfaceScale"],
    ["systemlanguage", "systemLanguage"],
    ["tablevalues", "tableValues"],
    ["targetx", "targetX"],
    ["targety", "targetY"],
    ["textlength", "textLength"],
    ["viewbox", "viewBox"],
    ["viewtarget", "viewTarget"],
    ["xchannelselector", "xChannelSelector"],
    ["ychannelselector", "yChannelSelector"],
    ["zoomandpan", "zoomAndPan"]
  ]);
  return foreignNames;
}
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$1;
  hasRequiredLib$2 = 1;
  var __assign = lib$1 && lib$1.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __createBinding = lib$1 && lib$1.__createBinding || (Object.create ? (function(o, m, k2, k22) {
    if (k22 === void 0) k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m[k2];
    } });
  }) : (function(o, m, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o[k22] = m[k2];
  }));
  var __setModuleDefault = lib$1 && lib$1.__setModuleDefault || (Object.create ? (function(o, v2) {
    Object.defineProperty(o, "default", { enumerable: true, value: v2 });
  }) : function(o, v2) {
    o["default"] = v2;
  });
  var __importStar = lib$1 && lib$1.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(lib$1, "__esModule", { value: true });
  var ElementType = __importStar(/* @__PURE__ */ requireLib$6());
  var entities_1 = /* @__PURE__ */ requireLib$3();
  var foreignNames_1 = /* @__PURE__ */ requireForeignNames();
  var unencodedElements = /* @__PURE__ */ new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript"
  ]);
  function formatAttributes(attributes, opts) {
    if (!attributes)
      return;
    return Object.keys(attributes).map(function(key) {
      var _a2, _b;
      var value = (_a2 = attributes[key]) !== null && _a2 !== void 0 ? _a2 : "";
      if (opts.xmlMode === "foreign") {
        key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
      }
      if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
        return key;
      }
      return key + '="' + (opts.decodeEntities !== false ? entities_1.encodeXML(value) : value.replace(/"/g, "&quot;")) + '"';
    }).join(" ");
  }
  var singleTag = /* @__PURE__ */ new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  function render2(node2, options) {
    if (options === void 0) {
      options = {};
    }
    var nodes = "length" in node2 ? node2 : [node2];
    var output = "";
    for (var i = 0; i < nodes.length; i++) {
      output += renderNode(nodes[i], options);
    }
    return output;
  }
  lib$1.default = render2;
  function renderNode(node2, options) {
    switch (node2.type) {
      case ElementType.Root:
        return render2(node2.children, options);
      case ElementType.Directive:
      case ElementType.Doctype:
        return renderDirective(node2);
      case ElementType.Comment:
        return renderComment(node2);
      case ElementType.CDATA:
        return renderCdata(node2);
      case ElementType.Script:
      case ElementType.Style:
      case ElementType.Tag:
        return renderTag(node2, options);
      case ElementType.Text:
        return renderText(node2, options);
    }
  }
  var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]);
  var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
  function renderTag(elem, opts) {
    var _a2;
    if (opts.xmlMode === "foreign") {
      elem.name = (_a2 = foreignNames_1.elementNames.get(elem.name)) !== null && _a2 !== void 0 ? _a2 : elem.name;
      if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: false });
      }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
      opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<" + elem.name;
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
      tag += " " + attribs;
    }
    if (elem.children.length === 0 && (opts.xmlMode ? (
      // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
      opts.selfClosingTags !== false
    ) : (
      // User explicitly asked for self-closing tags, even in HTML mode
      opts.selfClosingTags && singleTag.has(elem.name)
    ))) {
      if (!opts.xmlMode)
        tag += " ";
      tag += "/>";
    } else {
      tag += ">";
      if (elem.children.length > 0) {
        tag += render2(elem.children, opts);
      }
      if (opts.xmlMode || !singleTag.has(elem.name)) {
        tag += "</" + elem.name + ">";
      }
    }
    return tag;
  }
  function renderDirective(elem) {
    return "<" + elem.data + ">";
  }
  function renderText(elem, opts) {
    var data = elem.data || "";
    if (opts.decodeEntities !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
      data = entities_1.encodeXML(data);
    }
    return data;
  }
  function renderCdata(elem) {
    return "<![CDATA[" + elem.children[0].data + "]]>";
  }
  function renderComment(elem) {
    return "<!--" + elem.data + "-->";
  }
  return lib$1;
}
var hasRequiredStringify$1;
function requireStringify$1() {
  if (hasRequiredStringify$1) return stringify$1;
  hasRequiredStringify$1 = 1;
  var __importDefault = stringify$1 && stringify$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(stringify$1, "__esModule", { value: true });
  stringify$1.innerText = stringify$1.textContent = stringify$1.getText = stringify$1.getInnerHTML = stringify$1.getOuterHTML = void 0;
  var domhandler_1 = /* @__PURE__ */ requireLib$4();
  var dom_serializer_1 = __importDefault(/* @__PURE__ */ requireLib$2());
  var domelementtype_1 = /* @__PURE__ */ requireLib$6();
  function getOuterHTML(node2, options) {
    return (0, dom_serializer_1.default)(node2, options);
  }
  stringify$1.getOuterHTML = getOuterHTML;
  function getInnerHTML(node2, options) {
    return (0, domhandler_1.hasChildren)(node2) ? node2.children.map(function(node3) {
      return getOuterHTML(node3, options);
    }).join("") : "";
  }
  stringify$1.getInnerHTML = getInnerHTML;
  function getText(node2) {
    if (Array.isArray(node2))
      return node2.map(getText).join("");
    if ((0, domhandler_1.isTag)(node2))
      return node2.name === "br" ? "\n" : getText(node2.children);
    if ((0, domhandler_1.isCDATA)(node2))
      return getText(node2.children);
    if ((0, domhandler_1.isText)(node2))
      return node2.data;
    return "";
  }
  stringify$1.getText = getText;
  function textContent(node2) {
    if (Array.isArray(node2))
      return node2.map(textContent).join("");
    if ((0, domhandler_1.hasChildren)(node2) && !(0, domhandler_1.isComment)(node2)) {
      return textContent(node2.children);
    }
    if ((0, domhandler_1.isText)(node2))
      return node2.data;
    return "";
  }
  stringify$1.textContent = textContent;
  function innerText(node2) {
    if (Array.isArray(node2))
      return node2.map(innerText).join("");
    if ((0, domhandler_1.hasChildren)(node2) && (node2.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node2))) {
      return innerText(node2.children);
    }
    if ((0, domhandler_1.isText)(node2))
      return node2.data;
    return "";
  }
  stringify$1.innerText = innerText;
  return stringify$1;
}
var traversal = {};
var hasRequiredTraversal;
function requireTraversal() {
  if (hasRequiredTraversal) return traversal;
  hasRequiredTraversal = 1;
  Object.defineProperty(traversal, "__esModule", { value: true });
  traversal.prevElementSibling = traversal.nextElementSibling = traversal.getName = traversal.hasAttrib = traversal.getAttributeValue = traversal.getSiblings = traversal.getParent = traversal.getChildren = void 0;
  var domhandler_1 = /* @__PURE__ */ requireLib$4();
  var emptyArray = [];
  function getChildren(elem) {
    var _a2;
    return (_a2 = elem.children) !== null && _a2 !== void 0 ? _a2 : emptyArray;
  }
  traversal.getChildren = getChildren;
  function getParent(elem) {
    return elem.parent || null;
  }
  traversal.getParent = getParent;
  function getSiblings(elem) {
    var _a2, _b;
    var parent = getParent(elem);
    if (parent != null)
      return getChildren(parent);
    var siblings = [elem];
    var prev = elem.prev, next = elem.next;
    while (prev != null) {
      siblings.unshift(prev);
      _a2 = prev, prev = _a2.prev;
    }
    while (next != null) {
      siblings.push(next);
      _b = next, next = _b.next;
    }
    return siblings;
  }
  traversal.getSiblings = getSiblings;
  function getAttributeValue(elem, name) {
    var _a2;
    return (_a2 = elem.attribs) === null || _a2 === void 0 ? void 0 : _a2[name];
  }
  traversal.getAttributeValue = getAttributeValue;
  function hasAttrib(elem, name) {
    return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
  }
  traversal.hasAttrib = hasAttrib;
  function getName(elem) {
    return elem.name;
  }
  traversal.getName = getName;
  function nextElementSibling(elem) {
    var _a2;
    var next = elem.next;
    while (next !== null && !(0, domhandler_1.isTag)(next))
      _a2 = next, next = _a2.next;
    return next;
  }
  traversal.nextElementSibling = nextElementSibling;
  function prevElementSibling(elem) {
    var _a2;
    var prev = elem.prev;
    while (prev !== null && !(0, domhandler_1.isTag)(prev))
      _a2 = prev, prev = _a2.prev;
    return prev;
  }
  traversal.prevElementSibling = prevElementSibling;
  return traversal;
}
var manipulation = {};
var hasRequiredManipulation;
function requireManipulation() {
  if (hasRequiredManipulation) return manipulation;
  hasRequiredManipulation = 1;
  Object.defineProperty(manipulation, "__esModule", { value: true });
  manipulation.prepend = manipulation.prependChild = manipulation.append = manipulation.appendChild = manipulation.replaceElement = manipulation.removeElement = void 0;
  function removeElement(elem) {
    if (elem.prev)
      elem.prev.next = elem.next;
    if (elem.next)
      elem.next.prev = elem.prev;
    if (elem.parent) {
      var childs = elem.parent.children;
      childs.splice(childs.lastIndexOf(elem), 1);
    }
  }
  manipulation.removeElement = removeElement;
  function replaceElement(elem, replacement) {
    var prev = replacement.prev = elem.prev;
    if (prev) {
      prev.next = replacement;
    }
    var next = replacement.next = elem.next;
    if (next) {
      next.prev = replacement;
    }
    var parent = replacement.parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs[childs.lastIndexOf(elem)] = replacement;
    }
  }
  manipulation.replaceElement = replaceElement;
  function appendChild(elem, child) {
    removeElement(child);
    child.next = null;
    child.parent = elem;
    if (elem.children.push(child) > 1) {
      var sibling = elem.children[elem.children.length - 2];
      sibling.next = child;
      child.prev = sibling;
    } else {
      child.prev = null;
    }
  }
  manipulation.appendChild = appendChild;
  function append(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
      currNext.prev = next;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(currNext), 0, next);
      }
    } else if (parent) {
      parent.children.push(next);
    }
  }
  manipulation.append = append;
  function prependChild(elem, child) {
    removeElement(child);
    child.parent = elem;
    child.prev = null;
    if (elem.children.unshift(child) !== 1) {
      var sibling = elem.children[1];
      sibling.prev = child;
      child.next = sibling;
    } else {
      child.next = null;
    }
  }
  manipulation.prependChild = prependChild;
  function prepend(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
      elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
  }
  manipulation.prepend = prepend;
  return manipulation;
}
var querying = {};
var hasRequiredQuerying;
function requireQuerying() {
  if (hasRequiredQuerying) return querying;
  hasRequiredQuerying = 1;
  Object.defineProperty(querying, "__esModule", { value: true });
  querying.findAll = querying.existsOne = querying.findOne = querying.findOneChild = querying.find = querying.filter = void 0;
  var domhandler_1 = /* @__PURE__ */ requireLib$4();
  function filter(test, node2, recurse, limit) {
    if (recurse === void 0) {
      recurse = true;
    }
    if (limit === void 0) {
      limit = Infinity;
    }
    if (!Array.isArray(node2))
      node2 = [node2];
    return find(test, node2, recurse, limit);
  }
  querying.filter = filter;
  function find(test, nodes, recurse, limit) {
    var result = [];
    for (var _i2 = 0, nodes_1 = nodes; _i2 < nodes_1.length; _i2++) {
      var elem = nodes_1[_i2];
      if (test(elem)) {
        result.push(elem);
        if (--limit <= 0)
          break;
      }
      if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
        var children = find(test, elem.children, recurse, limit);
        result.push.apply(result, children);
        limit -= children.length;
        if (limit <= 0)
          break;
      }
    }
    return result;
  }
  querying.find = find;
  function findOneChild(test, nodes) {
    return nodes.find(test);
  }
  querying.findOneChild = findOneChild;
  function findOne(test, nodes, recurse) {
    if (recurse === void 0) {
      recurse = true;
    }
    var elem = null;
    for (var i = 0; i < nodes.length && !elem; i++) {
      var checked = nodes[i];
      if (!(0, domhandler_1.isTag)(checked)) {
        continue;
      } else if (test(checked)) {
        elem = checked;
      } else if (recurse && checked.children.length > 0) {
        elem = findOne(test, checked.children);
      }
    }
    return elem;
  }
  querying.findOne = findOne;
  function existsOne(test, nodes) {
    return nodes.some(function(checked) {
      return (0, domhandler_1.isTag)(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));
    });
  }
  querying.existsOne = existsOne;
  function findAll(test, nodes) {
    var _a2;
    var result = [];
    var stack = nodes.filter(domhandler_1.isTag);
    var elem;
    while (elem = stack.shift()) {
      var children = (_a2 = elem.children) === null || _a2 === void 0 ? void 0 : _a2.filter(domhandler_1.isTag);
      if (children && children.length > 0) {
        stack.unshift.apply(stack, children);
      }
      if (test(elem))
        result.push(elem);
    }
    return result;
  }
  querying.findAll = findAll;
  return querying;
}
var legacy = {};
var hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  Object.defineProperty(legacy, "__esModule", { value: true });
  legacy.getElementsByTagType = legacy.getElementsByTagName = legacy.getElementById = legacy.getElements = legacy.testElement = void 0;
  var domhandler_1 = /* @__PURE__ */ requireLib$4();
  var querying_1 = /* @__PURE__ */ requireQuerying();
  var Checks = {
    tag_name: function(name) {
      if (typeof name === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && name(elem.name);
        };
      } else if (name === "*") {
        return domhandler_1.isTag;
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.name === name;
      };
    },
    tag_type: function(type) {
      if (typeof type === "function") {
        return function(elem) {
          return type(elem.type);
        };
      }
      return function(elem) {
        return elem.type === type;
      };
    },
    tag_contains: function(data) {
      if (typeof data === "function") {
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && data(elem.data);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isText)(elem) && elem.data === data;
      };
    }
  };
  function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
      };
    }
    return function(elem) {
      return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
    };
  }
  function combineFuncs(a, b2) {
    return function(elem) {
      return a(elem) || b2(elem);
    };
  }
  function compileTest(options) {
    var funcs = Object.keys(options).map(function(key) {
      var value = options[key];
      return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
  }
  function testElement(options, node2) {
    var test = compileTest(options);
    return test ? test(node2) : true;
  }
  legacy.testElement = testElement;
  function getElements(options, nodes, recurse, limit) {
    if (limit === void 0) {
      limit = Infinity;
    }
    var test = compileTest(options);
    return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
  }
  legacy.getElements = getElements;
  function getElementById(id2, nodes, recurse) {
    if (recurse === void 0) {
      recurse = true;
    }
    if (!Array.isArray(nodes))
      nodes = [nodes];
    return (0, querying_1.findOne)(getAttribCheck("id", id2), nodes, recurse);
  }
  legacy.getElementById = getElementById;
  function getElementsByTagName(tagName, nodes, recurse, limit) {
    if (recurse === void 0) {
      recurse = true;
    }
    if (limit === void 0) {
      limit = Infinity;
    }
    return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
  }
  legacy.getElementsByTagName = getElementsByTagName;
  function getElementsByTagType(type, nodes, recurse, limit) {
    if (recurse === void 0) {
      recurse = true;
    }
    if (limit === void 0) {
      limit = Infinity;
    }
    return (0, querying_1.filter)(Checks.tag_type(type), nodes, recurse, limit);
  }
  legacy.getElementsByTagType = getElementsByTagType;
  return legacy;
}
var helpers = {};
var hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers) return helpers;
  hasRequiredHelpers = 1;
  Object.defineProperty(helpers, "__esModule", { value: true });
  helpers.uniqueSort = helpers.compareDocumentPosition = helpers.removeSubsets = void 0;
  var domhandler_1 = /* @__PURE__ */ requireLib$4();
  function removeSubsets(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node2 = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  }
  helpers.removeSubsets = removeSubsets;
  function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return 1;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return 4 | 16;
      }
      return 4;
    }
    if (sharedParent === nodeA) {
      return 2 | 8;
    }
    return 2;
  }
  helpers.compareDocumentPosition = compareDocumentPosition;
  function uniqueSort(nodes) {
    nodes = nodes.filter(function(node2, i, arr) {
      return !arr.includes(node2, i + 1);
    });
    nodes.sort(function(a, b2) {
      var relative = compareDocumentPosition(a, b2);
      if (relative & 2) {
        return -1;
      } else if (relative & 4) {
        return 1;
      }
      return 0;
    });
    return nodes;
  }
  helpers.uniqueSort = uniqueSort;
  return helpers;
}
var feeds = {};
var hasRequiredFeeds;
function requireFeeds() {
  if (hasRequiredFeeds) return feeds;
  hasRequiredFeeds = 1;
  Object.defineProperty(feeds, "__esModule", { value: true });
  feeds.getFeed = void 0;
  var stringify_1 = /* @__PURE__ */ requireStringify$1();
  var legacy_1 = /* @__PURE__ */ requireLegacy();
  function getFeed(doc) {
    var feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
  }
  feeds.getFeed = getFeed;
  function getAtomFeed(feedRoot) {
    var _a2;
    var childs = feedRoot.children;
    var feed = {
      type: "atom",
      items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function(item) {
        var _a3;
        var children = item.children;
        var entry = { media: getMediaElements(children) };
        addConditionally(entry, "id", "id", children);
        addConditionally(entry, "title", "title", children);
        var href2 = (_a3 = getOneElement("link", children)) === null || _a3 === void 0 ? void 0 : _a3.attribs.href;
        if (href2) {
          entry.link = href2;
        }
        var description = fetch2("summary", children) || fetch2("content", children);
        if (description) {
          entry.description = description;
        }
        var pubDate = fetch2("updated", children);
        if (pubDate) {
          entry.pubDate = new Date(pubDate);
        }
        return entry;
      })
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    var href = (_a2 = getOneElement("link", childs)) === null || _a2 === void 0 ? void 0 : _a2.attribs.href;
    if (href) {
      feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    var updated = fetch2("updated", childs);
    if (updated) {
      feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
  }
  function getRssFeed(feedRoot) {
    var _a2, _b;
    var childs = (_b = (_a2 = getOneElement("channel", feedRoot.children)) === null || _a2 === void 0 ? void 0 : _a2.children) !== null && _b !== void 0 ? _b : [];
    var feed = {
      type: feedRoot.name.substr(0, 3),
      id: "",
      items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
        var children = item.children;
        var entry = { media: getMediaElements(children) };
        addConditionally(entry, "id", "guid", children);
        addConditionally(entry, "title", "title", children);
        addConditionally(entry, "link", "link", children);
        addConditionally(entry, "description", "description", children);
        var pubDate = fetch2("pubDate", children);
        if (pubDate)
          entry.pubDate = new Date(pubDate);
        return entry;
      })
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    var updated = fetch2("lastBuildDate", childs);
    if (updated) {
      feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
  }
  var MEDIA_KEYS_STRING = ["url", "type", "lang"];
  var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width"
  ];
  function getMediaElements(where) {
    return (0, legacy_1.getElementsByTagName)("media:content", where).map(function(elem) {
      var attribs = elem.attribs;
      var media = {
        medium: attribs.medium,
        isDefault: !!attribs.isDefault
      };
      for (var _i2 = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i2 < MEDIA_KEYS_STRING_1.length; _i2++) {
        var attrib = MEDIA_KEYS_STRING_1[_i2];
        if (attribs[attrib]) {
          media[attrib] = attribs[attrib];
        }
      }
      for (var _a2 = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a2 < MEDIA_KEYS_INT_1.length; _a2++) {
        var attrib = MEDIA_KEYS_INT_1[_a2];
        if (attribs[attrib]) {
          media[attrib] = parseInt(attribs[attrib], 10);
        }
      }
      if (attribs.expression) {
        media.expression = attribs.expression;
      }
      return media;
    });
  }
  function getOneElement(tagName, node2) {
    return (0, legacy_1.getElementsByTagName)(tagName, node2, true, 1)[0];
  }
  function fetch2(tagName, where, recurse) {
    if (recurse === void 0) {
      recurse = false;
    }
    return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
  }
  function addConditionally(obj, prop2, tagName, where, recurse) {
    if (recurse === void 0) {
      recurse = false;
    }
    var val = fetch2(tagName, where, recurse);
    if (val)
      obj[prop2] = val;
  }
  function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
  }
  return feeds;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$2;
  hasRequiredLib$1 = 1;
  (function(exports$1) {
    var __createBinding = lib$2 && lib$2.__createBinding || (Object.create ? (function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    }) : (function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    }));
    var __exportStar = lib$2 && lib$2.__exportStar || function(m, exports$12) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.hasChildren = exports$1.isDocument = exports$1.isComment = exports$1.isText = exports$1.isCDATA = exports$1.isTag = void 0;
    __exportStar(/* @__PURE__ */ requireStringify$1(), exports$1);
    __exportStar(/* @__PURE__ */ requireTraversal(), exports$1);
    __exportStar(/* @__PURE__ */ requireManipulation(), exports$1);
    __exportStar(/* @__PURE__ */ requireQuerying(), exports$1);
    __exportStar(/* @__PURE__ */ requireLegacy(), exports$1);
    __exportStar(/* @__PURE__ */ requireHelpers(), exports$1);
    __exportStar(/* @__PURE__ */ requireFeeds(), exports$1);
    var domhandler_1 = /* @__PURE__ */ requireLib$4();
    Object.defineProperty(exports$1, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports$1, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports$1, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports$1, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports$1, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports$1, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  })(lib$2);
  return lib$2;
}
var hasRequiredFeedHandler;
function requireFeedHandler() {
  if (hasRequiredFeedHandler) return FeedHandler;
  hasRequiredFeedHandler = 1;
  var __extends = FeedHandler && FeedHandler.__extends || /* @__PURE__ */ (function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
  })();
  var __createBinding = FeedHandler && FeedHandler.__createBinding || (Object.create ? (function(o, m, k2, k22) {
    if (k22 === void 0) k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m[k2];
    } });
  }) : (function(o, m, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o[k22] = m[k2];
  }));
  var __setModuleDefault = FeedHandler && FeedHandler.__setModuleDefault || (Object.create ? (function(o, v2) {
    Object.defineProperty(o, "default", { enumerable: true, value: v2 });
  }) : function(o, v2) {
    o["default"] = v2;
  });
  var __importStar = FeedHandler && FeedHandler.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = FeedHandler && FeedHandler.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(FeedHandler, "__esModule", { value: true });
  FeedHandler.parseFeed = FeedHandler.FeedHandler = void 0;
  var domhandler_1 = __importDefault(/* @__PURE__ */ requireLib$4());
  var DomUtils = __importStar(/* @__PURE__ */ requireLib$1());
  var Parser_1 = /* @__PURE__ */ requireParser();
  var FeedItemMediaMedium;
  (function(FeedItemMediaMedium2) {
    FeedItemMediaMedium2[FeedItemMediaMedium2["image"] = 0] = "image";
    FeedItemMediaMedium2[FeedItemMediaMedium2["audio"] = 1] = "audio";
    FeedItemMediaMedium2[FeedItemMediaMedium2["video"] = 2] = "video";
    FeedItemMediaMedium2[FeedItemMediaMedium2["document"] = 3] = "document";
    FeedItemMediaMedium2[FeedItemMediaMedium2["executable"] = 4] = "executable";
  })(FeedItemMediaMedium || (FeedItemMediaMedium = {}));
  var FeedItemMediaExpression;
  (function(FeedItemMediaExpression2) {
    FeedItemMediaExpression2[FeedItemMediaExpression2["sample"] = 0] = "sample";
    FeedItemMediaExpression2[FeedItemMediaExpression2["full"] = 1] = "full";
    FeedItemMediaExpression2[FeedItemMediaExpression2["nonstop"] = 2] = "nonstop";
  })(FeedItemMediaExpression || (FeedItemMediaExpression = {}));
  var FeedHandler$1 = (
    /** @class */
    (function(_super) {
      __extends(FeedHandler2, _super);
      function FeedHandler2(callback, options) {
        var _this = this;
        if (typeof callback === "object") {
          callback = void 0;
          options = callback;
        }
        _this = _super.call(this, callback, options) || this;
        return _this;
      }
      FeedHandler2.prototype.onend = function() {
        var _a2, _b;
        var feedRoot = getOneElement(isValidFeed, this.dom);
        if (!feedRoot) {
          this.handleCallback(new Error("couldn't find root of feed"));
          return;
        }
        var feed = {};
        if (feedRoot.name === "feed") {
          var childs = feedRoot.children;
          feed.type = "atom";
          addConditionally(feed, "id", "id", childs);
          addConditionally(feed, "title", "title", childs);
          var href = getAttribute("href", getOneElement("link", childs));
          if (href) {
            feed.link = href;
          }
          addConditionally(feed, "description", "subtitle", childs);
          var updated = fetch2("updated", childs);
          if (updated) {
            feed.updated = new Date(updated);
          }
          addConditionally(feed, "author", "email", childs, true);
          feed.items = getElements("entry", childs).map(function(item) {
            var entry = {};
            var children = item.children;
            addConditionally(entry, "id", "id", children);
            addConditionally(entry, "title", "title", children);
            var href2 = getAttribute("href", getOneElement("link", children));
            if (href2) {
              entry.link = href2;
            }
            var description = fetch2("summary", children) || fetch2("content", children);
            if (description) {
              entry.description = description;
            }
            var pubDate = fetch2("updated", children);
            if (pubDate) {
              entry.pubDate = new Date(pubDate);
            }
            entry.media = getMediaElements(children);
            return entry;
          });
        } else {
          var childs = (_b = (_a2 = getOneElement("channel", feedRoot.children)) === null || _a2 === void 0 ? void 0 : _a2.children) !== null && _b !== void 0 ? _b : [];
          feed.type = feedRoot.name.substr(0, 3);
          feed.id = "";
          addConditionally(feed, "title", "title", childs);
          addConditionally(feed, "link", "link", childs);
          addConditionally(feed, "description", "description", childs);
          var updated = fetch2("lastBuildDate", childs);
          if (updated) {
            feed.updated = new Date(updated);
          }
          addConditionally(feed, "author", "managingEditor", childs, true);
          feed.items = getElements("item", feedRoot.children).map(function(item) {
            var entry = {};
            var children = item.children;
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            var pubDate = fetch2("pubDate", children);
            if (pubDate)
              entry.pubDate = new Date(pubDate);
            entry.media = getMediaElements(children);
            return entry;
          });
        }
        this.feed = feed;
        this.handleCallback(null);
      };
      return FeedHandler2;
    })(domhandler_1.default)
  );
  FeedHandler.FeedHandler = FeedHandler$1;
  function getMediaElements(where) {
    return getElements("media:content", where).map(function(elem) {
      var media = {
        medium: elem.attribs.medium,
        isDefault: !!elem.attribs.isDefault
      };
      if (elem.attribs.url) {
        media.url = elem.attribs.url;
      }
      if (elem.attribs.fileSize) {
        media.fileSize = parseInt(elem.attribs.fileSize, 10);
      }
      if (elem.attribs.type) {
        media.type = elem.attribs.type;
      }
      if (elem.attribs.expression) {
        media.expression = elem.attribs.expression;
      }
      if (elem.attribs.bitrate) {
        media.bitrate = parseInt(elem.attribs.bitrate, 10);
      }
      if (elem.attribs.framerate) {
        media.framerate = parseInt(elem.attribs.framerate, 10);
      }
      if (elem.attribs.samplingrate) {
        media.samplingrate = parseInt(elem.attribs.samplingrate, 10);
      }
      if (elem.attribs.channels) {
        media.channels = parseInt(elem.attribs.channels, 10);
      }
      if (elem.attribs.duration) {
        media.duration = parseInt(elem.attribs.duration, 10);
      }
      if (elem.attribs.height) {
        media.height = parseInt(elem.attribs.height, 10);
      }
      if (elem.attribs.width) {
        media.width = parseInt(elem.attribs.width, 10);
      }
      if (elem.attribs.lang) {
        media.lang = elem.attribs.lang;
      }
      return media;
    });
  }
  function getElements(tagName, where) {
    return DomUtils.getElementsByTagName(tagName, where, true);
  }
  function getOneElement(tagName, node2) {
    return DomUtils.getElementsByTagName(tagName, node2, true, 1)[0];
  }
  function fetch2(tagName, where, recurse) {
    if (recurse === void 0) {
      recurse = false;
    }
    return DomUtils.getText(DomUtils.getElementsByTagName(tagName, where, recurse, 1)).trim();
  }
  function getAttribute(name, elem) {
    if (!elem) {
      return null;
    }
    var attribs = elem.attribs;
    return attribs[name];
  }
  function addConditionally(obj, prop2, what, where, recurse) {
    if (recurse === void 0) {
      recurse = false;
    }
    var tmp = fetch2(what, where, recurse);
    if (tmp)
      obj[prop2] = tmp;
  }
  function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
  }
  function parseFeed(feed, options) {
    if (options === void 0) {
      options = { xmlMode: true };
    }
    var handler = new FeedHandler$1(options);
    new Parser_1.Parser(handler, options).end(feed);
    return handler.feed;
  }
  FeedHandler.parseFeed = parseFeed;
  return FeedHandler;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$4;
  hasRequiredLib = 1;
  (function(exports$1) {
    var __createBinding = lib$4 && lib$4.__createBinding || (Object.create ? (function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    }) : (function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    }));
    var __setModuleDefault = lib$4 && lib$4.__setModuleDefault || (Object.create ? (function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    }) : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar = lib$4 && lib$4.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = lib$4 && lib$4.__exportStar || function(m, exports$12) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
    };
    var __importDefault = lib$4 && lib$4.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.RssHandler = exports$1.DefaultHandler = exports$1.DomUtils = exports$1.ElementType = exports$1.Tokenizer = exports$1.createDomStream = exports$1.parseDOM = exports$1.parseDocument = exports$1.DomHandler = exports$1.Parser = void 0;
    var Parser_1 = /* @__PURE__ */ requireParser();
    Object.defineProperty(exports$1, "Parser", { enumerable: true, get: function() {
      return Parser_1.Parser;
    } });
    var domhandler_1 = /* @__PURE__ */ requireLib$4();
    Object.defineProperty(exports$1, "DomHandler", { enumerable: true, get: function() {
      return domhandler_1.DomHandler;
    } });
    Object.defineProperty(exports$1, "DefaultHandler", { enumerable: true, get: function() {
      return domhandler_1.DomHandler;
    } });
    function parseDocument(data, options) {
      var handler = new domhandler_1.DomHandler(void 0, options);
      new Parser_1.Parser(handler, options).end(data);
      return handler.root;
    }
    exports$1.parseDocument = parseDocument;
    function parseDOM(data, options) {
      return parseDocument(data, options).children;
    }
    exports$1.parseDOM = parseDOM;
    function createDomStream(cb, options, elementCb) {
      var handler = new domhandler_1.DomHandler(cb, options, elementCb);
      return new Parser_1.Parser(handler, options);
    }
    exports$1.createDomStream = createDomStream;
    var Tokenizer_1 = /* @__PURE__ */ requireTokenizer();
    Object.defineProperty(exports$1, "Tokenizer", { enumerable: true, get: function() {
      return __importDefault(Tokenizer_1).default;
    } });
    var ElementType = __importStar(/* @__PURE__ */ requireLib$6());
    exports$1.ElementType = ElementType;
    __exportStar(/* @__PURE__ */ requireFeedHandler(), exports$1);
    exports$1.DomUtils = __importStar(/* @__PURE__ */ requireLib$1());
    var FeedHandler_1 = /* @__PURE__ */ requireFeedHandler();
    Object.defineProperty(exports$1, "RssHandler", { enumerable: true, get: function() {
      return FeedHandler_1.FeedHandler;
    } });
  })(lib$4);
  return lib$4;
}
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(selderee);
var helper;
var hasRequiredHelper;
function requireHelper() {
  if (hasRequiredHelper) return helper;
  hasRequiredHelper = 1;
  const merge = requireCjs();
  function splitClassesAndIds(selectors) {
    const classes = [];
    const ids = [];
    for (const selector of selectors) {
      if (selector.startsWith(".")) {
        classes.push(selector.substring(1));
      } else if (selector.startsWith("#")) {
        ids.push(selector.substring(1));
      }
    }
    return { classes, ids };
  }
  function limitedDepthRecursive(n, f2, g = () => void 0) {
    if (n === void 0) {
      const f1 = function(...args) {
        return f2(f1, ...args);
      };
      return f1;
    }
    if (n >= 0) {
      return function(...args) {
        return f2(limitedDepthRecursive(n - 1, f2, g), ...args);
      };
    }
    return g;
  }
  function numberToLetterSequence(num2, baseChar = "a", base = 26) {
    const digits = [];
    do {
      num2 -= 1;
      digits.push(num2 % base);
      num2 = num2 / base >> 0;
    } while (num2 > 0);
    const baseCode = baseChar.charCodeAt(0);
    return digits.reverse().map((n) => String.fromCharCode(baseCode + n)).join("");
  }
  const I2 = ["I", "X", "C", "M"];
  const V2 = ["V", "L", "D"];
  function numberToRoman(num2) {
    return [...num2 + ""].map((n) => +n).reverse().map((v2, i) => v2 % 5 < 4 ? (v2 < 5 ? "" : V2[i]) + I2[i].repeat(v2 % 5) : I2[i] + (v2 < 5 ? V2[i] : I2[i + 1])).reverse().join("");
  }
  function trimCharacter(str, char) {
    let start = 0;
    let end = str.length;
    while (start < end && str[start] === char) {
      ++start;
    }
    while (end > start && str[end - 1] === char) {
      --end;
    }
    return start > 0 || end < str.length ? str.substring(start, end) : str;
  }
  function get(obj, path) {
    for (const key of path) {
      if (!obj) {
        return void 0;
      }
      obj = obj[key];
    }
    return obj;
  }
  function mergeDuplicatesPreferLast(items, getKey) {
    const map2 = /* @__PURE__ */ new Map();
    for (let i = items.length; i-- > 0; ) {
      const item = items[i];
      const key = getKey(item);
      map2.set(
        key,
        map2.has(key) ? merge(item, map2.get(key), { arrayMerge: overwriteMerge }) : item
      );
    }
    return [...map2.values()].reverse();
  }
  const overwriteMerge = (acc, src, options) => [...src];
  helper = {
    get,
    limitedDepthRecursive,
    mergeDuplicatesPreferLast,
    numberToLetterSequence,
    numberToRoman,
    splitClassesAndIds,
    trimCharacter
  };
  return helper;
}
var inlineTextBuilder;
var hasRequiredInlineTextBuilder;
function requireInlineTextBuilder() {
  if (hasRequiredInlineTextBuilder) return inlineTextBuilder;
  hasRequiredInlineTextBuilder = 1;
  class InlineTextBuilder {
    /**
     * Creates an instance of InlineTextBuilder.
     *
     * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.
     *
     * @param { Options } options           HtmlToText options.
     * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.
     */
    constructor(options, maxLineLength = void 0) {
      this.lines = [];
      this.nextLineWords = [];
      this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
      this.nextLineAvailableChars = this.maxLineLength;
      this.wrapCharacters = options.longWordSplit.wrapCharacters || [];
      this.forceWrapOnLimit = options.longWordSplit.forceWrapOnLimit || false;
      this.stashedSpace = false;
      this.wordBreakOpportunity = false;
    }
    /**
     * Add a new word.
     *
     * @param { string } word A word to add.
     */
    pushWord(word) {
      if (this.nextLineAvailableChars <= 0) {
        this.startNewLine();
      }
      const isLineStart = this.nextLineWords.length === 0;
      const cost = word.length + (isLineStart ? 0 : 1);
      if (cost <= this.nextLineAvailableChars) {
        this.nextLineWords.push(word);
        this.nextLineAvailableChars -= cost;
      } else {
        const [first, ...rest] = this.splitLongWord(word);
        if (!isLineStart) {
          this.startNewLine();
        }
        this.nextLineWords.push(first);
        this.nextLineAvailableChars -= first.length;
        for (const part2 of rest) {
          this.startNewLine();
          this.nextLineWords.push(part2);
          this.nextLineAvailableChars -= part2.length;
        }
      }
    }
    /**
     * Pop a word from the currently built line.
     * This doesn't affect completed lines.
     *
     * @returns { string }
     */
    popWord() {
      const lastWord = this.nextLineWords.pop();
      if (lastWord !== void 0) {
        const isLineStart = this.nextLineWords.length === 0;
        const cost = lastWord.length + (isLineStart ? 0 : 1);
        this.nextLineAvailableChars += cost;
      }
      return lastWord;
    }
    /**
     * Concat a word to the last word already in the builder.
     * Adds a new word in case there are no words yet in the last line.
     *
     * @param { string } word A word to be concatenated.
     */
    concatWord(word) {
      if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
        this.pushWord(word);
        this.wordBreakOpportunity = false;
      } else {
        const lastWord = this.popWord();
        this.pushWord(lastWord ? lastWord.concat(word) : word);
      }
    }
    /**
     * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.
     *
     * @param { number } n Number of line breaks that will be added to the resulting string.
     */
    startNewLine(n = 1) {
      this.lines.push(this.nextLineWords);
      if (n > 1) {
        this.lines.push(...Array.from({ length: n - 1 }, () => []));
      }
      this.nextLineWords = [];
      this.nextLineAvailableChars = this.maxLineLength;
    }
    /**
     * No words in this builder.
     *
     * @returns { boolean }
     */
    isEmpty() {
      return this.lines.length === 0 && this.nextLineWords.length === 0;
    }
    clear() {
      this.lines.length = 0;
      this.nextLineWords.length = 0;
      this.nextLineAvailableChars = this.maxLineLength;
    }
    /**
     * Join all lines of words inside the InlineTextBuilder into a complete string.
     *
     * @returns { string }
     */
    toString() {
      return [...this.lines, this.nextLineWords].map((words) => words.join(" ")).join("\n");
    }
    /**
     * Split a long word up to fit within the word wrap limit.
     * Use either a character to split looking back from the word wrap limit,
     * or truncate to the word wrap limit.
     *
     * @param   { string }   word Input word.
     * @returns { string[] }      Parts of the word.
     */
    splitLongWord(word) {
      const parts = [];
      let idx = 0;
      while (word.length > this.maxLineLength) {
        const firstLine = word.substring(0, this.maxLineLength);
        const remainingChars = word.substring(this.maxLineLength);
        const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
        if (splitIndex > -1) {
          word = firstLine.substring(splitIndex + 1) + remainingChars;
          parts.push(firstLine.substring(0, splitIndex + 1));
        } else {
          idx++;
          if (idx < this.wrapCharacters.length) {
            word = firstLine + remainingChars;
          } else {
            if (this.forceWrapOnLimit) {
              parts.push(firstLine);
              word = remainingChars;
              if (word.length > this.maxLineLength) {
                continue;
              }
            } else {
              word = firstLine + remainingChars;
            }
            break;
          }
        }
      }
      parts.push(word);
      return parts;
    }
  }
  inlineTextBuilder = { InlineTextBuilder };
  return inlineTextBuilder;
}
var stackItem;
var hasRequiredStackItem;
function requireStackItem() {
  if (hasRequiredStackItem) return stackItem;
  hasRequiredStackItem = 1;
  const { InlineTextBuilder } = requireInlineTextBuilder();
  class StackItem {
    constructor(next = null) {
      this.next = next;
    }
    getRoot() {
      return this.next ? this.next : this;
    }
  }
  class BlockStackItem extends StackItem {
    constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = void 0) {
      super(next);
      this.leadingLineBreaks = leadingLineBreaks;
      this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
      this.rawText = "";
      this.stashedLineBreaks = 0;
      this.isPre = next && next.isPre;
    }
  }
  class TableStackItem extends StackItem {
    constructor(next = null) {
      super(next);
      this.rows = [];
      this.isPre = next && next.isPre;
    }
  }
  class TableRowStackItem extends StackItem {
    constructor(next = null) {
      super(next);
      this.cells = [];
      this.isPre = next && next.isPre;
    }
  }
  class TableCellStackItem extends StackItem {
    constructor(options, next = null, maxColumnWidth = void 0) {
      super(next);
      this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
      this.rawText = "";
      this.stashedLineBreaks = 0;
      this.isPre = next && next.isPre;
    }
  }
  class TransformerStackItem extends StackItem {
    constructor(next = null, transform) {
      super(next);
      this.transform = transform;
    }
  }
  stackItem = {
    BlockStackItem,
    StackItem,
    TableCellStackItem,
    TableRowStackItem,
    TableStackItem,
    TransformerStackItem
  };
  return stackItem;
}
var tablePrinter;
var hasRequiredTablePrinter;
function requireTablePrinter() {
  if (hasRequiredTablePrinter) return tablePrinter;
  hasRequiredTablePrinter = 1;
  function getRow(matrix, j2) {
    if (!matrix[j2]) {
      matrix[j2] = [];
    }
    return matrix[j2];
  }
  function findFirstVacantIndex(row, x2 = 0) {
    while (row[x2]) {
      x2++;
    }
    return x2;
  }
  function transposeInPlace(matrix, maxSize) {
    for (let i = 0; i < maxSize; i++) {
      const rowI = getRow(matrix, i);
      for (let j2 = 0; j2 < i; j2++) {
        const rowJ = getRow(matrix, j2);
        const temp = rowI[j2];
        rowI[j2] = rowJ[i];
        rowJ[i] = temp;
      }
    }
  }
  function putCellIntoLayout(cell, layout, baseRow, baseCol) {
    for (let r = 0; r < cell.rowspan; r++) {
      const layoutRow = getRow(layout, baseRow + r);
      for (let c = 0; c < cell.colspan; c++) {
        layoutRow[baseCol + c] = cell;
      }
    }
  }
  function updateOffset(offsets, base, span, value) {
    offsets[base + span] = Math.max(
      offsets[base + span] || 0,
      offsets[base] + value
    );
  }
  function tableToString(tableRows, rowSpacing, colSpacing) {
    const layout = [];
    let colNumber = 0;
    const rowNumber = tableRows.length;
    const rowOffsets = [0];
    for (let j2 = 0; j2 < rowNumber; j2++) {
      const layoutRow = getRow(layout, j2);
      const cells = tableRows[j2];
      let x2 = 0;
      for (let i = 0; i < cells.length; i++) {
        const cell = cells[i];
        x2 = findFirstVacantIndex(layoutRow, x2);
        putCellIntoLayout(cell, layout, j2, x2);
        x2 += cell.colspan;
        cell.lines = cell.text.split("\n");
        const cellHeight = cell.lines.length;
        updateOffset(rowOffsets, j2, cell.rowspan, cellHeight + rowSpacing);
      }
      colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
    }
    transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);
    const outputLines = [];
    const colOffsets = [0];
    for (let x2 = 0; x2 < colNumber; x2++) {
      let y2 = 0;
      let cell;
      while (y2 < rowNumber && (cell = layout[x2][y2])) {
        if (!cell.rendered) {
          let cellWidth = 0;
          for (let j2 = 0; j2 < cell.lines.length; j2++) {
            const line = cell.lines[j2];
            const lineOffset = rowOffsets[y2] + j2;
            outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x2]) + line;
            cellWidth = line.length > cellWidth ? line.length : cellWidth;
          }
          updateOffset(colOffsets, x2, cell.colspan, cellWidth + colSpacing);
          cell.rendered = true;
        }
        y2 += cell.rowspan;
      }
    }
    return outputLines.join("\n");
  }
  tablePrinter = { tableToString };
  return tablePrinter;
}
var whitespaceProcessor;
var hasRequiredWhitespaceProcessor;
function requireWhitespaceProcessor() {
  if (hasRequiredWhitespaceProcessor) return whitespaceProcessor;
  hasRequiredWhitespaceProcessor = 1;
  const { InlineTextBuilder } = requireInlineTextBuilder();
  function charactersToCodes(str) {
    return [...str].map((c) => "\\u" + c.charCodeAt(0).toString(16).padStart(4, "0")).join("");
  }
  class WhitespaceProcessor {
    /**
     * Creates an instance of WhitespaceProcessor.
     *
     * @param { Options } options    HtmlToText options.
     * @memberof WhitespaceProcessor
     */
    constructor(options) {
      this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\n/g, "") : options.whitespaceCharacters;
      const whitespaceCodes = charactersToCodes(this.whitespaceChars);
      this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
      this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
      this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
      this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
      if (options.preserveNewlines) {
        const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
        this.shrinkWrapAdd = function(text, inlineTextBuilder2, transform = ((str) => str)) {
          if (!text) {
            return;
          }
          const previouslyStashedSpace = inlineTextBuilder2.stashedSpace;
          let anyMatch = false;
          let m = wordOrNewlineRe.exec(text);
          if (m) {
            anyMatch = true;
            if (m[0] === "\n") {
              inlineTextBuilder2.startNewLine();
            } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
              inlineTextBuilder2.pushWord(transform(m[0]));
            } else {
              inlineTextBuilder2.concatWord(transform(m[0]));
            }
            while ((m = wordOrNewlineRe.exec(text)) !== null) {
              if (m[0] === "\n") {
                inlineTextBuilder2.startNewLine();
              } else {
                inlineTextBuilder2.pushWord(transform(m[0]));
              }
            }
          }
          inlineTextBuilder2.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
        };
      } else {
        const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
        this.shrinkWrapAdd = function(text, inlineTextBuilder2, transform = ((str) => str)) {
          if (!text) {
            return;
          }
          const previouslyStashedSpace = inlineTextBuilder2.stashedSpace;
          let anyMatch = false;
          let m = wordRe.exec(text);
          if (m) {
            anyMatch = true;
            if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
              inlineTextBuilder2.pushWord(transform(m[0]));
            } else {
              inlineTextBuilder2.concatWord(transform(m[0]));
            }
            while ((m = wordRe.exec(text)) !== null) {
              inlineTextBuilder2.pushWord(transform(m[0]));
            }
          }
          inlineTextBuilder2.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);
        };
      }
    }
    /**
     * Test whether the given text starts with HTML whitespace character.
     *
     * @param   { string }  text  The string to test.
     * @returns { boolean }
     */
    testLeadingWhitespace(text) {
      return this.leadingWhitespaceRe.test(text);
    }
    /**
     * Test whether the given text ends with HTML whitespace character.
     *
     * @param   { string }  text  The string to test.
     * @returns { boolean }
     */
    testTrailingWhitespace(text) {
      return this.trailingWhitespaceRe.test(text);
    }
    /**
     * Test whether the given text contains any non-whitespace characters.
     *
     * @param   { string }  text  The string to test.
     * @returns { boolean }
     */
    testContainsWords(text) {
      return !this.allWhitespaceOrEmptyRe.test(text);
    }
    /**
     * Return the number of newlines if there are no words.
     *
     * If any word is found then return zero regardless of the actual number of newlines.
     *
     * @param   { string }  text  Input string.
     * @returns { number }
     */
    countNewlinesNoWords(text) {
      this.newlineOrNonWhitespaceRe.lastIndex = 0;
      let counter = 0;
      let match;
      while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {
        if (match[0] === "\n") {
          counter++;
        } else {
          return 0;
        }
      }
      return counter;
    }
  }
  whitespaceProcessor = { WhitespaceProcessor };
  return whitespaceProcessor;
}
var blockTextBuilder;
var hasRequiredBlockTextBuilder;
function requireBlockTextBuilder() {
  if (hasRequiredBlockTextBuilder) return blockTextBuilder;
  hasRequiredBlockTextBuilder = 1;
  const { Picker: Picker2 } = require$$4;
  const { trimCharacter } = requireHelper();
  const { StackItem, BlockStackItem, TableCellStackItem, TableRowStackItem, TableStackItem, TransformerStackItem } = requireStackItem();
  const { tableToString } = requireTablePrinter();
  const { WhitespaceProcessor } = requireWhitespaceProcessor();
  class BlockTextBuilder {
    /**
     * Creates an instance of BlockTextBuilder.
     *
     * @param { Options } options HtmlToText options.
     * @param { Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.
     */
    constructor(options, picker) {
      this.options = options;
      this.picker = picker;
      this.whitespaceProcessor = new WhitespaceProcessor(options);
      this._stackItem = new BlockStackItem(options);
      this._wordTransformer = void 0;
    }
    /**
     * Put a word-by-word transform function onto the transformations stack.
     *
     * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.
     *
     * Word transformations applied before wrapping.
     *
     * @param { (str: string) => string } wordTransform Word transformation function.
     */
    pushWordTransform(wordTransform) {
      this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
    }
    /**
     * Remove a function from the word transformations stack.
     *
     * @returns { (str: string) => string } A function that was removed.
     */
    popWordTransform() {
      if (!this._wordTransformer) {
        return void 0;
      }
      const transform = this._wordTransformer.transform;
      this._wordTransformer = this._wordTransformer.next;
      return transform;
    }
    /** @returns { (str: string) => string } */
    _getCombinedWordTransformer() {
      const applyTransformer = (str, transformer) => transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
      return (str) => applyTransformer(str, this._wordTransformer);
    }
    _popStackItem() {
      const item = this._stackItem;
      this._stackItem = item.next;
      return item;
    }
    /**
     * Add a line break into currently built block.
     */
    addLineBreak() {
      if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {
        return;
      }
      if (this._stackItem.isPre) {
        this._stackItem.rawText += "\n";
      } else {
        this._stackItem.inlineTextBuilder.startNewLine();
      }
    }
    /**
     * Allow to break line in case directly following text will not fit.
     */
    addWordBreakOpportunity() {
      if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem) {
        this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
      }
    }
    /**
     * Add a node inline into the currently built block.
     *
     * @param { string } str
     * Text content of a node to add.
     *
     * @param { object | boolean } [ optionsObjectOrNoWordTransform ]
     * Object holding the parameters of the operation.
     *
     * Boolean value is deprecated.
     *
     * @param { boolean } [ optionsObjectOrNoWordTransform.noWordTransform = false ]
     * Ignore word transformers if there are any.
     */
    addInline(str, optionsObjectOrNoWordTransform = {}) {
      if (typeof optionsObjectOrNoWordTransform === "object") {
        this._addInline(str, optionsObjectOrNoWordTransform);
      } else {
        this._addInline(str, { noWordTransform: optionsObjectOrNoWordTransform });
      }
    }
    _addInline(str, { noWordTransform = false } = {}) {
      if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {
        return;
      }
      if (this._stackItem.isPre) {
        this._stackItem.rawText += str;
        return;
      }
      if (str.length === 0 || // empty string
      this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant
      !this.whitespaceProcessor.testContainsWords(str)) {
        return;
      }
      if (this.options.preserveNewlines) {
        const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
        if (newlinesNumber > 0) {
          this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
          return;
        }
      }
      if (this._stackItem.stashedLineBreaks) {
        this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
      }
      this.whitespaceProcessor.shrinkWrapAdd(
        str,
        this._stackItem.inlineTextBuilder,
        this._wordTransformer && !noWordTransform ? this._getCombinedWordTransformer() : void 0
      );
      this._stackItem.stashedLineBreaks = 0;
    }
    /**
     * Start building a new block.
     *
     * @param { object | number } [optionsObjectOrLeadingLineBreaks]
     * Object holding the parameters of the block.
     *
     * Number value is deprecated.
     *
     * @param { number }  [optionsObjectOrLeadingLineBreaks.leadingLineBreaks = 1]
     * This block should have at least this number of line breaks to separate if from any preceding block.
     *
     * @param { number }  [optionsObjectOrLeadingLineBreaks.reservedLineLength = 0]
     * Reserve this number of characters on each line for block markup.
     *
     * @param { boolean } [optionsObjectOrLeadingLineBreaks.isPre = false]
     * Should HTML whitespace be preserved inside this block.
     *
     * @param { number }  [reservedLineLength]
     * Deprecated.
     *
     * @param { boolean } [isPre]
     * Deprecated.
     */
    openBlock(optionsObjectOrLeadingLineBreaks = {}, reservedLineLength = void 0, isPre = void 0) {
      if (typeof optionsObjectOrLeadingLineBreaks === "object") {
        this._openBlock(optionsObjectOrLeadingLineBreaks);
      } else {
        this._openBlock({
          isPre,
          leadingLineBreaks: optionsObjectOrLeadingLineBreaks,
          reservedLineLength
        });
      }
    }
    _openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
      const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
      this._stackItem = new BlockStackItem(
        this.options,
        this._stackItem,
        leadingLineBreaks,
        maxLineLength
      );
      if (isPre) {
        this._stackItem.isPre = true;
      }
    }
    /**
     * Finalize currently built block, add it's content to the parent block.
     *
     * @param { object | number }         [optionsObjectOrTrailingLineBreaks]
     * Object holding the parameters of the block.
     *
     * Number value is deprecated.
     *
     * @param { number }                  [optionsObjectOrTrailingLineBreaks.trailingLineBreaks = 1]
     * This block should have at least this number of line breaks to separate it from any following block.
     *
     * @param { (str: string) => string } [optionsObjectOrTrailingLineBreaks.blockTransform = undefined]
     * A function to transform the block text before adding to the parent block.
     * This happens after word wrap and should be used in combination with reserved line length
     * in order to keep line lengths correct.
     * Used for whole block markup.
     *
     * @param { (str: string) => string } [blockTransform]
     * Deprecated.
     */
    closeBlock(optionsObjectOrTrailingLineBreaks = {}, blockTransform = void 0) {
      if (typeof optionsObjectOrTrailingLineBreaks === "object") {
        this._closeBlock(optionsObjectOrTrailingLineBreaks);
      } else {
        this._closeBlock({
          trailingLineBreaks: optionsObjectOrTrailingLineBreaks,
          blockTransform
        });
      }
    }
    _closeBlock({ trailingLineBreaks = 1, blockTransform = void 0 } = {}) {
      const block2 = this._popStackItem();
      const blockText = blockTransform ? blockTransform(getText(block2)) : getText(block2);
      addText(this._stackItem, blockText, block2.leadingLineBreaks, Math.max(block2.stashedLineBreaks, trailingLineBreaks));
    }
    /**
     * Start building a table.
     */
    openTable() {
      this._stackItem = new TableStackItem(this._stackItem);
    }
    /**
     * Start building a table row.
     */
    openTableRow() {
      if (!(this._stackItem instanceof TableStackItem)) {
        throw new Error("Can't add table row to something that is not a table! Check the formatter.");
      }
      this._stackItem = new TableRowStackItem(this._stackItem);
    }
    /**
     * Start building a table cell.
     *
     * @param { object | number } [optionsObjectOrMaxColumnWidth = undefined]
     * Object holding the parameters of the cell.
     *
     * Number value is deprecated.
     *
     * @param { number } [optionsObjectOrMaxColumnWidth.maxColumnWidth = undefined]
     * Wrap cell content to this width. Fall back to global wordwrap value if undefined.
     */
    openTableCell(optionsObjectOrMaxColumnWidth = {}) {
      if (typeof optionsObjectOrMaxColumnWidth === "object") {
        this._openTableCell(optionsObjectOrMaxColumnWidth);
      } else {
        this._openTableCell({ maxColumnWidth: optionsObjectOrMaxColumnWidth });
      }
    }
    _openTableCell({ maxColumnWidth = void 0 } = {}) {
      if (!(this._stackItem instanceof TableRowStackItem)) {
        throw new Error("Can't add table cell to something that is not a table row! Check the formatter.");
      }
      this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
    }
    /**
     * Finalize currently built table cell and add it to parent table row's cells.
     *
     * @param { object | number } [optionsObjectOrColspan]
     * Object holding the parameters of the cell.
     *
     * Number value is deprecated.
     *
     * @param { number } [optionsObjectOrColspan.colspan = 1] How many columns this cell should occupy.
     * @param { number } [optionsObjectOrColspan.rowspan = 1] How many rows this cell should occupy.
     *
     * @param { number } [rowspan] Deprecated.
     */
    closeTableCell(optionsObjectOrColspan = {}, rowspan = void 0) {
      if (typeof optionsObjectOrColspan === "object") {
        this._closeTableCell(optionsObjectOrColspan);
      } else {
        this._closeTableCell({
          colspan: optionsObjectOrColspan,
          rowspan
        });
      }
    }
    _closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
      const cell = this._popStackItem();
      const text = trimCharacter(getText(cell), "\n");
      cell.next.cells.push({ colspan, rowspan, text });
    }
    /**
     * Finalize currently built table row and add it to parent table's rows.
     */
    closeTableRow() {
      const row = this._popStackItem();
      row.next.rows.push(row.cells);
    }
    /**
     * Finalize currently built table and add the rendered text to the parent block.
     *
     * @param { object | number } [optionsObjectOrColSpacing]
     * Object holding the parameters of the table.
     *
     * Number value is deprecated.
     *
     * @param { number } [optionsObjectOrColSpacing.colSpacing = 3]
     * Number of spaces between table columns.
     *
     * @param { number } [optionsObjectOrColSpacing.rowSpacing = 0]
     * Number of empty lines between table rows.
     *
     * @param { number } [optionsObjectOrColSpacing.leadingLineBreaks = 2]
     * This table should have at least this number of line breaks to separate if from any preceding block.
     *
     * @param { number } [optionsObjectOrColSpacing.trailingLineBreaks = 2]
     * This table should have at least this number of line breaks to separate it from any following block.
     *
     * @param { number } [rowSpacing]
     * Deprecated.
     *
     * @param { number } [leadingLineBreaks]
     * Deprecated.
     *
     * @param { number } [trailingLineBreaks]
     * Deprecated.
     */
    closeTable(optionsObjectOrColSpacing = {}, rowSpacing = void 0, leadingLineBreaks = void 0, trailingLineBreaks = void 0) {
      if (typeof optionsObjectOrColSpacing === "object") {
        this._closeTable(optionsObjectOrColSpacing);
      } else {
        this._closeTable({
          colSpacing: optionsObjectOrColSpacing,
          leadingLineBreaks,
          rowSpacing,
          trailingLineBreaks
        });
      }
    }
    _closeTable({ colSpacing = 3, rowSpacing = 0, leadingLineBreaks = 2, trailingLineBreaks = 2 } = {}) {
      const table = this._popStackItem();
      const output = tableToString(table.rows, rowSpacing, colSpacing);
      if (output) {
        addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
      }
    }
    /**
     * Return the rendered text content of this builder.
     *
     * @returns { string }
     */
    toString() {
      return getText(this._stackItem.getRoot());
    }
  }
  function getText(stackItem2) {
    if (!(stackItem2 instanceof BlockStackItem || stackItem2 instanceof TableCellStackItem)) {
      throw new Error("Only blocks and table cells can be requested for text contents.");
    }
    return stackItem2.inlineTextBuilder.isEmpty() ? stackItem2.rawText : stackItem2.rawText + stackItem2.inlineTextBuilder.toString();
  }
  function addText(stackItem2, text, leadingLineBreaks, trailingLineBreaks) {
    if (!(stackItem2 instanceof BlockStackItem || stackItem2 instanceof TableCellStackItem)) {
      throw new Error("Only blocks and table cells can contain text.");
    }
    const parentText = getText(stackItem2);
    const lineBreaks = Math.max(stackItem2.stashedLineBreaks, leadingLineBreaks);
    stackItem2.inlineTextBuilder.clear();
    if (parentText) {
      stackItem2.rawText = parentText + "\n".repeat(lineBreaks) + text;
    } else {
      stackItem2.rawText = text;
      stackItem2.leadingLineBreaks = lineBreaks;
    }
    stackItem2.stashedLineBreaks = trailingLineBreaks;
  }
  blockTextBuilder = { BlockTextBuilder };
  return blockTextBuilder;
}
var formatter;
var hasRequiredFormatter;
function requireFormatter() {
  if (hasRequiredFormatter) return formatter;
  hasRequiredFormatter = 1;
  const he2 = requireHe();
  const { get, numberToLetterSequence, numberToRoman, splitClassesAndIds, trimCharacter } = requireHelper();
  function formatSkip(elem, walk, builder, formatOptions) {
  }
  function formatInline(elem, walk, builder, formatOptions) {
    walk(elem.children, builder);
  }
  function formatBlock(elem, walk, builder, formatOptions) {
    builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
    walk(elem.children, builder);
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
  }
  function formatLineBreak(elem, walk, builder, formatOptions) {
    builder.addLineBreak();
  }
  function formatWbr(elem, walk, builder, formatOptions) {
    builder.addWordBreakOpportunity();
  }
  function formatHorizontalLine(elem, walk, builder, formatOptions) {
    builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
    builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
  }
  function formatParagraph(elem, walk, builder, formatOptions) {
    builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
    walk(elem.children, builder);
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
  }
  function formatPre(elem, walk, builder, formatOptions) {
    builder.openBlock({
      isPre: true,
      leadingLineBreaks: formatOptions.leadingLineBreaks || 2
    });
    walk(elem.children, builder);
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
  }
  function formatHeading(elem, walk, builder, formatOptions) {
    builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
    if (formatOptions.uppercase !== false) {
      builder.pushWordTransform((str) => str.toUpperCase());
      walk(elem.children, builder);
      builder.popWordTransform();
    } else {
      walk(elem.children, builder);
    }
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
  }
  function formatBlockquote(elem, walk, builder, formatOptions) {
    builder.openBlock({
      leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
      reservedLineLength: 2
    });
    walk(elem.children, builder);
    builder.closeBlock({
      trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
      blockTransform: (str) => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, "\n") : str).split("\n").map((line) => "> " + line).join("\n")
    });
  }
  function withBrackets(str, brackets) {
    if (!brackets) {
      return str;
    }
    const lbr2 = typeof brackets[0] === "string" ? brackets[0] : "[";
    const rbr2 = typeof brackets[1] === "string" ? brackets[1] : "]";
    return lbr2 + str + rbr2;
  }
  function formatImage(elem, walk, builder, formatOptions) {
    const attribs = elem.attribs || {};
    const alt = attribs.alt ? he2.decode(attribs.alt, builder.options.decodeOptions) : "";
    const src = !attribs.src ? "" : formatOptions.baseUrl && attribs.src.indexOf("/") === 0 ? formatOptions.baseUrl + attribs.src : attribs.src;
    const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
    builder.addInline(text);
  }
  function formatAnchor(elem, walk, builder, formatOptions) {
    function getHref() {
      if (formatOptions.ignoreHref) {
        return "";
      }
      if (!elem.attribs || !elem.attribs.href) {
        return "";
      }
      let href2 = elem.attribs.href.replace(/^mailto:/, "");
      if (formatOptions.noAnchorUrl && href2[0] === "#") {
        return "";
      }
      href2 = formatOptions.baseUrl && href2[0] === "/" ? formatOptions.baseUrl + href2 : href2;
      return he2.decode(href2, builder.options.decodeOptions);
    }
    const href = getHref();
    if (!href) {
      walk(elem.children, builder);
    } else {
      let text = "";
      builder.pushWordTransform(
        (str) => {
          if (str) {
            text += str;
          }
          return str;
        }
      );
      walk(elem.children, builder);
      builder.popWordTransform();
      const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;
      if (!hideSameLink) {
        builder.addInline(
          !text ? href : " " + withBrackets(href, formatOptions.linkBrackets),
          { noWordTransform: true }
        );
      }
    }
  }
  function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {
    const isNestedList = get(elem, ["parent", "name"]) === "li";
    let maxPrefixLength = 0;
    const listItems = (elem.children || []).filter((child) => child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
      if (child.name !== "li") {
        return { node: child, prefix: "" };
      }
      const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
      if (prefix.length > maxPrefixLength) {
        maxPrefixLength = prefix.length;
      }
      return { node: child, prefix };
    });
    if (!listItems.length) {
      return;
    }
    const reservedLineLength = maxPrefixLength;
    const spacing = "\n" + " ".repeat(reservedLineLength);
    builder.openBlock({ leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2 });
    for (const { node: node2, prefix } of listItems) {
      builder.openBlock({
        leadingLineBreaks: 1,
        reservedLineLength
      });
      walk([node2], builder);
      builder.closeBlock({
        trailingLineBreaks: 1,
        blockTransform: (str) => prefix + " ".repeat(reservedLineLength - prefix.length) + str.replace(/\n/g, spacing)
      });
    }
    builder.closeBlock({ trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2 });
  }
  function formatUnorderedList(elem, walk, builder, formatOptions) {
    const prefix = formatOptions.itemPrefix || " * ";
    return formatList(elem, walk, builder, formatOptions, () => prefix);
  }
  function formatOrderedList(elem, walk, builder, formatOptions) {
    let nextIndex = Number(elem.attribs.start || "1");
    const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
    const nextPrefixCallback = () => " " + indexFunction(nextIndex++) + ". ";
    return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
  }
  function getOrderedListIndexFunction(olType = "1") {
    switch (olType) {
      case "a":
        return (i) => numberToLetterSequence(i, "a");
      case "A":
        return (i) => numberToLetterSequence(i, "A");
      case "i":
        return (i) => numberToRoman(i).toLowerCase();
      case "I":
        return (i) => numberToRoman(i);
      case "1":
      default:
        return (i) => i.toString();
    }
  }
  function isDataTable(attr, tables) {
    if (tables === true) {
      return true;
    }
    if (!attr) {
      return false;
    }
    const { classes, ids } = splitClassesAndIds(tables);
    const attrClasses = (attr["class"] || "").split(" ");
    const attrIds = (attr["id"] || "").split(" ");
    return attrClasses.some((x2) => classes.includes(x2)) || attrIds.some((x2) => ids.includes(x2));
  }
  function formatTable(elem, walk, builder, formatOptions) {
    return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
  }
  function formatDataTable(elem, walk, builder, formatOptions) {
    builder.openTable();
    elem.children.forEach(walkTable);
    builder.closeTable({
      colSpacing: formatOptions.colSpacing,
      leadingLineBreaks: formatOptions.leadingLineBreaks,
      rowSpacing: formatOptions.rowSpacing,
      trailingLineBreaks: formatOptions.trailingLineBreaks
    });
    function formatCell(cellNode) {
      const colspan = +get(cellNode, ["attribs", "colspan"]) || 1;
      const rowspan = +get(cellNode, ["attribs", "rowspan"]) || 1;
      builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
      walk(cellNode.children, builder);
      builder.closeTableCell({ colspan, rowspan });
    }
    function walkTable(elem2) {
      if (elem2.type !== "tag") {
        return;
      }
      const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode) => {
        builder.pushWordTransform((str) => str.toUpperCase());
        formatCell(cellNode);
        builder.popWordTransform();
      } : formatCell;
      switch (elem2.name) {
        case "thead":
        case "tbody":
        case "tfoot":
        case "center":
          elem2.children.forEach(walkTable);
          return;
        case "tr": {
          builder.openTableRow();
          for (const childOfTr of elem2.children) {
            if (childOfTr.type !== "tag") {
              continue;
            }
            switch (childOfTr.name) {
              case "th": {
                formatHeaderCell(childOfTr);
                break;
              }
              case "td": {
                formatCell(childOfTr);
                break;
              }
            }
          }
          builder.closeTableRow();
          break;
        }
      }
    }
  }
  formatter = {
    anchor: formatAnchor,
    block: formatBlock,
    blockquote: formatBlockquote,
    dataTable: formatDataTable,
    heading: formatHeading,
    horizontalLine: formatHorizontalLine,
    image: formatImage,
    inline: formatInline,
    lineBreak: formatLineBreak,
    orderedList: formatOrderedList,
    paragraph: formatParagraph,
    pre: formatPre,
    skip: formatSkip,
    table: formatTable,
    unorderedList: formatUnorderedList,
    wbr: formatWbr
  };
  return formatter;
}
var htmlToText$1;
var hasRequiredHtmlToText$1;
function requireHtmlToText$1() {
  if (hasRequiredHtmlToText$1) return htmlToText$1;
  hasRequiredHtmlToText$1 = 1;
  const { hp2Builder: hp2Builder2 } = require$$0$2;
  const merge = requireCjs();
  const he2 = requireHe();
  const htmlparser = /* @__PURE__ */ requireLib();
  const selderee2 = require$$4;
  const { BlockTextBuilder } = requireBlockTextBuilder();
  const defaultFormatters = requireFormatter();
  const { limitedDepthRecursive, mergeDuplicatesPreferLast, get } = requireHelper();
  const DEFAULT_OPTIONS = {
    baseElements: {
      selectors: ["body"],
      orderBy: "selectors",
      // 'selectors' | 'occurrence'
      returnDomByDefault: true
    },
    decodeOptions: {
      isAttributeValue: false,
      strict: false
    },
    formatters: {},
    limits: {
      ellipsis: "...",
      maxBaseElements: void 0,
      maxChildNodes: void 0,
      maxDepth: void 0,
      maxInputLength: 1 << 24
      // 16_777_216
    },
    longWordSplit: {
      forceWrapOnLimit: false,
      wrapCharacters: []
    },
    preserveNewlines: false,
    selectors: [
      { selector: "*", format: "inline" },
      {
        selector: "a",
        format: "anchor",
        options: {
          baseUrl: null,
          hideLinkHrefIfSameAsText: false,
          ignoreHref: false,
          linkBrackets: ["[", "]"],
          noAnchorUrl: true
        }
      },
      { selector: "article", format: "block" },
      { selector: "aside", format: "block" },
      {
        selector: "blockquote",
        format: "blockquote",
        options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
      },
      { selector: "br", format: "lineBreak" },
      { selector: "div", format: "block" },
      { selector: "footer", format: "block" },
      { selector: "form", format: "block" },
      { selector: "h1", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h2", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h3", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h4", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h5", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h6", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
      { selector: "header", format: "block" },
      {
        selector: "hr",
        format: "horizontalLine",
        options: { leadingLineBreaks: 2, length: void 0, trailingLineBreaks: 2 }
      },
      {
        selector: "img",
        format: "image",
        options: { baseUrl: null, linkBrackets: ["[", "]"] }
      },
      { selector: "main", format: "block" },
      { selector: "nav", format: "block" },
      {
        selector: "ol",
        format: "orderedList",
        options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
      },
      { selector: "p", format: "paragraph", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
      { selector: "pre", format: "pre", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
      { selector: "section", format: "block" },
      {
        selector: "table",
        format: "table",
        options: {
          colSpacing: 3,
          leadingLineBreaks: 2,
          maxColumnWidth: 60,
          rowSpacing: 0,
          trailingLineBreaks: 2,
          uppercaseHeaderCells: true
        }
      },
      {
        selector: "ul",
        format: "unorderedList",
        options: { itemPrefix: " * ", leadingLineBreaks: 2, trailingLineBreaks: 2 }
      },
      { selector: "wbr", format: "wbr" }
    ],
    tables: [],
    // deprecated
    whitespaceCharacters: " 	\r\n\f​",
    wordwrap: 80
  };
  const concatMerge = (acc, src, options) => [...acc, ...src];
  const overwriteMerge = (acc, src, options) => [...src];
  const selectorsMerge = (acc, src, options) => acc.some((s) => typeof s === "object") ? concatMerge(acc, src) : overwriteMerge(acc, src);
  function compile(options = {}) {
    options = merge(
      DEFAULT_OPTIONS,
      options,
      {
        arrayMerge: overwriteMerge,
        customMerge: (key) => key === "selectors" ? selectorsMerge : void 0
      }
    );
    options.formatters = Object.assign({}, defaultFormatters, options.formatters);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, ((s) => s.selector));
    handleDeprecatedOptions(options);
    const selectorsWithoutFormat = options.selectors.filter((s) => !s.format);
    if (selectorsWithoutFormat.length) {
      throw new Error(
        "Following selectors have no specified format: " + selectorsWithoutFormat.map((s) => `\`${s.selector}\``).join(", ")
      );
    }
    const picker = new selderee2.DecisionTree(
      options.selectors.map((s) => [s.selector, s])
    ).build(hp2Builder2);
    const baseSelectorsPicker = new selderee2.DecisionTree(
      options.baseElements.selectors.map((s, i) => [s, i + 1])
    ).build(hp2Builder2);
    function findBaseElements(dom) {
      return findBases(dom, options, baseSelectorsPicker);
    }
    const limitedWalk = limitedDepthRecursive(
      options.limits.maxDepth,
      recursiveWalk,
      function(dom, builder) {
        builder.addInline(options.limits.ellipsis || "");
      }
    );
    return function(html2) {
      return process2(html2, options, picker, findBaseElements, limitedWalk);
    };
  }
  function process2(html2, options, picker, findBaseElements, walk) {
    const maxInputLength = options.limits.maxInputLength;
    if (maxInputLength && html2 && html2.length > maxInputLength) {
      console.warn(
        `Input length ${html2.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`
      );
      html2 = html2.substring(0, maxInputLength);
    }
    const handler = new htmlparser.DomHandler();
    new htmlparser.Parser(handler, { decodeEntities: false }).parseComplete(html2);
    const bases = findBaseElements(handler.dom);
    const builder = new BlockTextBuilder(options, picker);
    walk(bases, builder);
    return builder.toString();
  }
  function convert(html2, options = {}) {
    return compile(options)(html2);
  }
  function handleDeprecatedOptions(options) {
    const selectorDefinitions = options.selectors;
    if (options.tags) {
      const tagDefinitions = Object.entries(options.tags).map(
        ([selector, definition]) => ({ ...definition, selector: selector || "*" })
      );
      selectorDefinitions.push(...tagDefinitions);
    }
    function set(obj, path, value) {
      const valueKey = path.pop();
      for (const key of path) {
        let nested = obj[key];
        if (!nested) {
          nested = {};
          obj[key] = nested;
        }
        obj = nested;
      }
      obj[valueKey] = value;
    }
    function copyFormatterOption(source, format, target2) {
      if (options[source] === void 0) {
        return;
      }
      for (const definition of selectorDefinitions) {
        if (definition.format === format) {
          set(definition, ["options", target2], options[source]);
        }
      }
    }
    copyFormatterOption("hideLinkHrefIfSameAsText", "anchor", "hideLinkHrefIfSameAsText");
    copyFormatterOption("ignoreHref", "anchor", "ignoreHref");
    copyFormatterOption("linkHrefBaseUrl", "anchor", "baseUrl");
    copyFormatterOption("noAnchorUrl", "anchor", "noAnchorUrl");
    copyFormatterOption("noLinkBrackets", "anchor", "noLinkBrackets");
    copyFormatterOption("linkHrefBaseUrl", "image", "baseUrl");
    copyFormatterOption("unorderedListItemPrefix", "unorderedList", "itemPrefix");
    copyFormatterOption("uppercaseHeadings", "heading", "uppercase");
    copyFormatterOption("uppercaseHeadings", "table", "uppercaseHeadings");
    copyFormatterOption("uppercaseHeadings", "dataTable", "uppercaseHeadings");
    if (options["ignoreImage"]) {
      for (const definition of selectorDefinitions) {
        if (definition.format === "image") {
          definition.format = "skip";
        }
      }
    }
    if (options["singleNewLineParagraphs"]) {
      for (const definition of selectorDefinitions) {
        if (definition.format === "paragraph" || definition.format === "pre") {
          set(definition, ["options", "leadingLineBreaks"], 1);
          set(definition, ["options", "trailingLineBreaks"], 1);
        }
      }
    }
    if (options["baseElement"]) {
      const baseElement = options["baseElement"];
      set(
        options,
        ["baseElements", "selectors"],
        Array.isArray(baseElement) ? baseElement : [baseElement]
      );
    }
    if (options["returnDomByDefault"] !== void 0) {
      set(options, ["baseElements", "returnDomByDefault"], options["returnDomByDefault"]);
    }
    for (const definition of selectorDefinitions) {
      if (definition.format === "anchor" && get(definition, ["options", "noLinkBrackets"])) {
        set(definition, ["options", "linkBrackets"], false);
      }
    }
  }
  function findBases(dom, options, baseSelectorsPicker) {
    const results = [];
    function recursiveWalk2(walk, dom2) {
      dom2 = dom2.slice(0, options.limits.maxChildNodes);
      for (const elem of dom2) {
        if (elem.type !== "tag") {
          continue;
        }
        const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
        if (pickedSelectorIndex > 0) {
          results.push({ selectorIndex: pickedSelectorIndex, element: elem });
        } else if (elem.children) {
          walk(elem.children);
        }
        if (results.length >= options.limits.maxBaseElements) {
          return;
        }
      }
    }
    const limitedWalk = limitedDepthRecursive(
      options.limits.maxDepth,
      recursiveWalk2
    );
    limitedWalk(dom);
    if (options.baseElements.orderBy !== "occurrence") {
      results.sort((a, b2) => a.selectorIndex - b2.selectorIndex);
    }
    return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x2) => x2.element);
  }
  function recursiveWalk(walk, dom, builder) {
    if (!dom) {
      return;
    }
    const options = builder.options;
    const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
    if (tooManyChildNodes) {
      dom = dom.slice(0, options.limits.maxChildNodes);
      dom.push({
        data: options.limits.ellipsis,
        type: "text"
      });
    }
    for (const elem of dom) {
      switch (elem.type) {
        case "text": {
          builder.addInline(he2.decode(elem.data, options.decodeOptions));
          break;
        }
        case "tag": {
          const tagDefinition = builder.picker.pick1(elem);
          const format = options.formatters[tagDefinition.format];
          format(elem, walk, builder, tagDefinition.options || {});
          break;
        }
      }
    }
    return;
  }
  const fromString = (html2, options = {}) => convert(html2, options);
  htmlToText$1 = {
    compile,
    convert,
    fromString,
    htmlToText: convert
  };
  return htmlToText$1;
}
var htmlToText;
var hasRequiredHtmlToText;
function requireHtmlToText() {
  if (hasRequiredHtmlToText) return htmlToText;
  hasRequiredHtmlToText = 1;
  htmlToText = requireHtmlToText$1();
  return htmlToText;
}
var htmlToTextExports = requireHtmlToText();
function recursivelyMapDoc(doc, callback) {
  if (Array.isArray(doc)) return doc.map((innerDoc) => recursivelyMapDoc(innerDoc, callback));
  if (typeof doc === "object") {
    if (doc.type === "group") return {
      ...doc,
      contents: recursivelyMapDoc(doc.contents, callback),
      expandedStates: recursivelyMapDoc(doc.expandedStates, callback)
    };
    if ("contents" in doc) return {
      ...doc,
      contents: recursivelyMapDoc(doc.contents, callback)
    };
    if ("parts" in doc) return {
      ...doc,
      parts: recursivelyMapDoc(doc.parts, callback)
    };
    if (doc.type === "if-break") return {
      ...doc,
      breakContents: recursivelyMapDoc(doc.breakContents, callback),
      flatContents: recursivelyMapDoc(doc.flatContents, callback)
    };
  }
  return callback(doc);
}
const modifiedHtml = { ...html };
if (modifiedHtml.printers) {
  const previousPrint = modifiedHtml.printers.html.print;
  modifiedHtml.printers.html.print = (path, options, print, args) => {
    const node2 = path.getNode();
    const rawPrintingResult = previousPrint(path, options, print, args);
    if (node2.type === "ieConditionalComment") return recursivelyMapDoc(rawPrintingResult, (doc) => {
      if (typeof doc === "object" && doc.type === "line") return doc.soft ? "" : " ";
      return doc;
    });
    return rawPrintingResult;
  };
}
const defaults = {
  endOfLine: "lf",
  tabWidth: 2,
  plugins: [modifiedHtml],
  bracketSameLine: true,
  parser: "html"
};
const pretty = (str, options = {}) => {
  return Jn(str.replaceAll("\0", ""), {
    ...defaults,
    ...options
  });
};
const plainTextSelectors = [
  {
    selector: "img",
    format: "skip"
  },
  {
    selector: "[data-skip-in-text=true]",
    format: "skip"
  },
  {
    selector: "a",
    options: {
      linkBrackets: false,
      hideLinkHrefIfSameAsText: true
    }
  }
];
function toPlainText(html$1, options) {
  return htmlToTextExports.convert(html$1, {
    wordwrap: false,
    ...options,
    selectors: [...plainTextSelectors, ...options?.selectors ?? []]
  });
}
const readStream = async (stream) => {
  let result = "";
  const decoder = new TextDecoder("utf-8");
  if ("pipeTo" in stream) {
    const writableStream = new WritableStream({
      write(chunk) {
        result += decoder.decode(chunk, { stream: true });
      },
      close() {
        result += decoder.decode();
      }
    });
    await stream.pipeTo(writableStream);
  } else {
    const writable = new Writable({
      write(chunk, _encoding, callback) {
        result += decoder.decode(chunk, { stream: true });
        callback();
      },
      final(callback) {
        result += decoder.decode();
        callback();
      }
    });
    await new Promise((resolve, reject) => {
      writable.on("pipe", (source) => {
        source.on("error", (err) => {
          writable.destroy(err);
        });
      });
      writable.on("error", reject);
      writable.on("close", () => {
        resolve();
      });
      stream.pipe(writable);
    });
  }
  return result;
};
const render$1 = async (node2, options) => {
  const suspendedElement = /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { children: node2 });
  const reactDOMServer = await import("./server.mjs").then((n) => n.s).then((m) => {
    if ("default" in m) return m.default;
    return m;
  });
  let html$1;
  if (Object.hasOwn(reactDOMServer, "renderToReadableStream") && typeof WritableStream !== "undefined") html$1 = await readStream(await reactDOMServer.renderToReadableStream(suspendedElement, { progressiveChunkSize: Number.POSITIVE_INFINITY }));
  else await new Promise((resolve, reject) => {
    const stream = reactDOMServer.renderToPipeableStream(suspendedElement, {
      async onAllReady() {
        html$1 = await readStream(stream);
        resolve();
      },
      onError(error) {
        reject(error);
      },
      progressiveChunkSize: Number.POSITIVE_INFINITY
    });
  });
  if (options?.plainText) return toPlainText(html$1, options.htmlToTextOptions);
  const document = `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">${html$1.replace(/<!DOCTYPE.*?>/, "")}`;
  if (options?.pretty) return pretty(document);
  return document;
};
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  plainTextSelectors,
  pretty,
  render: render$1,
  toPlainText
}, Symbol.toStringTag, { value: "Module" }));
const Row = reactExports.forwardRef(({ children, style, ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("table", {
    align: "center",
    width: "100%",
    border: 0,
    cellPadding: "0",
    cellSpacing: "0",
    role: "presentation",
    ...props,
    ref,
    style,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", {
      style: { width: "100%" },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("tr", {
        style: { width: "100%" },
        children
      })
    })
  });
});
Row.displayName = "Row";
const Section = reactExports.forwardRef(({ children, style, ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("table", {
    align: "center",
    width: "100%",
    border: 0,
    cellPadding: "0",
    cellSpacing: "0",
    role: "presentation",
    ...props,
    ref,
    style,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children }) }) })
  });
});
Section.displayName = "Section";
function parseMarginValue(value) {
  if (typeof value === "number") return {
    marginTop: value,
    marginBottom: value,
    marginLeft: value,
    marginRight: value
  };
  if (typeof value === "string") {
    const values = value.toString().trim().split(/\s+/);
    if (values.length === 1) return {
      marginTop: values[0],
      marginBottom: values[0],
      marginLeft: values[0],
      marginRight: values[0]
    };
    if (values.length === 2) return {
      marginTop: values[0],
      marginRight: values[1],
      marginBottom: values[0],
      marginLeft: values[1]
    };
    if (values.length === 3) return {
      marginTop: values[0],
      marginRight: values[1],
      marginBottom: values[2],
      marginLeft: values[1]
    };
    if (values.length === 4) return {
      marginTop: values[0],
      marginRight: values[1],
      marginBottom: values[2],
      marginLeft: values[3]
    };
  }
  return {
    marginTop: void 0,
    marginBottom: void 0,
    marginLeft: void 0,
    marginRight: void 0
  };
}
function computeMargins(properties) {
  let result = {
    marginTop: void 0,
    marginRight: void 0,
    marginBottom: void 0,
    marginLeft: void 0
  };
  for (const [key, value] of Object.entries(properties)) if (key === "margin") result = parseMarginValue(value);
  else if (key === "marginTop") result.marginTop = value;
  else if (key === "marginRight") result.marginRight = value;
  else if (key === "marginBottom") result.marginBottom = value;
  else if (key === "marginLeft") result.marginLeft = value;
  return result;
}
const Text = reactExports.forwardRef(({ style, ...props }, ref) => {
  const defaultMargins = {};
  if (style?.marginTop === void 0) defaultMargins.marginTop = "16px";
  if (style?.marginBottom === void 0) defaultMargins.marginBottom = "16px";
  const margins = computeMargins({
    ...defaultMargins,
    ...style
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
    ...props,
    ref,
    style: {
      fontSize: "14px",
      lineHeight: "24px",
      ...style,
      ...margins
    }
  });
});
Text.displayName = "Text";
var dist$1 = {};
var application = {};
var applicationIn = {};
var hasRequiredApplicationIn;
function requireApplicationIn() {
  if (hasRequiredApplicationIn) return applicationIn;
  hasRequiredApplicationIn = 1;
  Object.defineProperty(applicationIn, "__esModule", { value: true });
  applicationIn.ApplicationInSerializer = void 0;
  applicationIn.ApplicationInSerializer = {
    _fromJsonObject(object) {
      return {
        metadata: object["metadata"],
        name: object["name"],
        rateLimit: object["rateLimit"],
        uid: object["uid"]
      };
    },
    _toJsonObject(self) {
      return {
        metadata: self.metadata,
        name: self.name,
        rateLimit: self.rateLimit,
        uid: self.uid
      };
    }
  };
  return applicationIn;
}
var applicationOut = {};
var hasRequiredApplicationOut;
function requireApplicationOut() {
  if (hasRequiredApplicationOut) return applicationOut;
  hasRequiredApplicationOut = 1;
  Object.defineProperty(applicationOut, "__esModule", { value: true });
  applicationOut.ApplicationOutSerializer = void 0;
  applicationOut.ApplicationOutSerializer = {
    _fromJsonObject(object) {
      return {
        createdAt: new Date(object["createdAt"]),
        id: object["id"],
        metadata: object["metadata"],
        name: object["name"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"])
      };
    },
    _toJsonObject(self) {
      return {
        createdAt: self.createdAt,
        id: self.id,
        metadata: self.metadata,
        name: self.name,
        rateLimit: self.rateLimit,
        uid: self.uid,
        updatedAt: self.updatedAt
      };
    }
  };
  return applicationOut;
}
var applicationPatch = {};
var hasRequiredApplicationPatch;
function requireApplicationPatch() {
  if (hasRequiredApplicationPatch) return applicationPatch;
  hasRequiredApplicationPatch = 1;
  Object.defineProperty(applicationPatch, "__esModule", { value: true });
  applicationPatch.ApplicationPatchSerializer = void 0;
  applicationPatch.ApplicationPatchSerializer = {
    _fromJsonObject(object) {
      return {
        metadata: object["metadata"],
        name: object["name"],
        rateLimit: object["rateLimit"],
        uid: object["uid"]
      };
    },
    _toJsonObject(self) {
      return {
        metadata: self.metadata,
        name: self.name,
        rateLimit: self.rateLimit,
        uid: self.uid
      };
    }
  };
  return applicationPatch;
}
var listResponseApplicationOut = {};
var hasRequiredListResponseApplicationOut;
function requireListResponseApplicationOut() {
  if (hasRequiredListResponseApplicationOut) return listResponseApplicationOut;
  hasRequiredListResponseApplicationOut = 1;
  Object.defineProperty(listResponseApplicationOut, "__esModule", { value: true });
  listResponseApplicationOut.ListResponseApplicationOutSerializer = void 0;
  const applicationOut_1 = requireApplicationOut();
  listResponseApplicationOut.ListResponseApplicationOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => applicationOut_1.ApplicationOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data.map((item) => applicationOut_1.ApplicationOutSerializer._toJsonObject(item)),
        done: self.done,
        iterator: self.iterator,
        prevIterator: self.prevIterator
      };
    }
  };
  return listResponseApplicationOut;
}
var request = {};
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", { value: true });
  util.ApiException = void 0;
  class ApiException extends Error {
    constructor(code, body, headers) {
      super(`HTTP-Code: ${code}
Headers: ${JSON.stringify(headers)}`);
      this.code = code;
      this.body = body;
      this.headers = {};
      headers.forEach((value, name) => {
        this.headers[name] = value;
      });
    }
  }
  util.ApiException = ApiException;
  return util;
}
var dist = {};
var max = {};
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  Object.defineProperty(max, "__esModule", {
    value: true
  });
  max.default = void 0;
  max.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
  return max;
}
var nil = {};
var hasRequiredNil;
function requireNil() {
  if (hasRequiredNil) return nil;
  hasRequiredNil = 1;
  Object.defineProperty(nil, "__esModule", {
    value: true
  });
  nil.default = void 0;
  nil.default = "00000000-0000-0000-0000-000000000000";
  return nil;
}
var parse = {};
var validate = {};
var regex = {};
var hasRequiredRegex;
function requireRegex() {
  if (hasRequiredRegex) return regex;
  hasRequiredRegex = 1;
  Object.defineProperty(regex, "__esModule", {
    value: true
  });
  regex.default = void 0;
  regex.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  return regex;
}
var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate;
  hasRequiredValidate = 1;
  Object.defineProperty(validate, "__esModule", {
    value: true
  });
  validate.default = void 0;
  var _regex = _interopRequireDefault(/* @__PURE__ */ requireRegex());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function validate$1(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  }
  validate.default = validate$1;
  return validate;
}
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  Object.defineProperty(parse, "__esModule", {
    value: true
  });
  parse.default = void 0;
  var _validate = _interopRequireDefault(/* @__PURE__ */ requireValidate());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function parse$1(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v2;
    const arr = new Uint8Array(16);
    arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v2 >>> 16 & 255;
    arr[2] = v2 >>> 8 & 255;
    arr[3] = v2 & 255;
    arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v2 & 255;
    arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v2 & 255;
    arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v2 & 255;
    arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v2 / 4294967296 & 255;
    arr[12] = v2 >>> 24 & 255;
    arr[13] = v2 >>> 16 & 255;
    arr[14] = v2 >>> 8 & 255;
    arr[15] = v2 & 255;
    return arr;
  }
  parse.default = parse$1;
  return parse;
}
var stringify = {};
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify;
  hasRequiredStringify = 1;
  Object.defineProperty(stringify, "__esModule", {
    value: true
  });
  stringify.default = void 0;
  stringify.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(/* @__PURE__ */ requireValidate());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  const byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }
  function stringify$12(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  stringify.default = stringify$12;
  return stringify;
}
var v1 = {};
var rng = {};
var hasRequiredRng;
function requireRng() {
  if (hasRequiredRng) return rng;
  hasRequiredRng = 1;
  Object.defineProperty(rng, "__esModule", {
    value: true
  });
  rng.default = rng$1;
  var _nodeCrypto = _interopRequireDefault(require$$0$3);
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  const rnds8Pool = new Uint8Array(256);
  let poolPtr = rnds8Pool.length;
  function rng$1() {
    if (poolPtr > rnds8Pool.length - 16) {
      _nodeCrypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
  return rng;
}
var hasRequiredV1;
function requireV1() {
  if (hasRequiredV1) return v1;
  hasRequiredV1 = 1;
  Object.defineProperty(v1, "__esModule", {
    value: true
  });
  v1.default = void 0;
  var _rng = _interopRequireDefault(/* @__PURE__ */ requireRng());
  var _stringify = /* @__PURE__ */ requireStringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  let _nodeId;
  let _clockseq;
  let _lastMSecs = 0;
  let _lastNSecs = 0;
  function v1$1(options, buf, offset) {
    let i = buf && offset || 0;
    const b2 = buf || new Array(16);
    options = options || {};
    let node2 = options.node;
    let clockseq = options.clockseq;
    if (!options._v6) {
      if (!node2) {
        node2 = _nodeId;
      }
      if (clockseq == null) {
        clockseq = _clockseq;
      }
    }
    if (node2 == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node2 == null) {
        node2 = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        if (!_nodeId && !options._v6) {
          node2[0] |= 1;
          _nodeId = node2;
        }
      }
      if (clockseq == null) {
        clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        if (_clockseq === void 0 && !options._v6) {
          _clockseq = clockseq;
        }
      }
    }
    let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
    let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
    const dt2 = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt2 < 0 && options.clockseq === void 0) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt2 < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 122192928e5;
    const tl2 = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b2[i++] = tl2 >>> 24 & 255;
    b2[i++] = tl2 >>> 16 & 255;
    b2[i++] = tl2 >>> 8 & 255;
    b2[i++] = tl2 & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b2[i++] = tmh >>> 8 & 255;
    b2[i++] = tmh & 255;
    b2[i++] = tmh >>> 24 & 15 | 16;
    b2[i++] = tmh >>> 16 & 255;
    b2[i++] = clockseq >>> 8 | 128;
    b2[i++] = clockseq & 255;
    for (let n = 0; n < 6; ++n) {
      b2[i + n] = node2[n];
    }
    return buf || (0, _stringify.unsafeStringify)(b2);
  }
  v1.default = v1$1;
  return v1;
}
var v1ToV6 = {};
var hasRequiredV1ToV6;
function requireV1ToV6() {
  if (hasRequiredV1ToV6) return v1ToV6;
  hasRequiredV1ToV6 = 1;
  Object.defineProperty(v1ToV6, "__esModule", {
    value: true
  });
  v1ToV6.default = v1ToV6$1;
  var _parse2 = _interopRequireDefault(/* @__PURE__ */ requireParse());
  var _stringify = /* @__PURE__ */ requireStringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v1ToV6$1(uuid) {
    const v1Bytes = typeof uuid === "string" ? (0, _parse2.default)(uuid) : uuid;
    const v6Bytes = _v1ToV6(v1Bytes);
    return typeof uuid === "string" ? (0, _stringify.unsafeStringify)(v6Bytes) : v6Bytes;
  }
  function _v1ToV6(v1Bytes, randomize = false) {
    return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
  }
  return v1ToV6;
}
var v3 = {};
var v35 = {};
var hasRequiredV35;
function requireV35() {
  if (hasRequiredV35) return v35;
  hasRequiredV35 = 1;
  Object.defineProperty(v35, "__esModule", {
    value: true
  });
  v35.URL = v35.DNS = void 0;
  v35.default = v35$1;
  var _stringify = /* @__PURE__ */ requireStringify();
  var _parse2 = _interopRequireDefault(/* @__PURE__ */ requireParse());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0; i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  }
  const DNS = v35.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  const URL2 = v35.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  function v35$1(name, version2, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      var _namespace;
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse2.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version2;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
  return v35;
}
var md5 = {};
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  Object.defineProperty(md5, "__esModule", {
    value: true
  });
  md5.default = void 0;
  var _nodeCrypto = _interopRequireDefault(require$$0$3);
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function md5$1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _nodeCrypto.default.createHash("md5").update(bytes).digest();
  }
  md5.default = md5$1;
  return md5;
}
var hasRequiredV3;
function requireV3() {
  if (hasRequiredV3) return v3;
  hasRequiredV3 = 1;
  Object.defineProperty(v3, "__esModule", {
    value: true
  });
  v3.default = void 0;
  var _v = _interopRequireDefault(/* @__PURE__ */ requireV35());
  var _md = _interopRequireDefault(/* @__PURE__ */ requireMd5());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  const v3$1 = (0, _v.default)("v3", 48, _md.default);
  v3.default = v3$1;
  return v3;
}
var v4 = {};
var native = {};
var hasRequiredNative;
function requireNative() {
  if (hasRequiredNative) return native;
  hasRequiredNative = 1;
  Object.defineProperty(native, "__esModule", {
    value: true
  });
  native.default = void 0;
  var _nodeCrypto = _interopRequireDefault(require$$0$3);
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  native.default = {
    randomUUID: _nodeCrypto.default.randomUUID
  };
  return native;
}
var hasRequiredV4;
function requireV4() {
  if (hasRequiredV4) return v4;
  hasRequiredV4 = 1;
  Object.defineProperty(v4, "__esModule", {
    value: true
  });
  v4.default = void 0;
  var _native = _interopRequireDefault(/* @__PURE__ */ requireNative());
  var _rng = _interopRequireDefault(/* @__PURE__ */ requireRng());
  var _stringify = /* @__PURE__ */ requireStringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v4$1(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  }
  v4.default = v4$1;
  return v4;
}
var v5 = {};
var sha1 = {};
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1;
  hasRequiredSha1 = 1;
  Object.defineProperty(sha1, "__esModule", {
    value: true
  });
  sha1.default = void 0;
  var _nodeCrypto = _interopRequireDefault(require$$0$3);
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function sha1$1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _nodeCrypto.default.createHash("sha1").update(bytes).digest();
  }
  sha1.default = sha1$1;
  return sha1;
}
var hasRequiredV5;
function requireV5() {
  if (hasRequiredV5) return v5;
  hasRequiredV5 = 1;
  Object.defineProperty(v5, "__esModule", {
    value: true
  });
  v5.default = void 0;
  var _v = _interopRequireDefault(/* @__PURE__ */ requireV35());
  var _sha = _interopRequireDefault(/* @__PURE__ */ requireSha1());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  const v5$1 = (0, _v.default)("v5", 80, _sha.default);
  v5.default = v5$1;
  return v5;
}
var v6 = {};
var hasRequiredV6;
function requireV6() {
  if (hasRequiredV6) return v6;
  hasRequiredV6 = 1;
  Object.defineProperty(v6, "__esModule", {
    value: true
  });
  v6.default = v6$1;
  var _stringify = /* @__PURE__ */ requireStringify();
  var _v = _interopRequireDefault(/* @__PURE__ */ requireV1());
  var _v1ToV = _interopRequireDefault(/* @__PURE__ */ requireV1ToV6());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v6$1(options = {}, buf, offset = 0) {
    let bytes = (0, _v.default)({
      ...options,
      _v6: true
    }, new Uint8Array(16));
    bytes = (0, _v1ToV.default)(bytes);
    if (buf) {
      for (let i = 0; i < 16; i++) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(bytes);
  }
  return v6;
}
var v6ToV1 = {};
var hasRequiredV6ToV1;
function requireV6ToV1() {
  if (hasRequiredV6ToV1) return v6ToV1;
  hasRequiredV6ToV1 = 1;
  Object.defineProperty(v6ToV1, "__esModule", {
    value: true
  });
  v6ToV1.default = v6ToV1$1;
  var _parse2 = _interopRequireDefault(/* @__PURE__ */ requireParse());
  var _stringify = /* @__PURE__ */ requireStringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v6ToV1$1(uuid) {
    const v6Bytes = typeof uuid === "string" ? (0, _parse2.default)(uuid) : uuid;
    const v1Bytes = _v6ToV1(v6Bytes);
    return typeof uuid === "string" ? (0, _stringify.unsafeStringify)(v1Bytes) : v1Bytes;
  }
  function _v6ToV1(v6Bytes) {
    return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
  }
  return v6ToV1;
}
var v7 = {};
var hasRequiredV7;
function requireV7() {
  if (hasRequiredV7) return v7;
  hasRequiredV7 = 1;
  Object.defineProperty(v7, "__esModule", {
    value: true
  });
  v7.default = void 0;
  var _rng = _interopRequireDefault(/* @__PURE__ */ requireRng());
  var _stringify = /* @__PURE__ */ requireStringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  let _seqLow = null;
  let _seqHigh = null;
  let _msecs = 0;
  function v7$1(options, buf, offset) {
    options = options || {};
    let i = buf && offset || 0;
    const b2 = buf || new Uint8Array(16);
    const rnds = options.random || (options.rng || _rng.default)();
    const msecs = options.msecs !== void 0 ? options.msecs : Date.now();
    let seq = options.seq !== void 0 ? options.seq : null;
    let seqHigh = _seqHigh;
    let seqLow = _seqLow;
    if (msecs > _msecs && options.msecs === void 0) {
      _msecs = msecs;
      if (seq !== null) {
        seqHigh = null;
        seqLow = null;
      }
    }
    if (seq !== null) {
      if (seq > 2147483647) {
        seq = 2147483647;
      }
      seqHigh = seq >>> 19 & 4095;
      seqLow = seq & 524287;
    }
    if (seqHigh === null || seqLow === null) {
      seqHigh = rnds[6] & 127;
      seqHigh = seqHigh << 8 | rnds[7];
      seqLow = rnds[8] & 63;
      seqLow = seqLow << 8 | rnds[9];
      seqLow = seqLow << 5 | rnds[10] >>> 3;
    }
    if (msecs + 1e4 > _msecs && seq === null) {
      if (++seqLow > 524287) {
        seqLow = 0;
        if (++seqHigh > 4095) {
          seqHigh = 0;
          _msecs++;
        }
      }
    } else {
      _msecs = msecs;
    }
    _seqHigh = seqHigh;
    _seqLow = seqLow;
    b2[i++] = _msecs / 1099511627776 & 255;
    b2[i++] = _msecs / 4294967296 & 255;
    b2[i++] = _msecs / 16777216 & 255;
    b2[i++] = _msecs / 65536 & 255;
    b2[i++] = _msecs / 256 & 255;
    b2[i++] = _msecs & 255;
    b2[i++] = seqHigh >>> 4 & 15 | 112;
    b2[i++] = seqHigh & 255;
    b2[i++] = seqLow >>> 13 & 63 | 128;
    b2[i++] = seqLow >>> 5 & 255;
    b2[i++] = seqLow << 3 & 255 | rnds[10] & 7;
    b2[i++] = rnds[11];
    b2[i++] = rnds[12];
    b2[i++] = rnds[13];
    b2[i++] = rnds[14];
    b2[i++] = rnds[15];
    return buf || (0, _stringify.unsafeStringify)(b2);
  }
  v7.default = v7$1;
  return v7;
}
var version$1 = {};
var hasRequiredVersion;
function requireVersion() {
  if (hasRequiredVersion) return version$1;
  hasRequiredVersion = 1;
  Object.defineProperty(version$1, "__esModule", {
    value: true
  });
  version$1.default = void 0;
  var _validate = _interopRequireDefault(/* @__PURE__ */ requireValidate());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function version2(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  }
  version$1.default = version2;
  return version$1;
}
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist;
  hasRequiredDist$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", {
      value: true
    });
    Object.defineProperty(exports$1, "MAX", {
      enumerable: true,
      get: function() {
        return _max.default;
      }
    });
    Object.defineProperty(exports$1, "NIL", {
      enumerable: true,
      get: function() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports$1, "parse", {
      enumerable: true,
      get: function() {
        return _parse2.default;
      }
    });
    Object.defineProperty(exports$1, "stringify", {
      enumerable: true,
      get: function() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports$1, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports$1, "v1ToV6", {
      enumerable: true,
      get: function() {
        return _v1ToV.default;
      }
    });
    Object.defineProperty(exports$1, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports$1, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports$1, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports$1, "v6", {
      enumerable: true,
      get: function() {
        return _v5.default;
      }
    });
    Object.defineProperty(exports$1, "v6ToV1", {
      enumerable: true,
      get: function() {
        return _v6ToV.default;
      }
    });
    Object.defineProperty(exports$1, "v7", {
      enumerable: true,
      get: function() {
        return _v6.default;
      }
    });
    Object.defineProperty(exports$1, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports$1, "version", {
      enumerable: true,
      get: function() {
        return _version.default;
      }
    });
    var _max = _interopRequireDefault(/* @__PURE__ */ requireMax());
    var _nil = _interopRequireDefault(/* @__PURE__ */ requireNil());
    var _parse2 = _interopRequireDefault(/* @__PURE__ */ requireParse());
    var _stringify = _interopRequireDefault(/* @__PURE__ */ requireStringify());
    var _v = _interopRequireDefault(/* @__PURE__ */ requireV1());
    var _v1ToV = _interopRequireDefault(/* @__PURE__ */ requireV1ToV6());
    var _v2 = _interopRequireDefault(/* @__PURE__ */ requireV3());
    var _v3 = _interopRequireDefault(/* @__PURE__ */ requireV4());
    var _v4 = _interopRequireDefault(/* @__PURE__ */ requireV5());
    var _v5 = _interopRequireDefault(/* @__PURE__ */ requireV6());
    var _v6ToV = _interopRequireDefault(/* @__PURE__ */ requireV6ToV1());
    var _v6 = _interopRequireDefault(/* @__PURE__ */ requireV7());
    var _validate = _interopRequireDefault(/* @__PURE__ */ requireValidate());
    var _version = _interopRequireDefault(/* @__PURE__ */ requireVersion());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
  })(dist);
  return dist;
}
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest) return request;
  hasRequiredRequest = 1;
  (function(exports$1) {
    var __awaiter = request && request.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.SvixRequest = exports$1.HttpMethod = exports$1.LIB_VERSION = void 0;
    const util_1 = requireUtil();
    const uuid_1 = /* @__PURE__ */ requireDist$1();
    exports$1.LIB_VERSION = "1.76.1";
    const USER_AGENT = `svix-libs/${exports$1.LIB_VERSION}/javascript`;
    (function(HttpMethod) {
      HttpMethod["GET"] = "GET";
      HttpMethod["HEAD"] = "HEAD";
      HttpMethod["POST"] = "POST";
      HttpMethod["PUT"] = "PUT";
      HttpMethod["DELETE"] = "DELETE";
      HttpMethod["CONNECT"] = "CONNECT";
      HttpMethod["OPTIONS"] = "OPTIONS";
      HttpMethod["TRACE"] = "TRACE";
      HttpMethod["PATCH"] = "PATCH";
    })(exports$1.HttpMethod || (exports$1.HttpMethod = {}));
    class SvixRequest {
      constructor(method, path) {
        this.method = method;
        this.path = path;
        this.queryParams = {};
        this.headerParams = {};
      }
      setPathParam(name, value) {
        const newPath = this.path.replace(`{${name}}`, encodeURIComponent(value));
        if (this.path === newPath) {
          throw new Error(`path parameter ${name} not found`);
        }
        this.path = newPath;
      }
      setQueryParam(name, value) {
        if (value === void 0 || value === null) {
          return;
        }
        if (typeof value === "string") {
          this.queryParams[name] = value;
        } else if (typeof value === "boolean" || typeof value === "number") {
          this.queryParams[name] = value.toString();
        } else if (value instanceof Date) {
          this.queryParams[name] = value.toISOString();
        } else if (value instanceof Array) {
          if (value.length > 0) {
            this.queryParams[name] = value.join(",");
          }
        } else {
          throw new Error(`query parameter ${name} has unsupported type`);
        }
      }
      setHeaderParam(name, value) {
        if (value === void 0) {
          return;
        }
        this.headerParams[name] = value;
      }
      setBody(value) {
        this.body = JSON.stringify(value);
      }
      send(ctx, parseResponseBody) {
        return __awaiter(this, void 0, void 0, function* () {
          const response = yield this.sendInner(ctx);
          if (response.status == 204) {
            return null;
          }
          const responseBody = yield response.text();
          return parseResponseBody(JSON.parse(responseBody));
        });
      }
      sendNoResponseBody(ctx) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.sendInner(ctx);
        });
      }
      sendInner(ctx) {
        var _a2, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const url = new URL(ctx.baseUrl + this.path);
          for (const [name, value] of Object.entries(this.queryParams)) {
            url.searchParams.set(name, value);
          }
          if (this.headerParams["idempotency-key"] === void 0 && this.method.toUpperCase() === "POST") {
            this.headerParams["idempotency-key"] = "auto_" + (0, uuid_1.v4)();
          }
          const randomId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
          if (this.body != null) {
            this.headerParams["content-type"] = "application/json";
          }
          const isCredentialsSupported = "credentials" in Request.prototype;
          const response = yield sendWithRetry(url, {
            method: this.method.toString(),
            body: this.body,
            headers: Object.assign({ accept: "application/json, */*;q=0.8", authorization: `Bearer ${ctx.token}`, "user-agent": USER_AGENT, "svix-req-id": randomId.toString() }, this.headerParams),
            credentials: isCredentialsSupported ? "same-origin" : void 0,
            signal: ctx.timeout !== void 0 ? AbortSignal.timeout(ctx.timeout) : void 0
          }, ctx.retryScheduleInMs, (_a2 = ctx.retryScheduleInMs) === null || _a2 === void 0 ? void 0 : _a2[0], ((_b = ctx.retryScheduleInMs) === null || _b === void 0 ? void 0 : _b.length) || ctx.numRetries);
          return filterResponseForErrors(response);
        });
      }
    }
    exports$1.SvixRequest = SvixRequest;
    function filterResponseForErrors(response) {
      return __awaiter(this, void 0, void 0, function* () {
        if (response.status < 300) {
          return response;
        }
        const responseBody = yield response.text();
        if (response.status === 422) {
          throw new util_1.ApiException(response.status, JSON.parse(responseBody), response.headers);
        }
        if (response.status >= 400 && response.status <= 499) {
          throw new util_1.ApiException(response.status, JSON.parse(responseBody), response.headers);
        }
        throw new util_1.ApiException(response.status, responseBody, response.headers);
      });
    }
    function sendWithRetry(url, init, retryScheduleInMs, nextInterval = 50, triesLeft = 2, retryCount = 1) {
      return __awaiter(this, void 0, void 0, function* () {
        const sleep = (interval) => new Promise((resolve) => setTimeout(resolve, interval));
        try {
          const response = yield fetch(url, init);
          if (triesLeft <= 0 || response.status < 500) {
            return response;
          }
        } catch (e) {
          if (triesLeft <= 0) {
            throw e;
          }
        }
        yield sleep(nextInterval);
        init.headers["svix-retry-count"] = retryCount.toString();
        nextInterval = (retryScheduleInMs === null || retryScheduleInMs === void 0 ? void 0 : retryScheduleInMs[retryCount]) || nextInterval * 2;
        return yield sendWithRetry(url, init, retryScheduleInMs, nextInterval, --triesLeft, ++retryCount);
      });
    }
  })(request);
  return request;
}
var hasRequiredApplication;
function requireApplication() {
  if (hasRequiredApplication) return application;
  hasRequiredApplication = 1;
  Object.defineProperty(application, "__esModule", { value: true });
  application.Application = void 0;
  const applicationIn_1 = requireApplicationIn();
  const applicationOut_1 = requireApplicationOut();
  const applicationPatch_1 = requireApplicationPatch();
  const listResponseApplicationOut_1 = requireListResponseApplicationOut();
  const request_1 = requireRequest();
  class Application {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app");
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      request2.setQueryParam("order", options === null || options === void 0 ? void 0 : options.order);
      return request2.send(this.requestCtx, listResponseApplicationOut_1.ListResponseApplicationOutSerializer._fromJsonObject);
    }
    create(applicationIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app");
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(applicationIn_1.ApplicationInSerializer._toJsonObject(applicationIn2));
      return request2.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
    getOrCreate(applicationIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app");
      request2.setQueryParam("get_if_exists", true);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(applicationIn_1.ApplicationInSerializer._toJsonObject(applicationIn2));
      return request2.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
    get(appId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}");
      request2.setPathParam("app_id", appId);
      return request2.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
    update(appId, applicationIn2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/app/{app_id}");
      request2.setPathParam("app_id", appId);
      request2.setBody(applicationIn_1.ApplicationInSerializer._toJsonObject(applicationIn2));
      return request2.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
    delete(appId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}");
      request2.setPathParam("app_id", appId);
      return request2.sendNoResponseBody(this.requestCtx);
    }
    patch(appId, applicationPatch2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}");
      request2.setPathParam("app_id", appId);
      request2.setBody(applicationPatch_1.ApplicationPatchSerializer._toJsonObject(applicationPatch2));
      return request2.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
  }
  application.Application = Application;
  return application;
}
var authentication = {};
var appPortalAccessIn = {};
var appPortalCapability = {};
var hasRequiredAppPortalCapability;
function requireAppPortalCapability() {
  if (hasRequiredAppPortalCapability) return appPortalCapability;
  hasRequiredAppPortalCapability = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.AppPortalCapabilitySerializer = exports$1.AppPortalCapability = void 0;
    (function(AppPortalCapability) {
      AppPortalCapability["ViewBase"] = "ViewBase";
      AppPortalCapability["ViewEndpointSecret"] = "ViewEndpointSecret";
      AppPortalCapability["ManageEndpointSecret"] = "ManageEndpointSecret";
      AppPortalCapability["ManageTransformations"] = "ManageTransformations";
      AppPortalCapability["CreateAttempts"] = "CreateAttempts";
      AppPortalCapability["ManageEndpoint"] = "ManageEndpoint";
    })(exports$1.AppPortalCapability || (exports$1.AppPortalCapability = {}));
    exports$1.AppPortalCapabilitySerializer = {
      _fromJsonObject(object) {
        return object;
      },
      _toJsonObject(self) {
        return self;
      }
    };
  })(appPortalCapability);
  return appPortalCapability;
}
var hasRequiredAppPortalAccessIn;
function requireAppPortalAccessIn() {
  if (hasRequiredAppPortalAccessIn) return appPortalAccessIn;
  hasRequiredAppPortalAccessIn = 1;
  Object.defineProperty(appPortalAccessIn, "__esModule", { value: true });
  appPortalAccessIn.AppPortalAccessInSerializer = void 0;
  const appPortalCapability_1 = requireAppPortalCapability();
  const applicationIn_1 = requireApplicationIn();
  appPortalAccessIn.AppPortalAccessInSerializer = {
    _fromJsonObject(object) {
      var _a2;
      return {
        application: object["application"] ? applicationIn_1.ApplicationInSerializer._fromJsonObject(object["application"]) : void 0,
        capabilities: (_a2 = object["capabilities"]) === null || _a2 === void 0 ? void 0 : _a2.map((item) => appPortalCapability_1.AppPortalCapabilitySerializer._fromJsonObject(item)),
        expiry: object["expiry"],
        featureFlags: object["featureFlags"],
        readOnly: object["readOnly"],
        sessionId: object["sessionId"]
      };
    },
    _toJsonObject(self) {
      var _a2;
      return {
        application: self.application ? applicationIn_1.ApplicationInSerializer._toJsonObject(self.application) : void 0,
        capabilities: (_a2 = self.capabilities) === null || _a2 === void 0 ? void 0 : _a2.map((item) => appPortalCapability_1.AppPortalCapabilitySerializer._toJsonObject(item)),
        expiry: self.expiry,
        featureFlags: self.featureFlags,
        readOnly: self.readOnly,
        sessionId: self.sessionId
      };
    }
  };
  return appPortalAccessIn;
}
var appPortalAccessOut = {};
var hasRequiredAppPortalAccessOut;
function requireAppPortalAccessOut() {
  if (hasRequiredAppPortalAccessOut) return appPortalAccessOut;
  hasRequiredAppPortalAccessOut = 1;
  Object.defineProperty(appPortalAccessOut, "__esModule", { value: true });
  appPortalAccessOut.AppPortalAccessOutSerializer = void 0;
  appPortalAccessOut.AppPortalAccessOutSerializer = {
    _fromJsonObject(object) {
      return {
        token: object["token"],
        url: object["url"]
      };
    },
    _toJsonObject(self) {
      return {
        token: self.token,
        url: self.url
      };
    }
  };
  return appPortalAccessOut;
}
var applicationTokenExpireIn = {};
var hasRequiredApplicationTokenExpireIn;
function requireApplicationTokenExpireIn() {
  if (hasRequiredApplicationTokenExpireIn) return applicationTokenExpireIn;
  hasRequiredApplicationTokenExpireIn = 1;
  Object.defineProperty(applicationTokenExpireIn, "__esModule", { value: true });
  applicationTokenExpireIn.ApplicationTokenExpireInSerializer = void 0;
  applicationTokenExpireIn.ApplicationTokenExpireInSerializer = {
    _fromJsonObject(object) {
      return {
        expiry: object["expiry"],
        sessionIds: object["sessionIds"]
      };
    },
    _toJsonObject(self) {
      return {
        expiry: self.expiry,
        sessionIds: self.sessionIds
      };
    }
  };
  return applicationTokenExpireIn;
}
var dashboardAccessOut = {};
var hasRequiredDashboardAccessOut;
function requireDashboardAccessOut() {
  if (hasRequiredDashboardAccessOut) return dashboardAccessOut;
  hasRequiredDashboardAccessOut = 1;
  Object.defineProperty(dashboardAccessOut, "__esModule", { value: true });
  dashboardAccessOut.DashboardAccessOutSerializer = void 0;
  dashboardAccessOut.DashboardAccessOutSerializer = {
    _fromJsonObject(object) {
      return {
        token: object["token"],
        url: object["url"]
      };
    },
    _toJsonObject(self) {
      return {
        token: self.token,
        url: self.url
      };
    }
  };
  return dashboardAccessOut;
}
var hasRequiredAuthentication;
function requireAuthentication() {
  if (hasRequiredAuthentication) return authentication;
  hasRequiredAuthentication = 1;
  Object.defineProperty(authentication, "__esModule", { value: true });
  authentication.Authentication = void 0;
  const appPortalAccessIn_1 = requireAppPortalAccessIn();
  const appPortalAccessOut_1 = requireAppPortalAccessOut();
  const applicationTokenExpireIn_1 = requireApplicationTokenExpireIn();
  const dashboardAccessOut_1 = requireDashboardAccessOut();
  const request_1 = requireRequest();
  class Authentication {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    appPortalAccess(appId, appPortalAccessIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/app-portal-access/{app_id}");
      request2.setPathParam("app_id", appId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(appPortalAccessIn_1.AppPortalAccessInSerializer._toJsonObject(appPortalAccessIn2));
      return request2.send(this.requestCtx, appPortalAccessOut_1.AppPortalAccessOutSerializer._fromJsonObject);
    }
    expireAll(appId, applicationTokenExpireIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/app/{app_id}/expire-all");
      request2.setPathParam("app_id", appId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(applicationTokenExpireIn_1.ApplicationTokenExpireInSerializer._toJsonObject(applicationTokenExpireIn2));
      return request2.sendNoResponseBody(this.requestCtx);
    }
    dashboardAccess(appId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/dashboard-access/{app_id}");
      request2.setPathParam("app_id", appId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      return request2.send(this.requestCtx, dashboardAccessOut_1.DashboardAccessOutSerializer._fromJsonObject);
    }
    logout(options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/logout");
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      return request2.sendNoResponseBody(this.requestCtx);
    }
  }
  authentication.Authentication = Authentication;
  return authentication;
}
var backgroundTask = {};
var backgroundTaskOut = {};
var backgroundTaskStatus = {};
var hasRequiredBackgroundTaskStatus;
function requireBackgroundTaskStatus() {
  if (hasRequiredBackgroundTaskStatus) return backgroundTaskStatus;
  hasRequiredBackgroundTaskStatus = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.BackgroundTaskStatusSerializer = exports$1.BackgroundTaskStatus = void 0;
    (function(BackgroundTaskStatus) {
      BackgroundTaskStatus["Running"] = "running";
      BackgroundTaskStatus["Finished"] = "finished";
      BackgroundTaskStatus["Failed"] = "failed";
    })(exports$1.BackgroundTaskStatus || (exports$1.BackgroundTaskStatus = {}));
    exports$1.BackgroundTaskStatusSerializer = {
      _fromJsonObject(object) {
        return object;
      },
      _toJsonObject(self) {
        return self;
      }
    };
  })(backgroundTaskStatus);
  return backgroundTaskStatus;
}
var backgroundTaskType = {};
var hasRequiredBackgroundTaskType;
function requireBackgroundTaskType() {
  if (hasRequiredBackgroundTaskType) return backgroundTaskType;
  hasRequiredBackgroundTaskType = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.BackgroundTaskTypeSerializer = exports$1.BackgroundTaskType = void 0;
    (function(BackgroundTaskType) {
      BackgroundTaskType["EndpointReplay"] = "endpoint.replay";
      BackgroundTaskType["EndpointRecover"] = "endpoint.recover";
      BackgroundTaskType["ApplicationStats"] = "application.stats";
      BackgroundTaskType["MessageBroadcast"] = "message.broadcast";
      BackgroundTaskType["SdkGenerate"] = "sdk.generate";
      BackgroundTaskType["EventTypeAggregate"] = "event-type.aggregate";
      BackgroundTaskType["ApplicationPurgeContent"] = "application.purge_content";
    })(exports$1.BackgroundTaskType || (exports$1.BackgroundTaskType = {}));
    exports$1.BackgroundTaskTypeSerializer = {
      _fromJsonObject(object) {
        return object;
      },
      _toJsonObject(self) {
        return self;
      }
    };
  })(backgroundTaskType);
  return backgroundTaskType;
}
var hasRequiredBackgroundTaskOut;
function requireBackgroundTaskOut() {
  if (hasRequiredBackgroundTaskOut) return backgroundTaskOut;
  hasRequiredBackgroundTaskOut = 1;
  Object.defineProperty(backgroundTaskOut, "__esModule", { value: true });
  backgroundTaskOut.BackgroundTaskOutSerializer = void 0;
  const backgroundTaskStatus_1 = requireBackgroundTaskStatus();
  const backgroundTaskType_1 = requireBackgroundTaskType();
  backgroundTaskOut.BackgroundTaskOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"],
        id: object["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object["task"])
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data,
        id: self.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self.task)
      };
    }
  };
  return backgroundTaskOut;
}
var listResponseBackgroundTaskOut = {};
var hasRequiredListResponseBackgroundTaskOut;
function requireListResponseBackgroundTaskOut() {
  if (hasRequiredListResponseBackgroundTaskOut) return listResponseBackgroundTaskOut;
  hasRequiredListResponseBackgroundTaskOut = 1;
  Object.defineProperty(listResponseBackgroundTaskOut, "__esModule", { value: true });
  listResponseBackgroundTaskOut.ListResponseBackgroundTaskOutSerializer = void 0;
  const backgroundTaskOut_1 = requireBackgroundTaskOut();
  listResponseBackgroundTaskOut.ListResponseBackgroundTaskOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => backgroundTaskOut_1.BackgroundTaskOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data.map((item) => backgroundTaskOut_1.BackgroundTaskOutSerializer._toJsonObject(item)),
        done: self.done,
        iterator: self.iterator,
        prevIterator: self.prevIterator
      };
    }
  };
  return listResponseBackgroundTaskOut;
}
var hasRequiredBackgroundTask;
function requireBackgroundTask() {
  if (hasRequiredBackgroundTask) return backgroundTask;
  hasRequiredBackgroundTask = 1;
  Object.defineProperty(backgroundTask, "__esModule", { value: true });
  backgroundTask.BackgroundTask = void 0;
  const backgroundTaskOut_1 = requireBackgroundTaskOut();
  const listResponseBackgroundTaskOut_1 = requireListResponseBackgroundTaskOut();
  const request_1 = requireRequest();
  class BackgroundTask {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/background-task");
      request2.setQueryParam("status", options === null || options === void 0 ? void 0 : options.status);
      request2.setQueryParam("task", options === null || options === void 0 ? void 0 : options.task);
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      request2.setQueryParam("order", options === null || options === void 0 ? void 0 : options.order);
      return request2.send(this.requestCtx, listResponseBackgroundTaskOut_1.ListResponseBackgroundTaskOutSerializer._fromJsonObject);
    }
    listByEndpoint(options) {
      return this.list(options);
    }
    get(taskId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/background-task/{task_id}");
      request2.setPathParam("task_id", taskId);
      return request2.send(this.requestCtx, backgroundTaskOut_1.BackgroundTaskOutSerializer._fromJsonObject);
    }
  }
  backgroundTask.BackgroundTask = BackgroundTask;
  return backgroundTask;
}
var endpoint = {};
var endpointHeadersIn = {};
var hasRequiredEndpointHeadersIn;
function requireEndpointHeadersIn() {
  if (hasRequiredEndpointHeadersIn) return endpointHeadersIn;
  hasRequiredEndpointHeadersIn = 1;
  Object.defineProperty(endpointHeadersIn, "__esModule", { value: true });
  endpointHeadersIn.EndpointHeadersInSerializer = void 0;
  endpointHeadersIn.EndpointHeadersInSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"]
      };
    },
    _toJsonObject(self) {
      return {
        headers: self.headers
      };
    }
  };
  return endpointHeadersIn;
}
var endpointHeadersOut = {};
var hasRequiredEndpointHeadersOut;
function requireEndpointHeadersOut() {
  if (hasRequiredEndpointHeadersOut) return endpointHeadersOut;
  hasRequiredEndpointHeadersOut = 1;
  Object.defineProperty(endpointHeadersOut, "__esModule", { value: true });
  endpointHeadersOut.EndpointHeadersOutSerializer = void 0;
  endpointHeadersOut.EndpointHeadersOutSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"],
        sensitive: object["sensitive"]
      };
    },
    _toJsonObject(self) {
      return {
        headers: self.headers,
        sensitive: self.sensitive
      };
    }
  };
  return endpointHeadersOut;
}
var endpointHeadersPatchIn = {};
var hasRequiredEndpointHeadersPatchIn;
function requireEndpointHeadersPatchIn() {
  if (hasRequiredEndpointHeadersPatchIn) return endpointHeadersPatchIn;
  hasRequiredEndpointHeadersPatchIn = 1;
  Object.defineProperty(endpointHeadersPatchIn, "__esModule", { value: true });
  endpointHeadersPatchIn.EndpointHeadersPatchInSerializer = void 0;
  endpointHeadersPatchIn.EndpointHeadersPatchInSerializer = {
    _fromJsonObject(object) {
      return {
        deleteHeaders: object["deleteHeaders"],
        headers: object["headers"]
      };
    },
    _toJsonObject(self) {
      return {
        deleteHeaders: self.deleteHeaders,
        headers: self.headers
      };
    }
  };
  return endpointHeadersPatchIn;
}
var endpointIn = {};
var hasRequiredEndpointIn;
function requireEndpointIn() {
  if (hasRequiredEndpointIn) return endpointIn;
  hasRequiredEndpointIn = 1;
  Object.defineProperty(endpointIn, "__esModule", { value: true });
  endpointIn.EndpointInSerializer = void 0;
  endpointIn.EndpointInSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        headers: object["headers"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        secret: object["secret"],
        uid: object["uid"],
        url: object["url"],
        version: object["version"]
      };
    },
    _toJsonObject(self) {
      return {
        channels: self.channels,
        description: self.description,
        disabled: self.disabled,
        filterTypes: self.filterTypes,
        headers: self.headers,
        metadata: self.metadata,
        rateLimit: self.rateLimit,
        secret: self.secret,
        uid: self.uid,
        url: self.url,
        version: self.version
      };
    }
  };
  return endpointIn;
}
var endpointOut = {};
var hasRequiredEndpointOut;
function requireEndpointOut() {
  if (hasRequiredEndpointOut) return endpointOut;
  hasRequiredEndpointOut = 1;
  Object.defineProperty(endpointOut, "__esModule", { value: true });
  endpointOut.EndpointOutSerializer = void 0;
  endpointOut.EndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        createdAt: new Date(object["createdAt"]),
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        id: object["id"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"]),
        url: object["url"],
        version: object["version"]
      };
    },
    _toJsonObject(self) {
      return {
        channels: self.channels,
        createdAt: self.createdAt,
        description: self.description,
        disabled: self.disabled,
        filterTypes: self.filterTypes,
        id: self.id,
        metadata: self.metadata,
        rateLimit: self.rateLimit,
        uid: self.uid,
        updatedAt: self.updatedAt,
        url: self.url,
        version: self.version
      };
    }
  };
  return endpointOut;
}
var endpointPatch = {};
var hasRequiredEndpointPatch;
function requireEndpointPatch() {
  if (hasRequiredEndpointPatch) return endpointPatch;
  hasRequiredEndpointPatch = 1;
  Object.defineProperty(endpointPatch, "__esModule", { value: true });
  endpointPatch.EndpointPatchSerializer = void 0;
  endpointPatch.EndpointPatchSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        secret: object["secret"],
        uid: object["uid"],
        url: object["url"],
        version: object["version"]
      };
    },
    _toJsonObject(self) {
      return {
        channels: self.channels,
        description: self.description,
        disabled: self.disabled,
        filterTypes: self.filterTypes,
        metadata: self.metadata,
        rateLimit: self.rateLimit,
        secret: self.secret,
        uid: self.uid,
        url: self.url,
        version: self.version
      };
    }
  };
  return endpointPatch;
}
var endpointSecretOut = {};
var hasRequiredEndpointSecretOut;
function requireEndpointSecretOut() {
  if (hasRequiredEndpointSecretOut) return endpointSecretOut;
  hasRequiredEndpointSecretOut = 1;
  Object.defineProperty(endpointSecretOut, "__esModule", { value: true });
  endpointSecretOut.EndpointSecretOutSerializer = void 0;
  endpointSecretOut.EndpointSecretOutSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self) {
      return {
        key: self.key
      };
    }
  };
  return endpointSecretOut;
}
var endpointSecretRotateIn = {};
var hasRequiredEndpointSecretRotateIn;
function requireEndpointSecretRotateIn() {
  if (hasRequiredEndpointSecretRotateIn) return endpointSecretRotateIn;
  hasRequiredEndpointSecretRotateIn = 1;
  Object.defineProperty(endpointSecretRotateIn, "__esModule", { value: true });
  endpointSecretRotateIn.EndpointSecretRotateInSerializer = void 0;
  endpointSecretRotateIn.EndpointSecretRotateInSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self) {
      return {
        key: self.key
      };
    }
  };
  return endpointSecretRotateIn;
}
var endpointStats = {};
var hasRequiredEndpointStats;
function requireEndpointStats() {
  if (hasRequiredEndpointStats) return endpointStats;
  hasRequiredEndpointStats = 1;
  Object.defineProperty(endpointStats, "__esModule", { value: true });
  endpointStats.EndpointStatsSerializer = void 0;
  endpointStats.EndpointStatsSerializer = {
    _fromJsonObject(object) {
      return {
        fail: object["fail"],
        pending: object["pending"],
        sending: object["sending"],
        success: object["success"]
      };
    },
    _toJsonObject(self) {
      return {
        fail: self.fail,
        pending: self.pending,
        sending: self.sending,
        success: self.success
      };
    }
  };
  return endpointStats;
}
var endpointTransformationIn = {};
var hasRequiredEndpointTransformationIn;
function requireEndpointTransformationIn() {
  if (hasRequiredEndpointTransformationIn) return endpointTransformationIn;
  hasRequiredEndpointTransformationIn = 1;
  Object.defineProperty(endpointTransformationIn, "__esModule", { value: true });
  endpointTransformationIn.EndpointTransformationInSerializer = void 0;
  endpointTransformationIn.EndpointTransformationInSerializer = {
    _fromJsonObject(object) {
      return {
        code: object["code"],
        enabled: object["enabled"]
      };
    },
    _toJsonObject(self) {
      return {
        code: self.code,
        enabled: self.enabled
      };
    }
  };
  return endpointTransformationIn;
}
var endpointTransformationOut = {};
var hasRequiredEndpointTransformationOut;
function requireEndpointTransformationOut() {
  if (hasRequiredEndpointTransformationOut) return endpointTransformationOut;
  hasRequiredEndpointTransformationOut = 1;
  Object.defineProperty(endpointTransformationOut, "__esModule", { value: true });
  endpointTransformationOut.EndpointTransformationOutSerializer = void 0;
  endpointTransformationOut.EndpointTransformationOutSerializer = {
    _fromJsonObject(object) {
      return {
        code: object["code"],
        enabled: object["enabled"]
      };
    },
    _toJsonObject(self) {
      return {
        code: self.code,
        enabled: self.enabled
      };
    }
  };
  return endpointTransformationOut;
}
var endpointTransformationPatch = {};
var hasRequiredEndpointTransformationPatch;
function requireEndpointTransformationPatch() {
  if (hasRequiredEndpointTransformationPatch) return endpointTransformationPatch;
  hasRequiredEndpointTransformationPatch = 1;
  Object.defineProperty(endpointTransformationPatch, "__esModule", { value: true });
  endpointTransformationPatch.EndpointTransformationPatchSerializer = void 0;
  endpointTransformationPatch.EndpointTransformationPatchSerializer = {
    _fromJsonObject(object) {
      return {
        code: object["code"],
        enabled: object["enabled"]
      };
    },
    _toJsonObject(self) {
      return {
        code: self.code,
        enabled: self.enabled
      };
    }
  };
  return endpointTransformationPatch;
}
var endpointUpdate = {};
var hasRequiredEndpointUpdate;
function requireEndpointUpdate() {
  if (hasRequiredEndpointUpdate) return endpointUpdate;
  hasRequiredEndpointUpdate = 1;
  Object.defineProperty(endpointUpdate, "__esModule", { value: true });
  endpointUpdate.EndpointUpdateSerializer = void 0;
  endpointUpdate.EndpointUpdateSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        url: object["url"],
        version: object["version"]
      };
    },
    _toJsonObject(self) {
      return {
        channels: self.channels,
        description: self.description,
        disabled: self.disabled,
        filterTypes: self.filterTypes,
        metadata: self.metadata,
        rateLimit: self.rateLimit,
        uid: self.uid,
        url: self.url,
        version: self.version
      };
    }
  };
  return endpointUpdate;
}
var eventExampleIn = {};
var hasRequiredEventExampleIn;
function requireEventExampleIn() {
  if (hasRequiredEventExampleIn) return eventExampleIn;
  hasRequiredEventExampleIn = 1;
  Object.defineProperty(eventExampleIn, "__esModule", { value: true });
  eventExampleIn.EventExampleInSerializer = void 0;
  eventExampleIn.EventExampleInSerializer = {
    _fromJsonObject(object) {
      return {
        eventType: object["eventType"],
        exampleIndex: object["exampleIndex"]
      };
    },
    _toJsonObject(self) {
      return {
        eventType: self.eventType,
        exampleIndex: self.exampleIndex
      };
    }
  };
  return eventExampleIn;
}
var listResponseEndpointOut = {};
var hasRequiredListResponseEndpointOut;
function requireListResponseEndpointOut() {
  if (hasRequiredListResponseEndpointOut) return listResponseEndpointOut;
  hasRequiredListResponseEndpointOut = 1;
  Object.defineProperty(listResponseEndpointOut, "__esModule", { value: true });
  listResponseEndpointOut.ListResponseEndpointOutSerializer = void 0;
  const endpointOut_1 = requireEndpointOut();
  listResponseEndpointOut.ListResponseEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => endpointOut_1.EndpointOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data.map((item) => endpointOut_1.EndpointOutSerializer._toJsonObject(item)),
        done: self.done,
        iterator: self.iterator,
        prevIterator: self.prevIterator
      };
    }
  };
  return listResponseEndpointOut;
}
var messageOut = {};
var hasRequiredMessageOut;
function requireMessageOut() {
  if (hasRequiredMessageOut) return messageOut;
  hasRequiredMessageOut = 1;
  Object.defineProperty(messageOut, "__esModule", { value: true });
  messageOut.MessageOutSerializer = void 0;
  messageOut.MessageOutSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        eventId: object["eventId"],
        eventType: object["eventType"],
        id: object["id"],
        payload: object["payload"],
        tags: object["tags"],
        timestamp: new Date(object["timestamp"])
      };
    },
    _toJsonObject(self) {
      return {
        channels: self.channels,
        eventId: self.eventId,
        eventType: self.eventType,
        id: self.id,
        payload: self.payload,
        tags: self.tags,
        timestamp: self.timestamp
      };
    }
  };
  return messageOut;
}
var recoverIn = {};
var hasRequiredRecoverIn;
function requireRecoverIn() {
  if (hasRequiredRecoverIn) return recoverIn;
  hasRequiredRecoverIn = 1;
  Object.defineProperty(recoverIn, "__esModule", { value: true });
  recoverIn.RecoverInSerializer = void 0;
  recoverIn.RecoverInSerializer = {
    _fromJsonObject(object) {
      return {
        since: new Date(object["since"]),
        until: object["until"] ? new Date(object["until"]) : null
      };
    },
    _toJsonObject(self) {
      return {
        since: self.since,
        until: self.until
      };
    }
  };
  return recoverIn;
}
var recoverOut = {};
var hasRequiredRecoverOut;
function requireRecoverOut() {
  if (hasRequiredRecoverOut) return recoverOut;
  hasRequiredRecoverOut = 1;
  Object.defineProperty(recoverOut, "__esModule", { value: true });
  recoverOut.RecoverOutSerializer = void 0;
  const backgroundTaskStatus_1 = requireBackgroundTaskStatus();
  const backgroundTaskType_1 = requireBackgroundTaskType();
  recoverOut.RecoverOutSerializer = {
    _fromJsonObject(object) {
      return {
        id: object["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object["task"])
      };
    },
    _toJsonObject(self) {
      return {
        id: self.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self.task)
      };
    }
  };
  return recoverOut;
}
var replayIn = {};
var hasRequiredReplayIn;
function requireReplayIn() {
  if (hasRequiredReplayIn) return replayIn;
  hasRequiredReplayIn = 1;
  Object.defineProperty(replayIn, "__esModule", { value: true });
  replayIn.ReplayInSerializer = void 0;
  replayIn.ReplayInSerializer = {
    _fromJsonObject(object) {
      return {
        since: new Date(object["since"]),
        until: object["until"] ? new Date(object["until"]) : null
      };
    },
    _toJsonObject(self) {
      return {
        since: self.since,
        until: self.until
      };
    }
  };
  return replayIn;
}
var replayOut = {};
var hasRequiredReplayOut;
function requireReplayOut() {
  if (hasRequiredReplayOut) return replayOut;
  hasRequiredReplayOut = 1;
  Object.defineProperty(replayOut, "__esModule", { value: true });
  replayOut.ReplayOutSerializer = void 0;
  const backgroundTaskStatus_1 = requireBackgroundTaskStatus();
  const backgroundTaskType_1 = requireBackgroundTaskType();
  replayOut.ReplayOutSerializer = {
    _fromJsonObject(object) {
      return {
        id: object["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object["task"])
      };
    },
    _toJsonObject(self) {
      return {
        id: self.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self.task)
      };
    }
  };
  return replayOut;
}
var hasRequiredEndpoint;
function requireEndpoint() {
  if (hasRequiredEndpoint) return endpoint;
  hasRequiredEndpoint = 1;
  Object.defineProperty(endpoint, "__esModule", { value: true });
  endpoint.Endpoint = void 0;
  const endpointHeadersIn_1 = requireEndpointHeadersIn();
  const endpointHeadersOut_1 = requireEndpointHeadersOut();
  const endpointHeadersPatchIn_1 = requireEndpointHeadersPatchIn();
  const endpointIn_1 = requireEndpointIn();
  const endpointOut_1 = requireEndpointOut();
  const endpointPatch_1 = requireEndpointPatch();
  const endpointSecretOut_1 = requireEndpointSecretOut();
  const endpointSecretRotateIn_1 = requireEndpointSecretRotateIn();
  const endpointStats_1 = requireEndpointStats();
  const endpointTransformationIn_1 = requireEndpointTransformationIn();
  const endpointTransformationOut_1 = requireEndpointTransformationOut();
  const endpointTransformationPatch_1 = requireEndpointTransformationPatch();
  const endpointUpdate_1 = requireEndpointUpdate();
  const eventExampleIn_1 = requireEventExampleIn();
  const listResponseEndpointOut_1 = requireListResponseEndpointOut();
  const messageOut_1 = requireMessageOut();
  const recoverIn_1 = requireRecoverIn();
  const recoverOut_1 = requireRecoverOut();
  const replayIn_1 = requireReplayIn();
  const replayOut_1 = requireReplayOut();
  const request_1 = requireRequest();
  class Endpoint {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(appId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint");
      request2.setPathParam("app_id", appId);
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      request2.setQueryParam("order", options === null || options === void 0 ? void 0 : options.order);
      return request2.send(this.requestCtx, listResponseEndpointOut_1.ListResponseEndpointOutSerializer._fromJsonObject);
    }
    create(appId, endpointIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint");
      request2.setPathParam("app_id", appId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(endpointIn_1.EndpointInSerializer._toJsonObject(endpointIn2));
      return request2.send(this.requestCtx, endpointOut_1.EndpointOutSerializer._fromJsonObject);
    }
    get(appId, endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      return request2.send(this.requestCtx, endpointOut_1.EndpointOutSerializer._fromJsonObject);
    }
    update(appId, endpointId, endpointUpdate2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/app/{app_id}/endpoint/{endpoint_id}");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setBody(endpointUpdate_1.EndpointUpdateSerializer._toJsonObject(endpointUpdate2));
      return request2.send(this.requestCtx, endpointOut_1.EndpointOutSerializer._fromJsonObject);
    }
    delete(appId, endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}/endpoint/{endpoint_id}");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      return request2.sendNoResponseBody(this.requestCtx);
    }
    patch(appId, endpointId, endpointPatch2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}/endpoint/{endpoint_id}");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setBody(endpointPatch_1.EndpointPatchSerializer._toJsonObject(endpointPatch2));
      return request2.send(this.requestCtx, endpointOut_1.EndpointOutSerializer._fromJsonObject);
    }
    getHeaders(appId, endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/headers");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      return request2.send(this.requestCtx, endpointHeadersOut_1.EndpointHeadersOutSerializer._fromJsonObject);
    }
    updateHeaders(appId, endpointId, endpointHeadersIn2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/headers");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setBody(endpointHeadersIn_1.EndpointHeadersInSerializer._toJsonObject(endpointHeadersIn2));
      return request2.sendNoResponseBody(this.requestCtx);
    }
    headersUpdate(appId, endpointId, endpointHeadersIn2) {
      return this.updateHeaders(appId, endpointId, endpointHeadersIn2);
    }
    patchHeaders(appId, endpointId, endpointHeadersPatchIn2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/headers");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setBody(endpointHeadersPatchIn_1.EndpointHeadersPatchInSerializer._toJsonObject(endpointHeadersPatchIn2));
      return request2.sendNoResponseBody(this.requestCtx);
    }
    headersPatch(appId, endpointId, endpointHeadersPatchIn2) {
      return this.patchHeaders(appId, endpointId, endpointHeadersPatchIn2);
    }
    recover(appId, endpointId, recoverIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/recover");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(recoverIn_1.RecoverInSerializer._toJsonObject(recoverIn2));
      return request2.send(this.requestCtx, recoverOut_1.RecoverOutSerializer._fromJsonObject);
    }
    replayMissing(appId, endpointId, replayIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/replay-missing");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(replayIn_1.ReplayInSerializer._toJsonObject(replayIn2));
      return request2.send(this.requestCtx, replayOut_1.ReplayOutSerializer._fromJsonObject);
    }
    getSecret(appId, endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/secret");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      return request2.send(this.requestCtx, endpointSecretOut_1.EndpointSecretOutSerializer._fromJsonObject);
    }
    rotateSecret(appId, endpointId, endpointSecretRotateIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/secret/rotate");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(endpointSecretRotateIn_1.EndpointSecretRotateInSerializer._toJsonObject(endpointSecretRotateIn2));
      return request2.sendNoResponseBody(this.requestCtx);
    }
    sendExample(appId, endpointId, eventExampleIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/send-example");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(eventExampleIn_1.EventExampleInSerializer._toJsonObject(eventExampleIn2));
      return request2.send(this.requestCtx, messageOut_1.MessageOutSerializer._fromJsonObject);
    }
    getStats(appId, endpointId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/stats");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setQueryParam("since", options === null || options === void 0 ? void 0 : options.since);
      request2.setQueryParam("until", options === null || options === void 0 ? void 0 : options.until);
      return request2.send(this.requestCtx, endpointStats_1.EndpointStatsSerializer._fromJsonObject);
    }
    transformationGet(appId, endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/transformation");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      return request2.send(this.requestCtx, endpointTransformationOut_1.EndpointTransformationOutSerializer._fromJsonObject);
    }
    patchTransformation(appId, endpointId, endpointTransformationPatch2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/transformation");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setBody(endpointTransformationPatch_1.EndpointTransformationPatchSerializer._toJsonObject(endpointTransformationPatch2));
      return request2.sendNoResponseBody(this.requestCtx);
    }
    transformationPartialUpdate(appId, endpointId, endpointTransformationIn2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/transformation");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setBody(endpointTransformationIn_1.EndpointTransformationInSerializer._toJsonObject(endpointTransformationIn2));
      return request2.sendNoResponseBody(this.requestCtx);
    }
  }
  endpoint.Endpoint = Endpoint;
  return endpoint;
}
var environment = {};
var environmentIn = {};
var connectorIn = {};
var connectorKind = {};
var hasRequiredConnectorKind;
function requireConnectorKind() {
  if (hasRequiredConnectorKind) return connectorKind;
  hasRequiredConnectorKind = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.ConnectorKindSerializer = exports$1.ConnectorKind = void 0;
    (function(ConnectorKind) {
      ConnectorKind["Custom"] = "Custom";
      ConnectorKind["CloseCrm"] = "CloseCRM";
      ConnectorKind["CustomerIo"] = "CustomerIO";
      ConnectorKind["Discord"] = "Discord";
      ConnectorKind["Hubspot"] = "Hubspot";
      ConnectorKind["Inngest"] = "Inngest";
      ConnectorKind["Loops"] = "Loops";
      ConnectorKind["Resend"] = "Resend";
      ConnectorKind["Salesforce"] = "Salesforce";
      ConnectorKind["Segment"] = "Segment";
      ConnectorKind["Sendgrid"] = "Sendgrid";
      ConnectorKind["Slack"] = "Slack";
      ConnectorKind["Teams"] = "Teams";
      ConnectorKind["TriggerDev"] = "TriggerDev";
      ConnectorKind["Windmill"] = "Windmill";
      ConnectorKind["Zapier"] = "Zapier";
    })(exports$1.ConnectorKind || (exports$1.ConnectorKind = {}));
    exports$1.ConnectorKindSerializer = {
      _fromJsonObject(object) {
        return object;
      },
      _toJsonObject(self) {
        return self;
      }
    };
  })(connectorKind);
  return connectorKind;
}
var hasRequiredConnectorIn;
function requireConnectorIn() {
  if (hasRequiredConnectorIn) return connectorIn;
  hasRequiredConnectorIn = 1;
  Object.defineProperty(connectorIn, "__esModule", { value: true });
  connectorIn.ConnectorInSerializer = void 0;
  const connectorKind_1 = requireConnectorKind();
  connectorIn.ConnectorInSerializer = {
    _fromJsonObject(object) {
      return {
        description: object["description"],
        featureFlag: object["featureFlag"],
        featureFlags: object["featureFlags"],
        filterTypes: object["filterTypes"],
        instructions: object["instructions"],
        instructionsLink: object["instructionsLink"],
        kind: object["kind"] ? connectorKind_1.ConnectorKindSerializer._fromJsonObject(object["kind"]) : void 0,
        logo: object["logo"],
        name: object["name"],
        transformation: object["transformation"]
      };
    },
    _toJsonObject(self) {
      return {
        description: self.description,
        featureFlag: self.featureFlag,
        featureFlags: self.featureFlags,
        filterTypes: self.filterTypes,
        instructions: self.instructions,
        instructionsLink: self.instructionsLink,
        kind: self.kind ? connectorKind_1.ConnectorKindSerializer._toJsonObject(self.kind) : void 0,
        logo: self.logo,
        name: self.name,
        transformation: self.transformation
      };
    }
  };
  return connectorIn;
}
var eventTypeIn = {};
var hasRequiredEventTypeIn;
function requireEventTypeIn() {
  if (hasRequiredEventTypeIn) return eventTypeIn;
  hasRequiredEventTypeIn = 1;
  Object.defineProperty(eventTypeIn, "__esModule", { value: true });
  eventTypeIn.EventTypeInSerializer = void 0;
  eventTypeIn.EventTypeInSerializer = {
    _fromJsonObject(object) {
      return {
        archived: object["archived"],
        deprecated: object["deprecated"],
        description: object["description"],
        featureFlag: object["featureFlag"],
        featureFlags: object["featureFlags"],
        groupName: object["groupName"],
        name: object["name"],
        schemas: object["schemas"]
      };
    },
    _toJsonObject(self) {
      return {
        archived: self.archived,
        deprecated: self.deprecated,
        description: self.description,
        featureFlag: self.featureFlag,
        featureFlags: self.featureFlags,
        groupName: self.groupName,
        name: self.name,
        schemas: self.schemas
      };
    }
  };
  return eventTypeIn;
}
var hasRequiredEnvironmentIn;
function requireEnvironmentIn() {
  if (hasRequiredEnvironmentIn) return environmentIn;
  hasRequiredEnvironmentIn = 1;
  Object.defineProperty(environmentIn, "__esModule", { value: true });
  environmentIn.EnvironmentInSerializer = void 0;
  const connectorIn_1 = requireConnectorIn();
  const eventTypeIn_1 = requireEventTypeIn();
  environmentIn.EnvironmentInSerializer = {
    _fromJsonObject(object) {
      var _a2, _b;
      return {
        connectors: (_a2 = object["connectors"]) === null || _a2 === void 0 ? void 0 : _a2.map((item) => connectorIn_1.ConnectorInSerializer._fromJsonObject(item)),
        eventTypes: (_b = object["eventTypes"]) === null || _b === void 0 ? void 0 : _b.map((item) => eventTypeIn_1.EventTypeInSerializer._fromJsonObject(item)),
        settings: object["settings"]
      };
    },
    _toJsonObject(self) {
      var _a2, _b;
      return {
        connectors: (_a2 = self.connectors) === null || _a2 === void 0 ? void 0 : _a2.map((item) => connectorIn_1.ConnectorInSerializer._toJsonObject(item)),
        eventTypes: (_b = self.eventTypes) === null || _b === void 0 ? void 0 : _b.map((item) => eventTypeIn_1.EventTypeInSerializer._toJsonObject(item)),
        settings: self.settings
      };
    }
  };
  return environmentIn;
}
var environmentOut = {};
var connectorOut = {};
var hasRequiredConnectorOut;
function requireConnectorOut() {
  if (hasRequiredConnectorOut) return connectorOut;
  hasRequiredConnectorOut = 1;
  Object.defineProperty(connectorOut, "__esModule", { value: true });
  connectorOut.ConnectorOutSerializer = void 0;
  const connectorKind_1 = requireConnectorKind();
  connectorOut.ConnectorOutSerializer = {
    _fromJsonObject(object) {
      return {
        createdAt: new Date(object["createdAt"]),
        description: object["description"],
        featureFlag: object["featureFlag"],
        featureFlags: object["featureFlags"],
        filterTypes: object["filterTypes"],
        id: object["id"],
        instructions: object["instructions"],
        instructionsLink: object["instructionsLink"],
        kind: connectorKind_1.ConnectorKindSerializer._fromJsonObject(object["kind"]),
        logo: object["logo"],
        name: object["name"],
        orgId: object["orgId"],
        transformation: object["transformation"],
        updatedAt: new Date(object["updatedAt"])
      };
    },
    _toJsonObject(self) {
      return {
        createdAt: self.createdAt,
        description: self.description,
        featureFlag: self.featureFlag,
        featureFlags: self.featureFlags,
        filterTypes: self.filterTypes,
        id: self.id,
        instructions: self.instructions,
        instructionsLink: self.instructionsLink,
        kind: connectorKind_1.ConnectorKindSerializer._toJsonObject(self.kind),
        logo: self.logo,
        name: self.name,
        orgId: self.orgId,
        transformation: self.transformation,
        updatedAt: self.updatedAt
      };
    }
  };
  return connectorOut;
}
var eventTypeOut = {};
var hasRequiredEventTypeOut;
function requireEventTypeOut() {
  if (hasRequiredEventTypeOut) return eventTypeOut;
  hasRequiredEventTypeOut = 1;
  Object.defineProperty(eventTypeOut, "__esModule", { value: true });
  eventTypeOut.EventTypeOutSerializer = void 0;
  eventTypeOut.EventTypeOutSerializer = {
    _fromJsonObject(object) {
      return {
        archived: object["archived"],
        createdAt: new Date(object["createdAt"]),
        deprecated: object["deprecated"],
        description: object["description"],
        featureFlag: object["featureFlag"],
        featureFlags: object["featureFlags"],
        groupName: object["groupName"],
        name: object["name"],
        schemas: object["schemas"],
        updatedAt: new Date(object["updatedAt"])
      };
    },
    _toJsonObject(self) {
      return {
        archived: self.archived,
        createdAt: self.createdAt,
        deprecated: self.deprecated,
        description: self.description,
        featureFlag: self.featureFlag,
        featureFlags: self.featureFlags,
        groupName: self.groupName,
        name: self.name,
        schemas: self.schemas,
        updatedAt: self.updatedAt
      };
    }
  };
  return eventTypeOut;
}
var hasRequiredEnvironmentOut;
function requireEnvironmentOut() {
  if (hasRequiredEnvironmentOut) return environmentOut;
  hasRequiredEnvironmentOut = 1;
  Object.defineProperty(environmentOut, "__esModule", { value: true });
  environmentOut.EnvironmentOutSerializer = void 0;
  const connectorOut_1 = requireConnectorOut();
  const eventTypeOut_1 = requireEventTypeOut();
  environmentOut.EnvironmentOutSerializer = {
    _fromJsonObject(object) {
      return {
        createdAt: new Date(object["createdAt"]),
        eventTypes: object["eventTypes"].map((item) => eventTypeOut_1.EventTypeOutSerializer._fromJsonObject(item)),
        settings: object["settings"],
        transformationTemplates: object["transformationTemplates"].map((item) => connectorOut_1.ConnectorOutSerializer._fromJsonObject(item)),
        version: object["version"]
      };
    },
    _toJsonObject(self) {
      return {
        createdAt: self.createdAt,
        eventTypes: self.eventTypes.map((item) => eventTypeOut_1.EventTypeOutSerializer._toJsonObject(item)),
        settings: self.settings,
        transformationTemplates: self.transformationTemplates.map((item) => connectorOut_1.ConnectorOutSerializer._toJsonObject(item)),
        version: self.version
      };
    }
  };
  return environmentOut;
}
var hasRequiredEnvironment;
function requireEnvironment() {
  if (hasRequiredEnvironment) return environment;
  hasRequiredEnvironment = 1;
  Object.defineProperty(environment, "__esModule", { value: true });
  environment.Environment = void 0;
  const environmentIn_1 = requireEnvironmentIn();
  const environmentOut_1 = requireEnvironmentOut();
  const request_1 = requireRequest();
  class Environment {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    export(options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/environment/export");
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      return request2.send(this.requestCtx, environmentOut_1.EnvironmentOutSerializer._fromJsonObject);
    }
    import(environmentIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/environment/import");
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(environmentIn_1.EnvironmentInSerializer._toJsonObject(environmentIn2));
      return request2.sendNoResponseBody(this.requestCtx);
    }
  }
  environment.Environment = Environment;
  return environment;
}
var eventType = {};
var eventTypeImportOpenApiIn = {};
var hasRequiredEventTypeImportOpenApiIn;
function requireEventTypeImportOpenApiIn() {
  if (hasRequiredEventTypeImportOpenApiIn) return eventTypeImportOpenApiIn;
  hasRequiredEventTypeImportOpenApiIn = 1;
  Object.defineProperty(eventTypeImportOpenApiIn, "__esModule", { value: true });
  eventTypeImportOpenApiIn.EventTypeImportOpenApiInSerializer = void 0;
  eventTypeImportOpenApiIn.EventTypeImportOpenApiInSerializer = {
    _fromJsonObject(object) {
      return {
        dryRun: object["dryRun"],
        replaceAll: object["replaceAll"],
        spec: object["spec"],
        specRaw: object["specRaw"]
      };
    },
    _toJsonObject(self) {
      return {
        dryRun: self.dryRun,
        replaceAll: self.replaceAll,
        spec: self.spec,
        specRaw: self.specRaw
      };
    }
  };
  return eventTypeImportOpenApiIn;
}
var eventTypeImportOpenApiOut = {};
var eventTypeImportOpenApiOutData = {};
var eventTypeFromOpenApi = {};
var hasRequiredEventTypeFromOpenApi;
function requireEventTypeFromOpenApi() {
  if (hasRequiredEventTypeFromOpenApi) return eventTypeFromOpenApi;
  hasRequiredEventTypeFromOpenApi = 1;
  Object.defineProperty(eventTypeFromOpenApi, "__esModule", { value: true });
  eventTypeFromOpenApi.EventTypeFromOpenApiSerializer = void 0;
  eventTypeFromOpenApi.EventTypeFromOpenApiSerializer = {
    _fromJsonObject(object) {
      return {
        deprecated: object["deprecated"],
        description: object["description"],
        featureFlag: object["featureFlag"],
        featureFlags: object["featureFlags"],
        groupName: object["groupName"],
        name: object["name"],
        schemas: object["schemas"]
      };
    },
    _toJsonObject(self) {
      return {
        deprecated: self.deprecated,
        description: self.description,
        featureFlag: self.featureFlag,
        featureFlags: self.featureFlags,
        groupName: self.groupName,
        name: self.name,
        schemas: self.schemas
      };
    }
  };
  return eventTypeFromOpenApi;
}
var hasRequiredEventTypeImportOpenApiOutData;
function requireEventTypeImportOpenApiOutData() {
  if (hasRequiredEventTypeImportOpenApiOutData) return eventTypeImportOpenApiOutData;
  hasRequiredEventTypeImportOpenApiOutData = 1;
  Object.defineProperty(eventTypeImportOpenApiOutData, "__esModule", { value: true });
  eventTypeImportOpenApiOutData.EventTypeImportOpenApiOutDataSerializer = void 0;
  const eventTypeFromOpenApi_1 = requireEventTypeFromOpenApi();
  eventTypeImportOpenApiOutData.EventTypeImportOpenApiOutDataSerializer = {
    _fromJsonObject(object) {
      var _a2;
      return {
        modified: object["modified"],
        toModify: (_a2 = object["to_modify"]) === null || _a2 === void 0 ? void 0 : _a2.map((item) => eventTypeFromOpenApi_1.EventTypeFromOpenApiSerializer._fromJsonObject(item))
      };
    },
    _toJsonObject(self) {
      var _a2;
      return {
        modified: self.modified,
        to_modify: (_a2 = self.toModify) === null || _a2 === void 0 ? void 0 : _a2.map((item) => eventTypeFromOpenApi_1.EventTypeFromOpenApiSerializer._toJsonObject(item))
      };
    }
  };
  return eventTypeImportOpenApiOutData;
}
var hasRequiredEventTypeImportOpenApiOut;
function requireEventTypeImportOpenApiOut() {
  if (hasRequiredEventTypeImportOpenApiOut) return eventTypeImportOpenApiOut;
  hasRequiredEventTypeImportOpenApiOut = 1;
  Object.defineProperty(eventTypeImportOpenApiOut, "__esModule", { value: true });
  eventTypeImportOpenApiOut.EventTypeImportOpenApiOutSerializer = void 0;
  const eventTypeImportOpenApiOutData_1 = requireEventTypeImportOpenApiOutData();
  eventTypeImportOpenApiOut.EventTypeImportOpenApiOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: eventTypeImportOpenApiOutData_1.EventTypeImportOpenApiOutDataSerializer._fromJsonObject(object["data"])
      };
    },
    _toJsonObject(self) {
      return {
        data: eventTypeImportOpenApiOutData_1.EventTypeImportOpenApiOutDataSerializer._toJsonObject(self.data)
      };
    }
  };
  return eventTypeImportOpenApiOut;
}
var eventTypePatch = {};
var hasRequiredEventTypePatch;
function requireEventTypePatch() {
  if (hasRequiredEventTypePatch) return eventTypePatch;
  hasRequiredEventTypePatch = 1;
  Object.defineProperty(eventTypePatch, "__esModule", { value: true });
  eventTypePatch.EventTypePatchSerializer = void 0;
  eventTypePatch.EventTypePatchSerializer = {
    _fromJsonObject(object) {
      return {
        archived: object["archived"],
        deprecated: object["deprecated"],
        description: object["description"],
        featureFlag: object["featureFlag"],
        featureFlags: object["featureFlags"],
        groupName: object["groupName"],
        schemas: object["schemas"]
      };
    },
    _toJsonObject(self) {
      return {
        archived: self.archived,
        deprecated: self.deprecated,
        description: self.description,
        featureFlag: self.featureFlag,
        featureFlags: self.featureFlags,
        groupName: self.groupName,
        schemas: self.schemas
      };
    }
  };
  return eventTypePatch;
}
var eventTypeUpdate = {};
var hasRequiredEventTypeUpdate;
function requireEventTypeUpdate() {
  if (hasRequiredEventTypeUpdate) return eventTypeUpdate;
  hasRequiredEventTypeUpdate = 1;
  Object.defineProperty(eventTypeUpdate, "__esModule", { value: true });
  eventTypeUpdate.EventTypeUpdateSerializer = void 0;
  eventTypeUpdate.EventTypeUpdateSerializer = {
    _fromJsonObject(object) {
      return {
        archived: object["archived"],
        deprecated: object["deprecated"],
        description: object["description"],
        featureFlag: object["featureFlag"],
        featureFlags: object["featureFlags"],
        groupName: object["groupName"],
        schemas: object["schemas"]
      };
    },
    _toJsonObject(self) {
      return {
        archived: self.archived,
        deprecated: self.deprecated,
        description: self.description,
        featureFlag: self.featureFlag,
        featureFlags: self.featureFlags,
        groupName: self.groupName,
        schemas: self.schemas
      };
    }
  };
  return eventTypeUpdate;
}
var listResponseEventTypeOut = {};
var hasRequiredListResponseEventTypeOut;
function requireListResponseEventTypeOut() {
  if (hasRequiredListResponseEventTypeOut) return listResponseEventTypeOut;
  hasRequiredListResponseEventTypeOut = 1;
  Object.defineProperty(listResponseEventTypeOut, "__esModule", { value: true });
  listResponseEventTypeOut.ListResponseEventTypeOutSerializer = void 0;
  const eventTypeOut_1 = requireEventTypeOut();
  listResponseEventTypeOut.ListResponseEventTypeOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => eventTypeOut_1.EventTypeOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data.map((item) => eventTypeOut_1.EventTypeOutSerializer._toJsonObject(item)),
        done: self.done,
        iterator: self.iterator,
        prevIterator: self.prevIterator
      };
    }
  };
  return listResponseEventTypeOut;
}
var hasRequiredEventType;
function requireEventType() {
  if (hasRequiredEventType) return eventType;
  hasRequiredEventType = 1;
  Object.defineProperty(eventType, "__esModule", { value: true });
  eventType.EventType = void 0;
  const eventTypeImportOpenApiIn_1 = requireEventTypeImportOpenApiIn();
  const eventTypeImportOpenApiOut_1 = requireEventTypeImportOpenApiOut();
  const eventTypeIn_1 = requireEventTypeIn();
  const eventTypeOut_1 = requireEventTypeOut();
  const eventTypePatch_1 = requireEventTypePatch();
  const eventTypeUpdate_1 = requireEventTypeUpdate();
  const listResponseEventTypeOut_1 = requireListResponseEventTypeOut();
  const request_1 = requireRequest();
  class EventType {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/event-type");
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      request2.setQueryParam("order", options === null || options === void 0 ? void 0 : options.order);
      request2.setQueryParam("include_archived", options === null || options === void 0 ? void 0 : options.includeArchived);
      request2.setQueryParam("with_content", options === null || options === void 0 ? void 0 : options.withContent);
      return request2.send(this.requestCtx, listResponseEventTypeOut_1.ListResponseEventTypeOutSerializer._fromJsonObject);
    }
    create(eventTypeIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/event-type");
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(eventTypeIn_1.EventTypeInSerializer._toJsonObject(eventTypeIn2));
      return request2.send(this.requestCtx, eventTypeOut_1.EventTypeOutSerializer._fromJsonObject);
    }
    importOpenapi(eventTypeImportOpenApiIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/event-type/import/openapi");
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(eventTypeImportOpenApiIn_1.EventTypeImportOpenApiInSerializer._toJsonObject(eventTypeImportOpenApiIn2));
      return request2.send(this.requestCtx, eventTypeImportOpenApiOut_1.EventTypeImportOpenApiOutSerializer._fromJsonObject);
    }
    get(eventTypeName) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/event-type/{event_type_name}");
      request2.setPathParam("event_type_name", eventTypeName);
      return request2.send(this.requestCtx, eventTypeOut_1.EventTypeOutSerializer._fromJsonObject);
    }
    update(eventTypeName, eventTypeUpdate2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/event-type/{event_type_name}");
      request2.setPathParam("event_type_name", eventTypeName);
      request2.setBody(eventTypeUpdate_1.EventTypeUpdateSerializer._toJsonObject(eventTypeUpdate2));
      return request2.send(this.requestCtx, eventTypeOut_1.EventTypeOutSerializer._fromJsonObject);
    }
    delete(eventTypeName, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/event-type/{event_type_name}");
      request2.setPathParam("event_type_name", eventTypeName);
      request2.setQueryParam("expunge", options === null || options === void 0 ? void 0 : options.expunge);
      return request2.sendNoResponseBody(this.requestCtx);
    }
    patch(eventTypeName, eventTypePatch2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/event-type/{event_type_name}");
      request2.setPathParam("event_type_name", eventTypeName);
      request2.setBody(eventTypePatch_1.EventTypePatchSerializer._toJsonObject(eventTypePatch2));
      return request2.send(this.requestCtx, eventTypeOut_1.EventTypeOutSerializer._fromJsonObject);
    }
  }
  eventType.EventType = EventType;
  return eventType;
}
var health = {};
var hasRequiredHealth;
function requireHealth() {
  if (hasRequiredHealth) return health;
  hasRequiredHealth = 1;
  Object.defineProperty(health, "__esModule", { value: true });
  health.Health = void 0;
  const request_1 = requireRequest();
  class Health {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    get() {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/health");
      return request2.sendNoResponseBody(this.requestCtx);
    }
  }
  health.Health = Health;
  return health;
}
var ingest = {};
var ingestSourceConsumerPortalAccessIn = {};
var hasRequiredIngestSourceConsumerPortalAccessIn;
function requireIngestSourceConsumerPortalAccessIn() {
  if (hasRequiredIngestSourceConsumerPortalAccessIn) return ingestSourceConsumerPortalAccessIn;
  hasRequiredIngestSourceConsumerPortalAccessIn = 1;
  Object.defineProperty(ingestSourceConsumerPortalAccessIn, "__esModule", { value: true });
  ingestSourceConsumerPortalAccessIn.IngestSourceConsumerPortalAccessInSerializer = void 0;
  ingestSourceConsumerPortalAccessIn.IngestSourceConsumerPortalAccessInSerializer = {
    _fromJsonObject(object) {
      return {
        expiry: object["expiry"],
        readOnly: object["readOnly"]
      };
    },
    _toJsonObject(self) {
      return {
        expiry: self.expiry,
        readOnly: self.readOnly
      };
    }
  };
  return ingestSourceConsumerPortalAccessIn;
}
var ingestEndpoint = {};
var ingestEndpointHeadersIn = {};
var hasRequiredIngestEndpointHeadersIn;
function requireIngestEndpointHeadersIn() {
  if (hasRequiredIngestEndpointHeadersIn) return ingestEndpointHeadersIn;
  hasRequiredIngestEndpointHeadersIn = 1;
  Object.defineProperty(ingestEndpointHeadersIn, "__esModule", { value: true });
  ingestEndpointHeadersIn.IngestEndpointHeadersInSerializer = void 0;
  ingestEndpointHeadersIn.IngestEndpointHeadersInSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"]
      };
    },
    _toJsonObject(self) {
      return {
        headers: self.headers
      };
    }
  };
  return ingestEndpointHeadersIn;
}
var ingestEndpointHeadersOut = {};
var hasRequiredIngestEndpointHeadersOut;
function requireIngestEndpointHeadersOut() {
  if (hasRequiredIngestEndpointHeadersOut) return ingestEndpointHeadersOut;
  hasRequiredIngestEndpointHeadersOut = 1;
  Object.defineProperty(ingestEndpointHeadersOut, "__esModule", { value: true });
  ingestEndpointHeadersOut.IngestEndpointHeadersOutSerializer = void 0;
  ingestEndpointHeadersOut.IngestEndpointHeadersOutSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"],
        sensitive: object["sensitive"]
      };
    },
    _toJsonObject(self) {
      return {
        headers: self.headers,
        sensitive: self.sensitive
      };
    }
  };
  return ingestEndpointHeadersOut;
}
var ingestEndpointIn = {};
var hasRequiredIngestEndpointIn;
function requireIngestEndpointIn() {
  if (hasRequiredIngestEndpointIn) return ingestEndpointIn;
  hasRequiredIngestEndpointIn = 1;
  Object.defineProperty(ingestEndpointIn, "__esModule", { value: true });
  ingestEndpointIn.IngestEndpointInSerializer = void 0;
  ingestEndpointIn.IngestEndpointInSerializer = {
    _fromJsonObject(object) {
      return {
        description: object["description"],
        disabled: object["disabled"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        secret: object["secret"],
        uid: object["uid"],
        url: object["url"]
      };
    },
    _toJsonObject(self) {
      return {
        description: self.description,
        disabled: self.disabled,
        metadata: self.metadata,
        rateLimit: self.rateLimit,
        secret: self.secret,
        uid: self.uid,
        url: self.url
      };
    }
  };
  return ingestEndpointIn;
}
var ingestEndpointOut = {};
var hasRequiredIngestEndpointOut;
function requireIngestEndpointOut() {
  if (hasRequiredIngestEndpointOut) return ingestEndpointOut;
  hasRequiredIngestEndpointOut = 1;
  Object.defineProperty(ingestEndpointOut, "__esModule", { value: true });
  ingestEndpointOut.IngestEndpointOutSerializer = void 0;
  ingestEndpointOut.IngestEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        createdAt: new Date(object["createdAt"]),
        description: object["description"],
        disabled: object["disabled"],
        id: object["id"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"]),
        url: object["url"]
      };
    },
    _toJsonObject(self) {
      return {
        createdAt: self.createdAt,
        description: self.description,
        disabled: self.disabled,
        id: self.id,
        metadata: self.metadata,
        rateLimit: self.rateLimit,
        uid: self.uid,
        updatedAt: self.updatedAt,
        url: self.url
      };
    }
  };
  return ingestEndpointOut;
}
var ingestEndpointSecretIn = {};
var hasRequiredIngestEndpointSecretIn;
function requireIngestEndpointSecretIn() {
  if (hasRequiredIngestEndpointSecretIn) return ingestEndpointSecretIn;
  hasRequiredIngestEndpointSecretIn = 1;
  Object.defineProperty(ingestEndpointSecretIn, "__esModule", { value: true });
  ingestEndpointSecretIn.IngestEndpointSecretInSerializer = void 0;
  ingestEndpointSecretIn.IngestEndpointSecretInSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self) {
      return {
        key: self.key
      };
    }
  };
  return ingestEndpointSecretIn;
}
var ingestEndpointSecretOut = {};
var hasRequiredIngestEndpointSecretOut;
function requireIngestEndpointSecretOut() {
  if (hasRequiredIngestEndpointSecretOut) return ingestEndpointSecretOut;
  hasRequiredIngestEndpointSecretOut = 1;
  Object.defineProperty(ingestEndpointSecretOut, "__esModule", { value: true });
  ingestEndpointSecretOut.IngestEndpointSecretOutSerializer = void 0;
  ingestEndpointSecretOut.IngestEndpointSecretOutSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self) {
      return {
        key: self.key
      };
    }
  };
  return ingestEndpointSecretOut;
}
var ingestEndpointTransformationOut = {};
var hasRequiredIngestEndpointTransformationOut;
function requireIngestEndpointTransformationOut() {
  if (hasRequiredIngestEndpointTransformationOut) return ingestEndpointTransformationOut;
  hasRequiredIngestEndpointTransformationOut = 1;
  Object.defineProperty(ingestEndpointTransformationOut, "__esModule", { value: true });
  ingestEndpointTransformationOut.IngestEndpointTransformationOutSerializer = void 0;
  ingestEndpointTransformationOut.IngestEndpointTransformationOutSerializer = {
    _fromJsonObject(object) {
      return {
        code: object["code"],
        enabled: object["enabled"]
      };
    },
    _toJsonObject(self) {
      return {
        code: self.code,
        enabled: self.enabled
      };
    }
  };
  return ingestEndpointTransformationOut;
}
var ingestEndpointTransformationPatch = {};
var hasRequiredIngestEndpointTransformationPatch;
function requireIngestEndpointTransformationPatch() {
  if (hasRequiredIngestEndpointTransformationPatch) return ingestEndpointTransformationPatch;
  hasRequiredIngestEndpointTransformationPatch = 1;
  Object.defineProperty(ingestEndpointTransformationPatch, "__esModule", { value: true });
  ingestEndpointTransformationPatch.IngestEndpointTransformationPatchSerializer = void 0;
  ingestEndpointTransformationPatch.IngestEndpointTransformationPatchSerializer = {
    _fromJsonObject(object) {
      return {
        code: object["code"],
        enabled: object["enabled"]
      };
    },
    _toJsonObject(self) {
      return {
        code: self.code,
        enabled: self.enabled
      };
    }
  };
  return ingestEndpointTransformationPatch;
}
var ingestEndpointUpdate = {};
var hasRequiredIngestEndpointUpdate;
function requireIngestEndpointUpdate() {
  if (hasRequiredIngestEndpointUpdate) return ingestEndpointUpdate;
  hasRequiredIngestEndpointUpdate = 1;
  Object.defineProperty(ingestEndpointUpdate, "__esModule", { value: true });
  ingestEndpointUpdate.IngestEndpointUpdateSerializer = void 0;
  ingestEndpointUpdate.IngestEndpointUpdateSerializer = {
    _fromJsonObject(object) {
      return {
        description: object["description"],
        disabled: object["disabled"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        url: object["url"]
      };
    },
    _toJsonObject(self) {
      return {
        description: self.description,
        disabled: self.disabled,
        metadata: self.metadata,
        rateLimit: self.rateLimit,
        uid: self.uid,
        url: self.url
      };
    }
  };
  return ingestEndpointUpdate;
}
var listResponseIngestEndpointOut = {};
var hasRequiredListResponseIngestEndpointOut;
function requireListResponseIngestEndpointOut() {
  if (hasRequiredListResponseIngestEndpointOut) return listResponseIngestEndpointOut;
  hasRequiredListResponseIngestEndpointOut = 1;
  Object.defineProperty(listResponseIngestEndpointOut, "__esModule", { value: true });
  listResponseIngestEndpointOut.ListResponseIngestEndpointOutSerializer = void 0;
  const ingestEndpointOut_1 = requireIngestEndpointOut();
  listResponseIngestEndpointOut.ListResponseIngestEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => ingestEndpointOut_1.IngestEndpointOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data.map((item) => ingestEndpointOut_1.IngestEndpointOutSerializer._toJsonObject(item)),
        done: self.done,
        iterator: self.iterator,
        prevIterator: self.prevIterator
      };
    }
  };
  return listResponseIngestEndpointOut;
}
var hasRequiredIngestEndpoint;
function requireIngestEndpoint() {
  if (hasRequiredIngestEndpoint) return ingestEndpoint;
  hasRequiredIngestEndpoint = 1;
  Object.defineProperty(ingestEndpoint, "__esModule", { value: true });
  ingestEndpoint.IngestEndpoint = void 0;
  const ingestEndpointHeadersIn_1 = requireIngestEndpointHeadersIn();
  const ingestEndpointHeadersOut_1 = requireIngestEndpointHeadersOut();
  const ingestEndpointIn_1 = requireIngestEndpointIn();
  const ingestEndpointOut_1 = requireIngestEndpointOut();
  const ingestEndpointSecretIn_1 = requireIngestEndpointSecretIn();
  const ingestEndpointSecretOut_1 = requireIngestEndpointSecretOut();
  const ingestEndpointTransformationOut_1 = requireIngestEndpointTransformationOut();
  const ingestEndpointTransformationPatch_1 = requireIngestEndpointTransformationPatch();
  const ingestEndpointUpdate_1 = requireIngestEndpointUpdate();
  const listResponseIngestEndpointOut_1 = requireListResponseIngestEndpointOut();
  const request_1 = requireRequest();
  class IngestEndpoint {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(sourceId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint");
      request2.setPathParam("source_id", sourceId);
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      request2.setQueryParam("order", options === null || options === void 0 ? void 0 : options.order);
      return request2.send(this.requestCtx, listResponseIngestEndpointOut_1.ListResponseIngestEndpointOutSerializer._fromJsonObject);
    }
    create(sourceId, ingestEndpointIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source/{source_id}/endpoint");
      request2.setPathParam("source_id", sourceId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(ingestEndpointIn_1.IngestEndpointInSerializer._toJsonObject(ingestEndpointIn2));
      return request2.send(this.requestCtx, ingestEndpointOut_1.IngestEndpointOutSerializer._fromJsonObject);
    }
    get(sourceId, endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}");
      request2.setPathParam("source_id", sourceId);
      request2.setPathParam("endpoint_id", endpointId);
      return request2.send(this.requestCtx, ingestEndpointOut_1.IngestEndpointOutSerializer._fromJsonObject);
    }
    update(sourceId, endpointId, ingestEndpointUpdate2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}");
      request2.setPathParam("source_id", sourceId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setBody(ingestEndpointUpdate_1.IngestEndpointUpdateSerializer._toJsonObject(ingestEndpointUpdate2));
      return request2.send(this.requestCtx, ingestEndpointOut_1.IngestEndpointOutSerializer._fromJsonObject);
    }
    delete(sourceId, endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}");
      request2.setPathParam("source_id", sourceId);
      request2.setPathParam("endpoint_id", endpointId);
      return request2.sendNoResponseBody(this.requestCtx);
    }
    getHeaders(sourceId, endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/headers");
      request2.setPathParam("source_id", sourceId);
      request2.setPathParam("endpoint_id", endpointId);
      return request2.send(this.requestCtx, ingestEndpointHeadersOut_1.IngestEndpointHeadersOutSerializer._fromJsonObject);
    }
    updateHeaders(sourceId, endpointId, ingestEndpointHeadersIn2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/headers");
      request2.setPathParam("source_id", sourceId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setBody(ingestEndpointHeadersIn_1.IngestEndpointHeadersInSerializer._toJsonObject(ingestEndpointHeadersIn2));
      return request2.sendNoResponseBody(this.requestCtx);
    }
    getSecret(sourceId, endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/secret");
      request2.setPathParam("source_id", sourceId);
      request2.setPathParam("endpoint_id", endpointId);
      return request2.send(this.requestCtx, ingestEndpointSecretOut_1.IngestEndpointSecretOutSerializer._fromJsonObject);
    }
    rotateSecret(sourceId, endpointId, ingestEndpointSecretIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/secret/rotate");
      request2.setPathParam("source_id", sourceId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(ingestEndpointSecretIn_1.IngestEndpointSecretInSerializer._toJsonObject(ingestEndpointSecretIn2));
      return request2.sendNoResponseBody(this.requestCtx);
    }
    getTransformation(sourceId, endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/transformation");
      request2.setPathParam("source_id", sourceId);
      request2.setPathParam("endpoint_id", endpointId);
      return request2.send(this.requestCtx, ingestEndpointTransformationOut_1.IngestEndpointTransformationOutSerializer._fromJsonObject);
    }
    setTransformation(sourceId, endpointId, ingestEndpointTransformationPatch2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/transformation");
      request2.setPathParam("source_id", sourceId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setBody(ingestEndpointTransformationPatch_1.IngestEndpointTransformationPatchSerializer._toJsonObject(ingestEndpointTransformationPatch2));
      return request2.sendNoResponseBody(this.requestCtx);
    }
  }
  ingestEndpoint.IngestEndpoint = IngestEndpoint;
  return ingestEndpoint;
}
var ingestSource = {};
var ingestSourceIn = {};
var adobeSignConfig = {};
var hasRequiredAdobeSignConfig;
function requireAdobeSignConfig() {
  if (hasRequiredAdobeSignConfig) return adobeSignConfig;
  hasRequiredAdobeSignConfig = 1;
  Object.defineProperty(adobeSignConfig, "__esModule", { value: true });
  adobeSignConfig.AdobeSignConfigSerializer = void 0;
  adobeSignConfig.AdobeSignConfigSerializer = {
    _fromJsonObject(object) {
      return {
        clientId: object["clientId"]
      };
    },
    _toJsonObject(self) {
      return {
        clientId: self.clientId
      };
    }
  };
  return adobeSignConfig;
}
var airwallexConfig = {};
var hasRequiredAirwallexConfig;
function requireAirwallexConfig() {
  if (hasRequiredAirwallexConfig) return airwallexConfig;
  hasRequiredAirwallexConfig = 1;
  Object.defineProperty(airwallexConfig, "__esModule", { value: true });
  airwallexConfig.AirwallexConfigSerializer = void 0;
  airwallexConfig.AirwallexConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return airwallexConfig;
}
var checkbookConfig = {};
var hasRequiredCheckbookConfig;
function requireCheckbookConfig() {
  if (hasRequiredCheckbookConfig) return checkbookConfig;
  hasRequiredCheckbookConfig = 1;
  Object.defineProperty(checkbookConfig, "__esModule", { value: true });
  checkbookConfig.CheckbookConfigSerializer = void 0;
  checkbookConfig.CheckbookConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return checkbookConfig;
}
var cronConfig = {};
var hasRequiredCronConfig;
function requireCronConfig() {
  if (hasRequiredCronConfig) return cronConfig;
  hasRequiredCronConfig = 1;
  Object.defineProperty(cronConfig, "__esModule", { value: true });
  cronConfig.CronConfigSerializer = void 0;
  cronConfig.CronConfigSerializer = {
    _fromJsonObject(object) {
      return {
        contentType: object["contentType"],
        payload: object["payload"],
        schedule: object["schedule"]
      };
    },
    _toJsonObject(self) {
      return {
        contentType: self.contentType,
        payload: self.payload,
        schedule: self.schedule
      };
    }
  };
  return cronConfig;
}
var docusignConfig = {};
var hasRequiredDocusignConfig;
function requireDocusignConfig() {
  if (hasRequiredDocusignConfig) return docusignConfig;
  hasRequiredDocusignConfig = 1;
  Object.defineProperty(docusignConfig, "__esModule", { value: true });
  docusignConfig.DocusignConfigSerializer = void 0;
  docusignConfig.DocusignConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return docusignConfig;
}
var easypostConfig = {};
var hasRequiredEasypostConfig;
function requireEasypostConfig() {
  if (hasRequiredEasypostConfig) return easypostConfig;
  hasRequiredEasypostConfig = 1;
  Object.defineProperty(easypostConfig, "__esModule", { value: true });
  easypostConfig.EasypostConfigSerializer = void 0;
  easypostConfig.EasypostConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return easypostConfig;
}
var githubConfig = {};
var hasRequiredGithubConfig;
function requireGithubConfig() {
  if (hasRequiredGithubConfig) return githubConfig;
  hasRequiredGithubConfig = 1;
  Object.defineProperty(githubConfig, "__esModule", { value: true });
  githubConfig.GithubConfigSerializer = void 0;
  githubConfig.GithubConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return githubConfig;
}
var hubspotConfig = {};
var hasRequiredHubspotConfig;
function requireHubspotConfig() {
  if (hasRequiredHubspotConfig) return hubspotConfig;
  hasRequiredHubspotConfig = 1;
  Object.defineProperty(hubspotConfig, "__esModule", { value: true });
  hubspotConfig.HubspotConfigSerializer = void 0;
  hubspotConfig.HubspotConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return hubspotConfig;
}
var orumIoConfig = {};
var hasRequiredOrumIoConfig;
function requireOrumIoConfig() {
  if (hasRequiredOrumIoConfig) return orumIoConfig;
  hasRequiredOrumIoConfig = 1;
  Object.defineProperty(orumIoConfig, "__esModule", { value: true });
  orumIoConfig.OrumIoConfigSerializer = void 0;
  orumIoConfig.OrumIoConfigSerializer = {
    _fromJsonObject(object) {
      return {
        publicKey: object["publicKey"]
      };
    },
    _toJsonObject(self) {
      return {
        publicKey: self.publicKey
      };
    }
  };
  return orumIoConfig;
}
var pandaDocConfig = {};
var hasRequiredPandaDocConfig;
function requirePandaDocConfig() {
  if (hasRequiredPandaDocConfig) return pandaDocConfig;
  hasRequiredPandaDocConfig = 1;
  Object.defineProperty(pandaDocConfig, "__esModule", { value: true });
  pandaDocConfig.PandaDocConfigSerializer = void 0;
  pandaDocConfig.PandaDocConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return pandaDocConfig;
}
var portIoConfig = {};
var hasRequiredPortIoConfig;
function requirePortIoConfig() {
  if (hasRequiredPortIoConfig) return portIoConfig;
  hasRequiredPortIoConfig = 1;
  Object.defineProperty(portIoConfig, "__esModule", { value: true });
  portIoConfig.PortIoConfigSerializer = void 0;
  portIoConfig.PortIoConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return portIoConfig;
}
var rutterConfig = {};
var hasRequiredRutterConfig;
function requireRutterConfig() {
  if (hasRequiredRutterConfig) return rutterConfig;
  hasRequiredRutterConfig = 1;
  Object.defineProperty(rutterConfig, "__esModule", { value: true });
  rutterConfig.RutterConfigSerializer = void 0;
  rutterConfig.RutterConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return rutterConfig;
}
var segmentConfig = {};
var hasRequiredSegmentConfig;
function requireSegmentConfig() {
  if (hasRequiredSegmentConfig) return segmentConfig;
  hasRequiredSegmentConfig = 1;
  Object.defineProperty(segmentConfig, "__esModule", { value: true });
  segmentConfig.SegmentConfigSerializer = void 0;
  segmentConfig.SegmentConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return segmentConfig;
}
var shopifyConfig = {};
var hasRequiredShopifyConfig;
function requireShopifyConfig() {
  if (hasRequiredShopifyConfig) return shopifyConfig;
  hasRequiredShopifyConfig = 1;
  Object.defineProperty(shopifyConfig, "__esModule", { value: true });
  shopifyConfig.ShopifyConfigSerializer = void 0;
  shopifyConfig.ShopifyConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return shopifyConfig;
}
var slackConfig = {};
var hasRequiredSlackConfig;
function requireSlackConfig() {
  if (hasRequiredSlackConfig) return slackConfig;
  hasRequiredSlackConfig = 1;
  Object.defineProperty(slackConfig, "__esModule", { value: true });
  slackConfig.SlackConfigSerializer = void 0;
  slackConfig.SlackConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return slackConfig;
}
var stripeConfig = {};
var hasRequiredStripeConfig;
function requireStripeConfig() {
  if (hasRequiredStripeConfig) return stripeConfig;
  hasRequiredStripeConfig = 1;
  Object.defineProperty(stripeConfig, "__esModule", { value: true });
  stripeConfig.StripeConfigSerializer = void 0;
  stripeConfig.StripeConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return stripeConfig;
}
var svixConfig = {};
var hasRequiredSvixConfig;
function requireSvixConfig() {
  if (hasRequiredSvixConfig) return svixConfig;
  hasRequiredSvixConfig = 1;
  Object.defineProperty(svixConfig, "__esModule", { value: true });
  svixConfig.SvixConfigSerializer = void 0;
  svixConfig.SvixConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return svixConfig;
}
var telnyxConfig = {};
var hasRequiredTelnyxConfig;
function requireTelnyxConfig() {
  if (hasRequiredTelnyxConfig) return telnyxConfig;
  hasRequiredTelnyxConfig = 1;
  Object.defineProperty(telnyxConfig, "__esModule", { value: true });
  telnyxConfig.TelnyxConfigSerializer = void 0;
  telnyxConfig.TelnyxConfigSerializer = {
    _fromJsonObject(object) {
      return {
        publicKey: object["publicKey"]
      };
    },
    _toJsonObject(self) {
      return {
        publicKey: self.publicKey
      };
    }
  };
  return telnyxConfig;
}
var vapiConfig = {};
var hasRequiredVapiConfig;
function requireVapiConfig() {
  if (hasRequiredVapiConfig) return vapiConfig;
  hasRequiredVapiConfig = 1;
  Object.defineProperty(vapiConfig, "__esModule", { value: true });
  vapiConfig.VapiConfigSerializer = void 0;
  vapiConfig.VapiConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return vapiConfig;
}
var veriffConfig = {};
var hasRequiredVeriffConfig;
function requireVeriffConfig() {
  if (hasRequiredVeriffConfig) return veriffConfig;
  hasRequiredVeriffConfig = 1;
  Object.defineProperty(veriffConfig, "__esModule", { value: true });
  veriffConfig.VeriffConfigSerializer = void 0;
  veriffConfig.VeriffConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return veriffConfig;
}
var zoomConfig = {};
var hasRequiredZoomConfig;
function requireZoomConfig() {
  if (hasRequiredZoomConfig) return zoomConfig;
  hasRequiredZoomConfig = 1;
  Object.defineProperty(zoomConfig, "__esModule", { value: true });
  zoomConfig.ZoomConfigSerializer = void 0;
  zoomConfig.ZoomConfigSerializer = {
    _fromJsonObject(object) {
      return {
        secret: object["secret"]
      };
    },
    _toJsonObject(self) {
      return {
        secret: self.secret
      };
    }
  };
  return zoomConfig;
}
var hasRequiredIngestSourceIn;
function requireIngestSourceIn() {
  if (hasRequiredIngestSourceIn) return ingestSourceIn;
  hasRequiredIngestSourceIn = 1;
  Object.defineProperty(ingestSourceIn, "__esModule", { value: true });
  ingestSourceIn.IngestSourceInSerializer = void 0;
  const adobeSignConfig_1 = requireAdobeSignConfig();
  const airwallexConfig_1 = requireAirwallexConfig();
  const checkbookConfig_1 = requireCheckbookConfig();
  const cronConfig_1 = requireCronConfig();
  const docusignConfig_1 = requireDocusignConfig();
  const easypostConfig_1 = requireEasypostConfig();
  const githubConfig_1 = requireGithubConfig();
  const hubspotConfig_1 = requireHubspotConfig();
  const orumIoConfig_1 = requireOrumIoConfig();
  const pandaDocConfig_1 = requirePandaDocConfig();
  const portIoConfig_1 = requirePortIoConfig();
  const rutterConfig_1 = requireRutterConfig();
  const segmentConfig_1 = requireSegmentConfig();
  const shopifyConfig_1 = requireShopifyConfig();
  const slackConfig_1 = requireSlackConfig();
  const stripeConfig_1 = requireStripeConfig();
  const svixConfig_1 = requireSvixConfig();
  const telnyxConfig_1 = requireTelnyxConfig();
  const vapiConfig_1 = requireVapiConfig();
  const veriffConfig_1 = requireVeriffConfig();
  const zoomConfig_1 = requireZoomConfig();
  ingestSourceIn.IngestSourceInSerializer = {
    _fromJsonObject(object) {
      const type = object["type"];
      function getConfig(type2) {
        switch (type2) {
          case "generic-webhook":
            return {};
          case "cron":
            return cronConfig_1.CronConfigSerializer._fromJsonObject(object["config"]);
          case "adobe-sign":
            return adobeSignConfig_1.AdobeSignConfigSerializer._fromJsonObject(object["config"]);
          case "beehiiv":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "brex":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "checkbook":
            return checkbookConfig_1.CheckbookConfigSerializer._fromJsonObject(object["config"]);
          case "clerk":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "docusign":
            return docusignConfig_1.DocusignConfigSerializer._fromJsonObject(object["config"]);
          case "easypost":
            return easypostConfig_1.EasypostConfigSerializer._fromJsonObject(object["config"]);
          case "github":
            return githubConfig_1.GithubConfigSerializer._fromJsonObject(object["config"]);
          case "guesty":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "hubspot":
            return hubspotConfig_1.HubspotConfigSerializer._fromJsonObject(object["config"]);
          case "incident-io":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "lithic":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "nash":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "orum-io":
            return orumIoConfig_1.OrumIoConfigSerializer._fromJsonObject(object["config"]);
          case "panda-doc":
            return pandaDocConfig_1.PandaDocConfigSerializer._fromJsonObject(object["config"]);
          case "port-io":
            return portIoConfig_1.PortIoConfigSerializer._fromJsonObject(object["config"]);
          case "pleo":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "replicate":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "resend":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "rutter":
            return rutterConfig_1.RutterConfigSerializer._fromJsonObject(object["config"]);
          case "safebase":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "sardine":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "segment":
            return segmentConfig_1.SegmentConfigSerializer._fromJsonObject(object["config"]);
          case "shopify":
            return shopifyConfig_1.ShopifyConfigSerializer._fromJsonObject(object["config"]);
          case "slack":
            return slackConfig_1.SlackConfigSerializer._fromJsonObject(object["config"]);
          case "stripe":
            return stripeConfig_1.StripeConfigSerializer._fromJsonObject(object["config"]);
          case "stych":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "svix":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "zoom":
            return zoomConfig_1.ZoomConfigSerializer._fromJsonObject(object["config"]);
          case "telnyx":
            return telnyxConfig_1.TelnyxConfigSerializer._fromJsonObject(object["config"]);
          case "vapi":
            return vapiConfig_1.VapiConfigSerializer._fromJsonObject(object["config"]);
          case "open-ai":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "render":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object["config"]);
          case "veriff":
            return veriffConfig_1.VeriffConfigSerializer._fromJsonObject(object["config"]);
          case "airwallex":
            return airwallexConfig_1.AirwallexConfigSerializer._fromJsonObject(object["config"]);
          default:
            throw new Error(`Unexpected type: ${type2}`);
        }
      }
      return {
        type,
        config: getConfig(type),
        metadata: object["metadata"],
        name: object["name"],
        uid: object["uid"]
      };
    },
    _toJsonObject(self) {
      let config;
      switch (self.type) {
        case "generic-webhook":
          config = {};
          break;
        case "cron":
          config = cronConfig_1.CronConfigSerializer._toJsonObject(self.config);
          break;
        case "adobe-sign":
          config = adobeSignConfig_1.AdobeSignConfigSerializer._toJsonObject(self.config);
          break;
        case "beehiiv":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "brex":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "checkbook":
          config = checkbookConfig_1.CheckbookConfigSerializer._toJsonObject(self.config);
          break;
        case "clerk":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "docusign":
          config = docusignConfig_1.DocusignConfigSerializer._toJsonObject(self.config);
          break;
        case "easypost":
          config = easypostConfig_1.EasypostConfigSerializer._toJsonObject(self.config);
          break;
        case "github":
          config = githubConfig_1.GithubConfigSerializer._toJsonObject(self.config);
          break;
        case "guesty":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "hubspot":
          config = hubspotConfig_1.HubspotConfigSerializer._toJsonObject(self.config);
          break;
        case "incident-io":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "lithic":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "nash":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "orum-io":
          config = orumIoConfig_1.OrumIoConfigSerializer._toJsonObject(self.config);
          break;
        case "panda-doc":
          config = pandaDocConfig_1.PandaDocConfigSerializer._toJsonObject(self.config);
          break;
        case "port-io":
          config = portIoConfig_1.PortIoConfigSerializer._toJsonObject(self.config);
          break;
        case "pleo":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "replicate":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "resend":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "rutter":
          config = rutterConfig_1.RutterConfigSerializer._toJsonObject(self.config);
          break;
        case "safebase":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "sardine":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "segment":
          config = segmentConfig_1.SegmentConfigSerializer._toJsonObject(self.config);
          break;
        case "shopify":
          config = shopifyConfig_1.ShopifyConfigSerializer._toJsonObject(self.config);
          break;
        case "slack":
          config = slackConfig_1.SlackConfigSerializer._toJsonObject(self.config);
          break;
        case "stripe":
          config = stripeConfig_1.StripeConfigSerializer._toJsonObject(self.config);
          break;
        case "stych":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "svix":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "zoom":
          config = zoomConfig_1.ZoomConfigSerializer._toJsonObject(self.config);
          break;
        case "telnyx":
          config = telnyxConfig_1.TelnyxConfigSerializer._toJsonObject(self.config);
          break;
        case "vapi":
          config = vapiConfig_1.VapiConfigSerializer._toJsonObject(self.config);
          break;
        case "open-ai":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "render":
          config = svixConfig_1.SvixConfigSerializer._toJsonObject(self.config);
          break;
        case "veriff":
          config = veriffConfig_1.VeriffConfigSerializer._toJsonObject(self.config);
          break;
        case "airwallex":
          config = airwallexConfig_1.AirwallexConfigSerializer._toJsonObject(self.config);
          break;
      }
      return {
        type: self.type,
        config,
        metadata: self.metadata,
        name: self.name,
        uid: self.uid
      };
    }
  };
  return ingestSourceIn;
}
var ingestSourceOut = {};
var adobeSignConfigOut = {};
var hasRequiredAdobeSignConfigOut;
function requireAdobeSignConfigOut() {
  if (hasRequiredAdobeSignConfigOut) return adobeSignConfigOut;
  hasRequiredAdobeSignConfigOut = 1;
  Object.defineProperty(adobeSignConfigOut, "__esModule", { value: true });
  adobeSignConfigOut.AdobeSignConfigOutSerializer = void 0;
  adobeSignConfigOut.AdobeSignConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return adobeSignConfigOut;
}
var airwallexConfigOut = {};
var hasRequiredAirwallexConfigOut;
function requireAirwallexConfigOut() {
  if (hasRequiredAirwallexConfigOut) return airwallexConfigOut;
  hasRequiredAirwallexConfigOut = 1;
  Object.defineProperty(airwallexConfigOut, "__esModule", { value: true });
  airwallexConfigOut.AirwallexConfigOutSerializer = void 0;
  airwallexConfigOut.AirwallexConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return airwallexConfigOut;
}
var checkbookConfigOut = {};
var hasRequiredCheckbookConfigOut;
function requireCheckbookConfigOut() {
  if (hasRequiredCheckbookConfigOut) return checkbookConfigOut;
  hasRequiredCheckbookConfigOut = 1;
  Object.defineProperty(checkbookConfigOut, "__esModule", { value: true });
  checkbookConfigOut.CheckbookConfigOutSerializer = void 0;
  checkbookConfigOut.CheckbookConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return checkbookConfigOut;
}
var docusignConfigOut = {};
var hasRequiredDocusignConfigOut;
function requireDocusignConfigOut() {
  if (hasRequiredDocusignConfigOut) return docusignConfigOut;
  hasRequiredDocusignConfigOut = 1;
  Object.defineProperty(docusignConfigOut, "__esModule", { value: true });
  docusignConfigOut.DocusignConfigOutSerializer = void 0;
  docusignConfigOut.DocusignConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return docusignConfigOut;
}
var easypostConfigOut = {};
var hasRequiredEasypostConfigOut;
function requireEasypostConfigOut() {
  if (hasRequiredEasypostConfigOut) return easypostConfigOut;
  hasRequiredEasypostConfigOut = 1;
  Object.defineProperty(easypostConfigOut, "__esModule", { value: true });
  easypostConfigOut.EasypostConfigOutSerializer = void 0;
  easypostConfigOut.EasypostConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return easypostConfigOut;
}
var githubConfigOut = {};
var hasRequiredGithubConfigOut;
function requireGithubConfigOut() {
  if (hasRequiredGithubConfigOut) return githubConfigOut;
  hasRequiredGithubConfigOut = 1;
  Object.defineProperty(githubConfigOut, "__esModule", { value: true });
  githubConfigOut.GithubConfigOutSerializer = void 0;
  githubConfigOut.GithubConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return githubConfigOut;
}
var hubspotConfigOut = {};
var hasRequiredHubspotConfigOut;
function requireHubspotConfigOut() {
  if (hasRequiredHubspotConfigOut) return hubspotConfigOut;
  hasRequiredHubspotConfigOut = 1;
  Object.defineProperty(hubspotConfigOut, "__esModule", { value: true });
  hubspotConfigOut.HubspotConfigOutSerializer = void 0;
  hubspotConfigOut.HubspotConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return hubspotConfigOut;
}
var orumIoConfigOut = {};
var hasRequiredOrumIoConfigOut;
function requireOrumIoConfigOut() {
  if (hasRequiredOrumIoConfigOut) return orumIoConfigOut;
  hasRequiredOrumIoConfigOut = 1;
  Object.defineProperty(orumIoConfigOut, "__esModule", { value: true });
  orumIoConfigOut.OrumIoConfigOutSerializer = void 0;
  orumIoConfigOut.OrumIoConfigOutSerializer = {
    _fromJsonObject(object) {
      return {
        publicKey: object["publicKey"]
      };
    },
    _toJsonObject(self) {
      return {
        publicKey: self.publicKey
      };
    }
  };
  return orumIoConfigOut;
}
var pandaDocConfigOut = {};
var hasRequiredPandaDocConfigOut;
function requirePandaDocConfigOut() {
  if (hasRequiredPandaDocConfigOut) return pandaDocConfigOut;
  hasRequiredPandaDocConfigOut = 1;
  Object.defineProperty(pandaDocConfigOut, "__esModule", { value: true });
  pandaDocConfigOut.PandaDocConfigOutSerializer = void 0;
  pandaDocConfigOut.PandaDocConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return pandaDocConfigOut;
}
var portIoConfigOut = {};
var hasRequiredPortIoConfigOut;
function requirePortIoConfigOut() {
  if (hasRequiredPortIoConfigOut) return portIoConfigOut;
  hasRequiredPortIoConfigOut = 1;
  Object.defineProperty(portIoConfigOut, "__esModule", { value: true });
  portIoConfigOut.PortIoConfigOutSerializer = void 0;
  portIoConfigOut.PortIoConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return portIoConfigOut;
}
var rutterConfigOut = {};
var hasRequiredRutterConfigOut;
function requireRutterConfigOut() {
  if (hasRequiredRutterConfigOut) return rutterConfigOut;
  hasRequiredRutterConfigOut = 1;
  Object.defineProperty(rutterConfigOut, "__esModule", { value: true });
  rutterConfigOut.RutterConfigOutSerializer = void 0;
  rutterConfigOut.RutterConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return rutterConfigOut;
}
var segmentConfigOut = {};
var hasRequiredSegmentConfigOut;
function requireSegmentConfigOut() {
  if (hasRequiredSegmentConfigOut) return segmentConfigOut;
  hasRequiredSegmentConfigOut = 1;
  Object.defineProperty(segmentConfigOut, "__esModule", { value: true });
  segmentConfigOut.SegmentConfigOutSerializer = void 0;
  segmentConfigOut.SegmentConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return segmentConfigOut;
}
var shopifyConfigOut = {};
var hasRequiredShopifyConfigOut;
function requireShopifyConfigOut() {
  if (hasRequiredShopifyConfigOut) return shopifyConfigOut;
  hasRequiredShopifyConfigOut = 1;
  Object.defineProperty(shopifyConfigOut, "__esModule", { value: true });
  shopifyConfigOut.ShopifyConfigOutSerializer = void 0;
  shopifyConfigOut.ShopifyConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return shopifyConfigOut;
}
var slackConfigOut = {};
var hasRequiredSlackConfigOut;
function requireSlackConfigOut() {
  if (hasRequiredSlackConfigOut) return slackConfigOut;
  hasRequiredSlackConfigOut = 1;
  Object.defineProperty(slackConfigOut, "__esModule", { value: true });
  slackConfigOut.SlackConfigOutSerializer = void 0;
  slackConfigOut.SlackConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return slackConfigOut;
}
var stripeConfigOut = {};
var hasRequiredStripeConfigOut;
function requireStripeConfigOut() {
  if (hasRequiredStripeConfigOut) return stripeConfigOut;
  hasRequiredStripeConfigOut = 1;
  Object.defineProperty(stripeConfigOut, "__esModule", { value: true });
  stripeConfigOut.StripeConfigOutSerializer = void 0;
  stripeConfigOut.StripeConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return stripeConfigOut;
}
var svixConfigOut = {};
var hasRequiredSvixConfigOut;
function requireSvixConfigOut() {
  if (hasRequiredSvixConfigOut) return svixConfigOut;
  hasRequiredSvixConfigOut = 1;
  Object.defineProperty(svixConfigOut, "__esModule", { value: true });
  svixConfigOut.SvixConfigOutSerializer = void 0;
  svixConfigOut.SvixConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return svixConfigOut;
}
var telnyxConfigOut = {};
var hasRequiredTelnyxConfigOut;
function requireTelnyxConfigOut() {
  if (hasRequiredTelnyxConfigOut) return telnyxConfigOut;
  hasRequiredTelnyxConfigOut = 1;
  Object.defineProperty(telnyxConfigOut, "__esModule", { value: true });
  telnyxConfigOut.TelnyxConfigOutSerializer = void 0;
  telnyxConfigOut.TelnyxConfigOutSerializer = {
    _fromJsonObject(object) {
      return {
        publicKey: object["publicKey"]
      };
    },
    _toJsonObject(self) {
      return {
        publicKey: self.publicKey
      };
    }
  };
  return telnyxConfigOut;
}
var vapiConfigOut = {};
var hasRequiredVapiConfigOut;
function requireVapiConfigOut() {
  if (hasRequiredVapiConfigOut) return vapiConfigOut;
  hasRequiredVapiConfigOut = 1;
  Object.defineProperty(vapiConfigOut, "__esModule", { value: true });
  vapiConfigOut.VapiConfigOutSerializer = void 0;
  vapiConfigOut.VapiConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return vapiConfigOut;
}
var veriffConfigOut = {};
var hasRequiredVeriffConfigOut;
function requireVeriffConfigOut() {
  if (hasRequiredVeriffConfigOut) return veriffConfigOut;
  hasRequiredVeriffConfigOut = 1;
  Object.defineProperty(veriffConfigOut, "__esModule", { value: true });
  veriffConfigOut.VeriffConfigOutSerializer = void 0;
  veriffConfigOut.VeriffConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return veriffConfigOut;
}
var zoomConfigOut = {};
var hasRequiredZoomConfigOut;
function requireZoomConfigOut() {
  if (hasRequiredZoomConfigOut) return zoomConfigOut;
  hasRequiredZoomConfigOut = 1;
  Object.defineProperty(zoomConfigOut, "__esModule", { value: true });
  zoomConfigOut.ZoomConfigOutSerializer = void 0;
  zoomConfigOut.ZoomConfigOutSerializer = {
    _fromJsonObject(object) {
      return {};
    },
    _toJsonObject(self) {
      return {};
    }
  };
  return zoomConfigOut;
}
var hasRequiredIngestSourceOut;
function requireIngestSourceOut() {
  if (hasRequiredIngestSourceOut) return ingestSourceOut;
  hasRequiredIngestSourceOut = 1;
  Object.defineProperty(ingestSourceOut, "__esModule", { value: true });
  ingestSourceOut.IngestSourceOutSerializer = void 0;
  const adobeSignConfigOut_1 = requireAdobeSignConfigOut();
  const airwallexConfigOut_1 = requireAirwallexConfigOut();
  const checkbookConfigOut_1 = requireCheckbookConfigOut();
  const cronConfig_1 = requireCronConfig();
  const docusignConfigOut_1 = requireDocusignConfigOut();
  const easypostConfigOut_1 = requireEasypostConfigOut();
  const githubConfigOut_1 = requireGithubConfigOut();
  const hubspotConfigOut_1 = requireHubspotConfigOut();
  const orumIoConfigOut_1 = requireOrumIoConfigOut();
  const pandaDocConfigOut_1 = requirePandaDocConfigOut();
  const portIoConfigOut_1 = requirePortIoConfigOut();
  const rutterConfigOut_1 = requireRutterConfigOut();
  const segmentConfigOut_1 = requireSegmentConfigOut();
  const shopifyConfigOut_1 = requireShopifyConfigOut();
  const slackConfigOut_1 = requireSlackConfigOut();
  const stripeConfigOut_1 = requireStripeConfigOut();
  const svixConfigOut_1 = requireSvixConfigOut();
  const telnyxConfigOut_1 = requireTelnyxConfigOut();
  const vapiConfigOut_1 = requireVapiConfigOut();
  const veriffConfigOut_1 = requireVeriffConfigOut();
  const zoomConfigOut_1 = requireZoomConfigOut();
  ingestSourceOut.IngestSourceOutSerializer = {
    _fromJsonObject(object) {
      const type = object["type"];
      function getConfig(type2) {
        switch (type2) {
          case "generic-webhook":
            return {};
          case "cron":
            return cronConfig_1.CronConfigSerializer._fromJsonObject(object["config"]);
          case "adobe-sign":
            return adobeSignConfigOut_1.AdobeSignConfigOutSerializer._fromJsonObject(object["config"]);
          case "beehiiv":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "brex":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "checkbook":
            return checkbookConfigOut_1.CheckbookConfigOutSerializer._fromJsonObject(object["config"]);
          case "clerk":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "docusign":
            return docusignConfigOut_1.DocusignConfigOutSerializer._fromJsonObject(object["config"]);
          case "easypost":
            return easypostConfigOut_1.EasypostConfigOutSerializer._fromJsonObject(object["config"]);
          case "github":
            return githubConfigOut_1.GithubConfigOutSerializer._fromJsonObject(object["config"]);
          case "guesty":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "hubspot":
            return hubspotConfigOut_1.HubspotConfigOutSerializer._fromJsonObject(object["config"]);
          case "incident-io":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "lithic":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "nash":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "orum-io":
            return orumIoConfigOut_1.OrumIoConfigOutSerializer._fromJsonObject(object["config"]);
          case "panda-doc":
            return pandaDocConfigOut_1.PandaDocConfigOutSerializer._fromJsonObject(object["config"]);
          case "port-io":
            return portIoConfigOut_1.PortIoConfigOutSerializer._fromJsonObject(object["config"]);
          case "pleo":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "replicate":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "resend":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "rutter":
            return rutterConfigOut_1.RutterConfigOutSerializer._fromJsonObject(object["config"]);
          case "safebase":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "sardine":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "segment":
            return segmentConfigOut_1.SegmentConfigOutSerializer._fromJsonObject(object["config"]);
          case "shopify":
            return shopifyConfigOut_1.ShopifyConfigOutSerializer._fromJsonObject(object["config"]);
          case "slack":
            return slackConfigOut_1.SlackConfigOutSerializer._fromJsonObject(object["config"]);
          case "stripe":
            return stripeConfigOut_1.StripeConfigOutSerializer._fromJsonObject(object["config"]);
          case "stych":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "svix":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "zoom":
            return zoomConfigOut_1.ZoomConfigOutSerializer._fromJsonObject(object["config"]);
          case "telnyx":
            return telnyxConfigOut_1.TelnyxConfigOutSerializer._fromJsonObject(object["config"]);
          case "vapi":
            return vapiConfigOut_1.VapiConfigOutSerializer._fromJsonObject(object["config"]);
          case "open-ai":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "render":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object["config"]);
          case "veriff":
            return veriffConfigOut_1.VeriffConfigOutSerializer._fromJsonObject(object["config"]);
          case "airwallex":
            return airwallexConfigOut_1.AirwallexConfigOutSerializer._fromJsonObject(object["config"]);
          default:
            throw new Error(`Unexpected type: ${type2}`);
        }
      }
      return {
        type,
        config: getConfig(type),
        createdAt: new Date(object["createdAt"]),
        id: object["id"],
        ingestUrl: object["ingestUrl"],
        metadata: object["metadata"],
        name: object["name"],
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"])
      };
    },
    _toJsonObject(self) {
      let config;
      switch (self.type) {
        case "generic-webhook":
          config = {};
          break;
        case "cron":
          config = cronConfig_1.CronConfigSerializer._toJsonObject(self.config);
          break;
        case "adobe-sign":
          config = adobeSignConfigOut_1.AdobeSignConfigOutSerializer._toJsonObject(self.config);
          break;
        case "beehiiv":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "brex":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "checkbook":
          config = checkbookConfigOut_1.CheckbookConfigOutSerializer._toJsonObject(self.config);
          break;
        case "clerk":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "docusign":
          config = docusignConfigOut_1.DocusignConfigOutSerializer._toJsonObject(self.config);
          break;
        case "easypost":
          config = easypostConfigOut_1.EasypostConfigOutSerializer._toJsonObject(self.config);
          break;
        case "github":
          config = githubConfigOut_1.GithubConfigOutSerializer._toJsonObject(self.config);
          break;
        case "guesty":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "hubspot":
          config = hubspotConfigOut_1.HubspotConfigOutSerializer._toJsonObject(self.config);
          break;
        case "incident-io":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "lithic":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "nash":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "orum-io":
          config = orumIoConfigOut_1.OrumIoConfigOutSerializer._toJsonObject(self.config);
          break;
        case "panda-doc":
          config = pandaDocConfigOut_1.PandaDocConfigOutSerializer._toJsonObject(self.config);
          break;
        case "port-io":
          config = portIoConfigOut_1.PortIoConfigOutSerializer._toJsonObject(self.config);
          break;
        case "pleo":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "replicate":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "resend":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "rutter":
          config = rutterConfigOut_1.RutterConfigOutSerializer._toJsonObject(self.config);
          break;
        case "safebase":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "sardine":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "segment":
          config = segmentConfigOut_1.SegmentConfigOutSerializer._toJsonObject(self.config);
          break;
        case "shopify":
          config = shopifyConfigOut_1.ShopifyConfigOutSerializer._toJsonObject(self.config);
          break;
        case "slack":
          config = slackConfigOut_1.SlackConfigOutSerializer._toJsonObject(self.config);
          break;
        case "stripe":
          config = stripeConfigOut_1.StripeConfigOutSerializer._toJsonObject(self.config);
          break;
        case "stych":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "svix":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "zoom":
          config = zoomConfigOut_1.ZoomConfigOutSerializer._toJsonObject(self.config);
          break;
        case "telnyx":
          config = telnyxConfigOut_1.TelnyxConfigOutSerializer._toJsonObject(self.config);
          break;
        case "vapi":
          config = vapiConfigOut_1.VapiConfigOutSerializer._toJsonObject(self.config);
          break;
        case "open-ai":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "render":
          config = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self.config);
          break;
        case "veriff":
          config = veriffConfigOut_1.VeriffConfigOutSerializer._toJsonObject(self.config);
          break;
        case "airwallex":
          config = airwallexConfigOut_1.AirwallexConfigOutSerializer._toJsonObject(self.config);
          break;
      }
      return {
        type: self.type,
        config,
        createdAt: self.createdAt,
        id: self.id,
        ingestUrl: self.ingestUrl,
        metadata: self.metadata,
        name: self.name,
        uid: self.uid,
        updatedAt: self.updatedAt
      };
    }
  };
  return ingestSourceOut;
}
var listResponseIngestSourceOut = {};
var hasRequiredListResponseIngestSourceOut;
function requireListResponseIngestSourceOut() {
  if (hasRequiredListResponseIngestSourceOut) return listResponseIngestSourceOut;
  hasRequiredListResponseIngestSourceOut = 1;
  Object.defineProperty(listResponseIngestSourceOut, "__esModule", { value: true });
  listResponseIngestSourceOut.ListResponseIngestSourceOutSerializer = void 0;
  const ingestSourceOut_1 = requireIngestSourceOut();
  listResponseIngestSourceOut.ListResponseIngestSourceOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => ingestSourceOut_1.IngestSourceOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data.map((item) => ingestSourceOut_1.IngestSourceOutSerializer._toJsonObject(item)),
        done: self.done,
        iterator: self.iterator,
        prevIterator: self.prevIterator
      };
    }
  };
  return listResponseIngestSourceOut;
}
var rotateTokenOut = {};
var hasRequiredRotateTokenOut;
function requireRotateTokenOut() {
  if (hasRequiredRotateTokenOut) return rotateTokenOut;
  hasRequiredRotateTokenOut = 1;
  Object.defineProperty(rotateTokenOut, "__esModule", { value: true });
  rotateTokenOut.RotateTokenOutSerializer = void 0;
  rotateTokenOut.RotateTokenOutSerializer = {
    _fromJsonObject(object) {
      return {
        ingestUrl: object["ingestUrl"]
      };
    },
    _toJsonObject(self) {
      return {
        ingestUrl: self.ingestUrl
      };
    }
  };
  return rotateTokenOut;
}
var hasRequiredIngestSource;
function requireIngestSource() {
  if (hasRequiredIngestSource) return ingestSource;
  hasRequiredIngestSource = 1;
  Object.defineProperty(ingestSource, "__esModule", { value: true });
  ingestSource.IngestSource = void 0;
  const ingestSourceIn_1 = requireIngestSourceIn();
  const ingestSourceOut_1 = requireIngestSourceOut();
  const listResponseIngestSourceOut_1 = requireListResponseIngestSourceOut();
  const rotateTokenOut_1 = requireRotateTokenOut();
  const request_1 = requireRequest();
  class IngestSource {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source");
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      request2.setQueryParam("order", options === null || options === void 0 ? void 0 : options.order);
      return request2.send(this.requestCtx, listResponseIngestSourceOut_1.ListResponseIngestSourceOutSerializer._fromJsonObject);
    }
    create(ingestSourceIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source");
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(ingestSourceIn_1.IngestSourceInSerializer._toJsonObject(ingestSourceIn2));
      return request2.send(this.requestCtx, ingestSourceOut_1.IngestSourceOutSerializer._fromJsonObject);
    }
    get(sourceId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}");
      request2.setPathParam("source_id", sourceId);
      return request2.send(this.requestCtx, ingestSourceOut_1.IngestSourceOutSerializer._fromJsonObject);
    }
    update(sourceId, ingestSourceIn2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/ingest/api/v1/source/{source_id}");
      request2.setPathParam("source_id", sourceId);
      request2.setBody(ingestSourceIn_1.IngestSourceInSerializer._toJsonObject(ingestSourceIn2));
      return request2.send(this.requestCtx, ingestSourceOut_1.IngestSourceOutSerializer._fromJsonObject);
    }
    delete(sourceId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/ingest/api/v1/source/{source_id}");
      request2.setPathParam("source_id", sourceId);
      return request2.sendNoResponseBody(this.requestCtx);
    }
    rotateToken(sourceId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source/{source_id}/token/rotate");
      request2.setPathParam("source_id", sourceId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      return request2.send(this.requestCtx, rotateTokenOut_1.RotateTokenOutSerializer._fromJsonObject);
    }
  }
  ingestSource.IngestSource = IngestSource;
  return ingestSource;
}
var hasRequiredIngest;
function requireIngest() {
  if (hasRequiredIngest) return ingest;
  hasRequiredIngest = 1;
  Object.defineProperty(ingest, "__esModule", { value: true });
  ingest.Ingest = void 0;
  const dashboardAccessOut_1 = requireDashboardAccessOut();
  const ingestSourceConsumerPortalAccessIn_1 = requireIngestSourceConsumerPortalAccessIn();
  const ingestEndpoint_1 = requireIngestEndpoint();
  const ingestSource_1 = requireIngestSource();
  const request_1 = requireRequest();
  class Ingest {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    get endpoint() {
      return new ingestEndpoint_1.IngestEndpoint(this.requestCtx);
    }
    get source() {
      return new ingestSource_1.IngestSource(this.requestCtx);
    }
    dashboard(sourceId, ingestSourceConsumerPortalAccessIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source/{source_id}/dashboard");
      request2.setPathParam("source_id", sourceId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(ingestSourceConsumerPortalAccessIn_1.IngestSourceConsumerPortalAccessInSerializer._toJsonObject(ingestSourceConsumerPortalAccessIn2));
      return request2.send(this.requestCtx, dashboardAccessOut_1.DashboardAccessOutSerializer._fromJsonObject);
    }
  }
  ingest.Ingest = Ingest;
  return ingest;
}
var integration = {};
var integrationIn = {};
var hasRequiredIntegrationIn;
function requireIntegrationIn() {
  if (hasRequiredIntegrationIn) return integrationIn;
  hasRequiredIntegrationIn = 1;
  Object.defineProperty(integrationIn, "__esModule", { value: true });
  integrationIn.IntegrationInSerializer = void 0;
  integrationIn.IntegrationInSerializer = {
    _fromJsonObject(object) {
      return {
        featureFlags: object["featureFlags"],
        name: object["name"]
      };
    },
    _toJsonObject(self) {
      return {
        featureFlags: self.featureFlags,
        name: self.name
      };
    }
  };
  return integrationIn;
}
var integrationKeyOut = {};
var hasRequiredIntegrationKeyOut;
function requireIntegrationKeyOut() {
  if (hasRequiredIntegrationKeyOut) return integrationKeyOut;
  hasRequiredIntegrationKeyOut = 1;
  Object.defineProperty(integrationKeyOut, "__esModule", { value: true });
  integrationKeyOut.IntegrationKeyOutSerializer = void 0;
  integrationKeyOut.IntegrationKeyOutSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self) {
      return {
        key: self.key
      };
    }
  };
  return integrationKeyOut;
}
var integrationOut = {};
var hasRequiredIntegrationOut;
function requireIntegrationOut() {
  if (hasRequiredIntegrationOut) return integrationOut;
  hasRequiredIntegrationOut = 1;
  Object.defineProperty(integrationOut, "__esModule", { value: true });
  integrationOut.IntegrationOutSerializer = void 0;
  integrationOut.IntegrationOutSerializer = {
    _fromJsonObject(object) {
      return {
        createdAt: new Date(object["createdAt"]),
        featureFlags: object["featureFlags"],
        id: object["id"],
        name: object["name"],
        updatedAt: new Date(object["updatedAt"])
      };
    },
    _toJsonObject(self) {
      return {
        createdAt: self.createdAt,
        featureFlags: self.featureFlags,
        id: self.id,
        name: self.name,
        updatedAt: self.updatedAt
      };
    }
  };
  return integrationOut;
}
var integrationUpdate = {};
var hasRequiredIntegrationUpdate;
function requireIntegrationUpdate() {
  if (hasRequiredIntegrationUpdate) return integrationUpdate;
  hasRequiredIntegrationUpdate = 1;
  Object.defineProperty(integrationUpdate, "__esModule", { value: true });
  integrationUpdate.IntegrationUpdateSerializer = void 0;
  integrationUpdate.IntegrationUpdateSerializer = {
    _fromJsonObject(object) {
      return {
        featureFlags: object["featureFlags"],
        name: object["name"]
      };
    },
    _toJsonObject(self) {
      return {
        featureFlags: self.featureFlags,
        name: self.name
      };
    }
  };
  return integrationUpdate;
}
var listResponseIntegrationOut = {};
var hasRequiredListResponseIntegrationOut;
function requireListResponseIntegrationOut() {
  if (hasRequiredListResponseIntegrationOut) return listResponseIntegrationOut;
  hasRequiredListResponseIntegrationOut = 1;
  Object.defineProperty(listResponseIntegrationOut, "__esModule", { value: true });
  listResponseIntegrationOut.ListResponseIntegrationOutSerializer = void 0;
  const integrationOut_1 = requireIntegrationOut();
  listResponseIntegrationOut.ListResponseIntegrationOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => integrationOut_1.IntegrationOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data.map((item) => integrationOut_1.IntegrationOutSerializer._toJsonObject(item)),
        done: self.done,
        iterator: self.iterator,
        prevIterator: self.prevIterator
      };
    }
  };
  return listResponseIntegrationOut;
}
var hasRequiredIntegration;
function requireIntegration() {
  if (hasRequiredIntegration) return integration;
  hasRequiredIntegration = 1;
  Object.defineProperty(integration, "__esModule", { value: true });
  integration.Integration = void 0;
  const integrationIn_1 = requireIntegrationIn();
  const integrationKeyOut_1 = requireIntegrationKeyOut();
  const integrationOut_1 = requireIntegrationOut();
  const integrationUpdate_1 = requireIntegrationUpdate();
  const listResponseIntegrationOut_1 = requireListResponseIntegrationOut();
  const request_1 = requireRequest();
  class Integration {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(appId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/integration");
      request2.setPathParam("app_id", appId);
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      request2.setQueryParam("order", options === null || options === void 0 ? void 0 : options.order);
      return request2.send(this.requestCtx, listResponseIntegrationOut_1.ListResponseIntegrationOutSerializer._fromJsonObject);
    }
    create(appId, integrationIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/integration");
      request2.setPathParam("app_id", appId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(integrationIn_1.IntegrationInSerializer._toJsonObject(integrationIn2));
      return request2.send(this.requestCtx, integrationOut_1.IntegrationOutSerializer._fromJsonObject);
    }
    get(appId, integId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/integration/{integ_id}");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("integ_id", integId);
      return request2.send(this.requestCtx, integrationOut_1.IntegrationOutSerializer._fromJsonObject);
    }
    update(appId, integId, integrationUpdate2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/app/{app_id}/integration/{integ_id}");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("integ_id", integId);
      request2.setBody(integrationUpdate_1.IntegrationUpdateSerializer._toJsonObject(integrationUpdate2));
      return request2.send(this.requestCtx, integrationOut_1.IntegrationOutSerializer._fromJsonObject);
    }
    delete(appId, integId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}/integration/{integ_id}");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("integ_id", integId);
      return request2.sendNoResponseBody(this.requestCtx);
    }
    getKey(appId, integId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/integration/{integ_id}/key");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("integ_id", integId);
      return request2.send(this.requestCtx, integrationKeyOut_1.IntegrationKeyOutSerializer._fromJsonObject);
    }
    rotateKey(appId, integId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/integration/{integ_id}/key/rotate");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("integ_id", integId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      return request2.send(this.requestCtx, integrationKeyOut_1.IntegrationKeyOutSerializer._fromJsonObject);
    }
  }
  integration.Integration = Integration;
  return integration;
}
var message = {};
var expungeAllContentsOut = {};
var hasRequiredExpungeAllContentsOut;
function requireExpungeAllContentsOut() {
  if (hasRequiredExpungeAllContentsOut) return expungeAllContentsOut;
  hasRequiredExpungeAllContentsOut = 1;
  Object.defineProperty(expungeAllContentsOut, "__esModule", { value: true });
  expungeAllContentsOut.ExpungeAllContentsOutSerializer = void 0;
  const backgroundTaskStatus_1 = requireBackgroundTaskStatus();
  const backgroundTaskType_1 = requireBackgroundTaskType();
  expungeAllContentsOut.ExpungeAllContentsOutSerializer = {
    _fromJsonObject(object) {
      return {
        id: object["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object["task"])
      };
    },
    _toJsonObject(self) {
      return {
        id: self.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self.task)
      };
    }
  };
  return expungeAllContentsOut;
}
var listResponseMessageOut = {};
var hasRequiredListResponseMessageOut;
function requireListResponseMessageOut() {
  if (hasRequiredListResponseMessageOut) return listResponseMessageOut;
  hasRequiredListResponseMessageOut = 1;
  Object.defineProperty(listResponseMessageOut, "__esModule", { value: true });
  listResponseMessageOut.ListResponseMessageOutSerializer = void 0;
  const messageOut_1 = requireMessageOut();
  listResponseMessageOut.ListResponseMessageOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => messageOut_1.MessageOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data.map((item) => messageOut_1.MessageOutSerializer._toJsonObject(item)),
        done: self.done,
        iterator: self.iterator,
        prevIterator: self.prevIterator
      };
    }
  };
  return listResponseMessageOut;
}
var messagePoller = {};
var pollingEndpointConsumerSeekIn = {};
var hasRequiredPollingEndpointConsumerSeekIn;
function requirePollingEndpointConsumerSeekIn() {
  if (hasRequiredPollingEndpointConsumerSeekIn) return pollingEndpointConsumerSeekIn;
  hasRequiredPollingEndpointConsumerSeekIn = 1;
  Object.defineProperty(pollingEndpointConsumerSeekIn, "__esModule", { value: true });
  pollingEndpointConsumerSeekIn.PollingEndpointConsumerSeekInSerializer = void 0;
  pollingEndpointConsumerSeekIn.PollingEndpointConsumerSeekInSerializer = {
    _fromJsonObject(object) {
      return {
        after: new Date(object["after"])
      };
    },
    _toJsonObject(self) {
      return {
        after: self.after
      };
    }
  };
  return pollingEndpointConsumerSeekIn;
}
var pollingEndpointConsumerSeekOut = {};
var hasRequiredPollingEndpointConsumerSeekOut;
function requirePollingEndpointConsumerSeekOut() {
  if (hasRequiredPollingEndpointConsumerSeekOut) return pollingEndpointConsumerSeekOut;
  hasRequiredPollingEndpointConsumerSeekOut = 1;
  Object.defineProperty(pollingEndpointConsumerSeekOut, "__esModule", { value: true });
  pollingEndpointConsumerSeekOut.PollingEndpointConsumerSeekOutSerializer = void 0;
  pollingEndpointConsumerSeekOut.PollingEndpointConsumerSeekOutSerializer = {
    _fromJsonObject(object) {
      return {
        iterator: object["iterator"]
      };
    },
    _toJsonObject(self) {
      return {
        iterator: self.iterator
      };
    }
  };
  return pollingEndpointConsumerSeekOut;
}
var pollingEndpointOut = {};
var pollingEndpointMessageOut = {};
var hasRequiredPollingEndpointMessageOut;
function requirePollingEndpointMessageOut() {
  if (hasRequiredPollingEndpointMessageOut) return pollingEndpointMessageOut;
  hasRequiredPollingEndpointMessageOut = 1;
  Object.defineProperty(pollingEndpointMessageOut, "__esModule", { value: true });
  pollingEndpointMessageOut.PollingEndpointMessageOutSerializer = void 0;
  pollingEndpointMessageOut.PollingEndpointMessageOutSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        eventId: object["eventId"],
        eventType: object["eventType"],
        headers: object["headers"],
        id: object["id"],
        payload: object["payload"],
        tags: object["tags"],
        timestamp: new Date(object["timestamp"])
      };
    },
    _toJsonObject(self) {
      return {
        channels: self.channels,
        eventId: self.eventId,
        eventType: self.eventType,
        headers: self.headers,
        id: self.id,
        payload: self.payload,
        tags: self.tags,
        timestamp: self.timestamp
      };
    }
  };
  return pollingEndpointMessageOut;
}
var hasRequiredPollingEndpointOut;
function requirePollingEndpointOut() {
  if (hasRequiredPollingEndpointOut) return pollingEndpointOut;
  hasRequiredPollingEndpointOut = 1;
  Object.defineProperty(pollingEndpointOut, "__esModule", { value: true });
  pollingEndpointOut.PollingEndpointOutSerializer = void 0;
  const pollingEndpointMessageOut_1 = requirePollingEndpointMessageOut();
  pollingEndpointOut.PollingEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => pollingEndpointMessageOut_1.PollingEndpointMessageOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"]
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data.map((item) => pollingEndpointMessageOut_1.PollingEndpointMessageOutSerializer._toJsonObject(item)),
        done: self.done,
        iterator: self.iterator
      };
    }
  };
  return pollingEndpointOut;
}
var hasRequiredMessagePoller;
function requireMessagePoller() {
  if (hasRequiredMessagePoller) return messagePoller;
  hasRequiredMessagePoller = 1;
  Object.defineProperty(messagePoller, "__esModule", { value: true });
  messagePoller.MessagePoller = void 0;
  const pollingEndpointConsumerSeekIn_1 = requirePollingEndpointConsumerSeekIn();
  const pollingEndpointConsumerSeekOut_1 = requirePollingEndpointConsumerSeekOut();
  const pollingEndpointOut_1 = requirePollingEndpointOut();
  const request_1 = requireRequest();
  class MessagePoller {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    poll(appId, sinkId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/poller/{sink_id}");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("sink_id", sinkId);
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      request2.setQueryParam("event_type", options === null || options === void 0 ? void 0 : options.eventType);
      request2.setQueryParam("channel", options === null || options === void 0 ? void 0 : options.channel);
      request2.setQueryParam("after", options === null || options === void 0 ? void 0 : options.after);
      return request2.send(this.requestCtx, pollingEndpointOut_1.PollingEndpointOutSerializer._fromJsonObject);
    }
    consumerPoll(appId, sinkId, consumerId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/poller/{sink_id}/consumer/{consumer_id}");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("sink_id", sinkId);
      request2.setPathParam("consumer_id", consumerId);
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      return request2.send(this.requestCtx, pollingEndpointOut_1.PollingEndpointOutSerializer._fromJsonObject);
    }
    consumerSeek(appId, sinkId, consumerId, pollingEndpointConsumerSeekIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/poller/{sink_id}/consumer/{consumer_id}/seek");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("sink_id", sinkId);
      request2.setPathParam("consumer_id", consumerId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(pollingEndpointConsumerSeekIn_1.PollingEndpointConsumerSeekInSerializer._toJsonObject(pollingEndpointConsumerSeekIn2));
      return request2.send(this.requestCtx, pollingEndpointConsumerSeekOut_1.PollingEndpointConsumerSeekOutSerializer._fromJsonObject);
    }
  }
  messagePoller.MessagePoller = MessagePoller;
  return messagePoller;
}
var messageIn = {};
var hasRequiredMessageIn;
function requireMessageIn() {
  if (hasRequiredMessageIn) return messageIn;
  hasRequiredMessageIn = 1;
  Object.defineProperty(messageIn, "__esModule", { value: true });
  messageIn.MessageInSerializer = void 0;
  const applicationIn_1 = requireApplicationIn();
  messageIn.MessageInSerializer = {
    _fromJsonObject(object) {
      return {
        application: object["application"] ? applicationIn_1.ApplicationInSerializer._fromJsonObject(object["application"]) : void 0,
        channels: object["channels"],
        eventId: object["eventId"],
        eventType: object["eventType"],
        payload: object["payload"],
        payloadRetentionHours: object["payloadRetentionHours"],
        payloadRetentionPeriod: object["payloadRetentionPeriod"],
        tags: object["tags"],
        transformationsParams: object["transformationsParams"]
      };
    },
    _toJsonObject(self) {
      return {
        application: self.application ? applicationIn_1.ApplicationInSerializer._toJsonObject(self.application) : void 0,
        channels: self.channels,
        eventId: self.eventId,
        eventType: self.eventType,
        payload: self.payload,
        payloadRetentionHours: self.payloadRetentionHours,
        payloadRetentionPeriod: self.payloadRetentionPeriod,
        tags: self.tags,
        transformationsParams: self.transformationsParams
      };
    }
  };
  return messageIn;
}
var hasRequiredMessage;
function requireMessage() {
  if (hasRequiredMessage) return message;
  hasRequiredMessage = 1;
  Object.defineProperty(message, "__esModule", { value: true });
  message.messageInRaw = message.Message = void 0;
  const expungeAllContentsOut_1 = requireExpungeAllContentsOut();
  const listResponseMessageOut_1 = requireListResponseMessageOut();
  const messageOut_1 = requireMessageOut();
  const messagePoller_1 = requireMessagePoller();
  const request_1 = requireRequest();
  const messageIn_1 = requireMessageIn();
  class Message {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    get poller() {
      return new messagePoller_1.MessagePoller(this.requestCtx);
    }
    list(appId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/msg");
      request2.setPathParam("app_id", appId);
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      request2.setQueryParam("channel", options === null || options === void 0 ? void 0 : options.channel);
      request2.setQueryParam("before", options === null || options === void 0 ? void 0 : options.before);
      request2.setQueryParam("after", options === null || options === void 0 ? void 0 : options.after);
      request2.setQueryParam("with_content", options === null || options === void 0 ? void 0 : options.withContent);
      request2.setQueryParam("tag", options === null || options === void 0 ? void 0 : options.tag);
      request2.setQueryParam("event_types", options === null || options === void 0 ? void 0 : options.eventTypes);
      return request2.send(this.requestCtx, listResponseMessageOut_1.ListResponseMessageOutSerializer._fromJsonObject);
    }
    create(appId, messageIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/msg");
      request2.setPathParam("app_id", appId);
      request2.setQueryParam("with_content", options === null || options === void 0 ? void 0 : options.withContent);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(messageIn_1.MessageInSerializer._toJsonObject(messageIn2));
      return request2.send(this.requestCtx, messageOut_1.MessageOutSerializer._fromJsonObject);
    }
    expungeAllContents(appId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/msg/expunge-all-contents");
      request2.setPathParam("app_id", appId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      return request2.send(this.requestCtx, expungeAllContentsOut_1.ExpungeAllContentsOutSerializer._fromJsonObject);
    }
    get(appId, msgId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/msg/{msg_id}");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("msg_id", msgId);
      request2.setQueryParam("with_content", options === null || options === void 0 ? void 0 : options.withContent);
      return request2.send(this.requestCtx, messageOut_1.MessageOutSerializer._fromJsonObject);
    }
    expungeContent(appId, msgId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}/msg/{msg_id}/content");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("msg_id", msgId);
      return request2.sendNoResponseBody(this.requestCtx);
    }
  }
  message.Message = Message;
  function messageInRaw(eventType2, payload, contentType) {
    const headers = contentType ? { "content-type": contentType } : void 0;
    return {
      eventType: eventType2,
      payload: {},
      transformationsParams: {
        rawPayload: payload,
        headers
      }
    };
  }
  message.messageInRaw = messageInRaw;
  return message;
}
var messageAttempt = {};
var listResponseEndpointMessageOut = {};
var endpointMessageOut = {};
var messageStatus = {};
var hasRequiredMessageStatus;
function requireMessageStatus() {
  if (hasRequiredMessageStatus) return messageStatus;
  hasRequiredMessageStatus = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MessageStatusSerializer = exports$1.MessageStatus = void 0;
    (function(MessageStatus) {
      MessageStatus[MessageStatus["Success"] = 0] = "Success";
      MessageStatus[MessageStatus["Pending"] = 1] = "Pending";
      MessageStatus[MessageStatus["Fail"] = 2] = "Fail";
      MessageStatus[MessageStatus["Sending"] = 3] = "Sending";
    })(exports$1.MessageStatus || (exports$1.MessageStatus = {}));
    exports$1.MessageStatusSerializer = {
      _fromJsonObject(object) {
        return object;
      },
      _toJsonObject(self) {
        return self;
      }
    };
  })(messageStatus);
  return messageStatus;
}
var messageStatusText = {};
var hasRequiredMessageStatusText;
function requireMessageStatusText() {
  if (hasRequiredMessageStatusText) return messageStatusText;
  hasRequiredMessageStatusText = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MessageStatusTextSerializer = exports$1.MessageStatusText = void 0;
    (function(MessageStatusText) {
      MessageStatusText["Success"] = "success";
      MessageStatusText["Pending"] = "pending";
      MessageStatusText["Fail"] = "fail";
      MessageStatusText["Sending"] = "sending";
    })(exports$1.MessageStatusText || (exports$1.MessageStatusText = {}));
    exports$1.MessageStatusTextSerializer = {
      _fromJsonObject(object) {
        return object;
      },
      _toJsonObject(self) {
        return self;
      }
    };
  })(messageStatusText);
  return messageStatusText;
}
var hasRequiredEndpointMessageOut;
function requireEndpointMessageOut() {
  if (hasRequiredEndpointMessageOut) return endpointMessageOut;
  hasRequiredEndpointMessageOut = 1;
  Object.defineProperty(endpointMessageOut, "__esModule", { value: true });
  endpointMessageOut.EndpointMessageOutSerializer = void 0;
  const messageStatus_1 = requireMessageStatus();
  const messageStatusText_1 = requireMessageStatusText();
  endpointMessageOut.EndpointMessageOutSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        eventId: object["eventId"],
        eventType: object["eventType"],
        id: object["id"],
        nextAttempt: object["nextAttempt"] ? new Date(object["nextAttempt"]) : null,
        payload: object["payload"],
        status: messageStatus_1.MessageStatusSerializer._fromJsonObject(object["status"]),
        statusText: messageStatusText_1.MessageStatusTextSerializer._fromJsonObject(object["statusText"]),
        tags: object["tags"],
        timestamp: new Date(object["timestamp"])
      };
    },
    _toJsonObject(self) {
      return {
        channels: self.channels,
        eventId: self.eventId,
        eventType: self.eventType,
        id: self.id,
        nextAttempt: self.nextAttempt,
        payload: self.payload,
        status: messageStatus_1.MessageStatusSerializer._toJsonObject(self.status),
        statusText: messageStatusText_1.MessageStatusTextSerializer._toJsonObject(self.statusText),
        tags: self.tags,
        timestamp: self.timestamp
      };
    }
  };
  return endpointMessageOut;
}
var hasRequiredListResponseEndpointMessageOut;
function requireListResponseEndpointMessageOut() {
  if (hasRequiredListResponseEndpointMessageOut) return listResponseEndpointMessageOut;
  hasRequiredListResponseEndpointMessageOut = 1;
  Object.defineProperty(listResponseEndpointMessageOut, "__esModule", { value: true });
  listResponseEndpointMessageOut.ListResponseEndpointMessageOutSerializer = void 0;
  const endpointMessageOut_1 = requireEndpointMessageOut();
  listResponseEndpointMessageOut.ListResponseEndpointMessageOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => endpointMessageOut_1.EndpointMessageOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data.map((item) => endpointMessageOut_1.EndpointMessageOutSerializer._toJsonObject(item)),
        done: self.done,
        iterator: self.iterator,
        prevIterator: self.prevIterator
      };
    }
  };
  return listResponseEndpointMessageOut;
}
var listResponseMessageAttemptOut = {};
var messageAttemptOut = {};
var messageAttemptTriggerType = {};
var hasRequiredMessageAttemptTriggerType;
function requireMessageAttemptTriggerType() {
  if (hasRequiredMessageAttemptTriggerType) return messageAttemptTriggerType;
  hasRequiredMessageAttemptTriggerType = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.MessageAttemptTriggerTypeSerializer = exports$1.MessageAttemptTriggerType = void 0;
    (function(MessageAttemptTriggerType) {
      MessageAttemptTriggerType[MessageAttemptTriggerType["Scheduled"] = 0] = "Scheduled";
      MessageAttemptTriggerType[MessageAttemptTriggerType["Manual"] = 1] = "Manual";
    })(exports$1.MessageAttemptTriggerType || (exports$1.MessageAttemptTriggerType = {}));
    exports$1.MessageAttemptTriggerTypeSerializer = {
      _fromJsonObject(object) {
        return object;
      },
      _toJsonObject(self) {
        return self;
      }
    };
  })(messageAttemptTriggerType);
  return messageAttemptTriggerType;
}
var hasRequiredMessageAttemptOut;
function requireMessageAttemptOut() {
  if (hasRequiredMessageAttemptOut) return messageAttemptOut;
  hasRequiredMessageAttemptOut = 1;
  Object.defineProperty(messageAttemptOut, "__esModule", { value: true });
  messageAttemptOut.MessageAttemptOutSerializer = void 0;
  const messageAttemptTriggerType_1 = requireMessageAttemptTriggerType();
  const messageOut_1 = requireMessageOut();
  const messageStatus_1 = requireMessageStatus();
  const messageStatusText_1 = requireMessageStatusText();
  messageAttemptOut.MessageAttemptOutSerializer = {
    _fromJsonObject(object) {
      return {
        endpointId: object["endpointId"],
        id: object["id"],
        msg: object["msg"] ? messageOut_1.MessageOutSerializer._fromJsonObject(object["msg"]) : void 0,
        msgId: object["msgId"],
        response: object["response"],
        responseDurationMs: object["responseDurationMs"],
        responseStatusCode: object["responseStatusCode"],
        status: messageStatus_1.MessageStatusSerializer._fromJsonObject(object["status"]),
        statusText: messageStatusText_1.MessageStatusTextSerializer._fromJsonObject(object["statusText"]),
        timestamp: new Date(object["timestamp"]),
        triggerType: messageAttemptTriggerType_1.MessageAttemptTriggerTypeSerializer._fromJsonObject(object["triggerType"]),
        url: object["url"]
      };
    },
    _toJsonObject(self) {
      return {
        endpointId: self.endpointId,
        id: self.id,
        msg: self.msg ? messageOut_1.MessageOutSerializer._toJsonObject(self.msg) : void 0,
        msgId: self.msgId,
        response: self.response,
        responseDurationMs: self.responseDurationMs,
        responseStatusCode: self.responseStatusCode,
        status: messageStatus_1.MessageStatusSerializer._toJsonObject(self.status),
        statusText: messageStatusText_1.MessageStatusTextSerializer._toJsonObject(self.statusText),
        timestamp: self.timestamp,
        triggerType: messageAttemptTriggerType_1.MessageAttemptTriggerTypeSerializer._toJsonObject(self.triggerType),
        url: self.url
      };
    }
  };
  return messageAttemptOut;
}
var hasRequiredListResponseMessageAttemptOut;
function requireListResponseMessageAttemptOut() {
  if (hasRequiredListResponseMessageAttemptOut) return listResponseMessageAttemptOut;
  hasRequiredListResponseMessageAttemptOut = 1;
  Object.defineProperty(listResponseMessageAttemptOut, "__esModule", { value: true });
  listResponseMessageAttemptOut.ListResponseMessageAttemptOutSerializer = void 0;
  const messageAttemptOut_1 = requireMessageAttemptOut();
  listResponseMessageAttemptOut.ListResponseMessageAttemptOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => messageAttemptOut_1.MessageAttemptOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data.map((item) => messageAttemptOut_1.MessageAttemptOutSerializer._toJsonObject(item)),
        done: self.done,
        iterator: self.iterator,
        prevIterator: self.prevIterator
      };
    }
  };
  return listResponseMessageAttemptOut;
}
var listResponseMessageEndpointOut = {};
var messageEndpointOut = {};
var hasRequiredMessageEndpointOut;
function requireMessageEndpointOut() {
  if (hasRequiredMessageEndpointOut) return messageEndpointOut;
  hasRequiredMessageEndpointOut = 1;
  Object.defineProperty(messageEndpointOut, "__esModule", { value: true });
  messageEndpointOut.MessageEndpointOutSerializer = void 0;
  const messageStatus_1 = requireMessageStatus();
  const messageStatusText_1 = requireMessageStatusText();
  messageEndpointOut.MessageEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        channels: object["channels"],
        createdAt: new Date(object["createdAt"]),
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        id: object["id"],
        nextAttempt: object["nextAttempt"] ? new Date(object["nextAttempt"]) : null,
        rateLimit: object["rateLimit"],
        status: messageStatus_1.MessageStatusSerializer._fromJsonObject(object["status"]),
        statusText: messageStatusText_1.MessageStatusTextSerializer._fromJsonObject(object["statusText"]),
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"]),
        url: object["url"],
        version: object["version"]
      };
    },
    _toJsonObject(self) {
      return {
        channels: self.channels,
        createdAt: self.createdAt,
        description: self.description,
        disabled: self.disabled,
        filterTypes: self.filterTypes,
        id: self.id,
        nextAttempt: self.nextAttempt,
        rateLimit: self.rateLimit,
        status: messageStatus_1.MessageStatusSerializer._toJsonObject(self.status),
        statusText: messageStatusText_1.MessageStatusTextSerializer._toJsonObject(self.statusText),
        uid: self.uid,
        updatedAt: self.updatedAt,
        url: self.url,
        version: self.version
      };
    }
  };
  return messageEndpointOut;
}
var hasRequiredListResponseMessageEndpointOut;
function requireListResponseMessageEndpointOut() {
  if (hasRequiredListResponseMessageEndpointOut) return listResponseMessageEndpointOut;
  hasRequiredListResponseMessageEndpointOut = 1;
  Object.defineProperty(listResponseMessageEndpointOut, "__esModule", { value: true });
  listResponseMessageEndpointOut.ListResponseMessageEndpointOutSerializer = void 0;
  const messageEndpointOut_1 = requireMessageEndpointOut();
  listResponseMessageEndpointOut.ListResponseMessageEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => messageEndpointOut_1.MessageEndpointOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data.map((item) => messageEndpointOut_1.MessageEndpointOutSerializer._toJsonObject(item)),
        done: self.done,
        iterator: self.iterator,
        prevIterator: self.prevIterator
      };
    }
  };
  return listResponseMessageEndpointOut;
}
var hasRequiredMessageAttempt;
function requireMessageAttempt() {
  if (hasRequiredMessageAttempt) return messageAttempt;
  hasRequiredMessageAttempt = 1;
  Object.defineProperty(messageAttempt, "__esModule", { value: true });
  messageAttempt.MessageAttempt = void 0;
  const listResponseEndpointMessageOut_1 = requireListResponseEndpointMessageOut();
  const listResponseMessageAttemptOut_1 = requireListResponseMessageAttemptOut();
  const listResponseMessageEndpointOut_1 = requireListResponseMessageEndpointOut();
  const messageAttemptOut_1 = requireMessageAttemptOut();
  const request_1 = requireRequest();
  class MessageAttempt {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    listByEndpoint(appId, endpointId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/attempt/endpoint/{endpoint_id}");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      request2.setQueryParam("status", options === null || options === void 0 ? void 0 : options.status);
      request2.setQueryParam("status_code_class", options === null || options === void 0 ? void 0 : options.statusCodeClass);
      request2.setQueryParam("channel", options === null || options === void 0 ? void 0 : options.channel);
      request2.setQueryParam("tag", options === null || options === void 0 ? void 0 : options.tag);
      request2.setQueryParam("before", options === null || options === void 0 ? void 0 : options.before);
      request2.setQueryParam("after", options === null || options === void 0 ? void 0 : options.after);
      request2.setQueryParam("with_content", options === null || options === void 0 ? void 0 : options.withContent);
      request2.setQueryParam("with_msg", options === null || options === void 0 ? void 0 : options.withMsg);
      request2.setQueryParam("event_types", options === null || options === void 0 ? void 0 : options.eventTypes);
      return request2.send(this.requestCtx, listResponseMessageAttemptOut_1.ListResponseMessageAttemptOutSerializer._fromJsonObject);
    }
    listByMsg(appId, msgId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/attempt/msg/{msg_id}");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("msg_id", msgId);
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      request2.setQueryParam("status", options === null || options === void 0 ? void 0 : options.status);
      request2.setQueryParam("status_code_class", options === null || options === void 0 ? void 0 : options.statusCodeClass);
      request2.setQueryParam("channel", options === null || options === void 0 ? void 0 : options.channel);
      request2.setQueryParam("tag", options === null || options === void 0 ? void 0 : options.tag);
      request2.setQueryParam("endpoint_id", options === null || options === void 0 ? void 0 : options.endpointId);
      request2.setQueryParam("before", options === null || options === void 0 ? void 0 : options.before);
      request2.setQueryParam("after", options === null || options === void 0 ? void 0 : options.after);
      request2.setQueryParam("with_content", options === null || options === void 0 ? void 0 : options.withContent);
      request2.setQueryParam("event_types", options === null || options === void 0 ? void 0 : options.eventTypes);
      return request2.send(this.requestCtx, listResponseMessageAttemptOut_1.ListResponseMessageAttemptOutSerializer._fromJsonObject);
    }
    listAttemptedMessages(appId, endpointId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/msg");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      request2.setQueryParam("channel", options === null || options === void 0 ? void 0 : options.channel);
      request2.setQueryParam("tag", options === null || options === void 0 ? void 0 : options.tag);
      request2.setQueryParam("status", options === null || options === void 0 ? void 0 : options.status);
      request2.setQueryParam("before", options === null || options === void 0 ? void 0 : options.before);
      request2.setQueryParam("after", options === null || options === void 0 ? void 0 : options.after);
      request2.setQueryParam("with_content", options === null || options === void 0 ? void 0 : options.withContent);
      request2.setQueryParam("event_types", options === null || options === void 0 ? void 0 : options.eventTypes);
      return request2.send(this.requestCtx, listResponseEndpointMessageOut_1.ListResponseEndpointMessageOutSerializer._fromJsonObject);
    }
    get(appId, msgId, attemptId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("msg_id", msgId);
      request2.setPathParam("attempt_id", attemptId);
      return request2.send(this.requestCtx, messageAttemptOut_1.MessageAttemptOutSerializer._fromJsonObject);
    }
    expungeContent(appId, msgId, attemptId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}/content");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("msg_id", msgId);
      request2.setPathParam("attempt_id", attemptId);
      return request2.sendNoResponseBody(this.requestCtx);
    }
    listAttemptedDestinations(appId, msgId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/msg/{msg_id}/endpoint");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("msg_id", msgId);
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      return request2.send(this.requestCtx, listResponseMessageEndpointOut_1.ListResponseMessageEndpointOutSerializer._fromJsonObject);
    }
    resend(appId, msgId, endpointId, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/resend");
      request2.setPathParam("app_id", appId);
      request2.setPathParam("msg_id", msgId);
      request2.setPathParam("endpoint_id", endpointId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      return request2.sendNoResponseBody(this.requestCtx);
    }
  }
  messageAttempt.MessageAttempt = MessageAttempt;
  return messageAttempt;
}
var operationalWebhook = {};
var operationalWebhookEndpoint = {};
var listResponseOperationalWebhookEndpointOut = {};
var operationalWebhookEndpointOut = {};
var hasRequiredOperationalWebhookEndpointOut;
function requireOperationalWebhookEndpointOut() {
  if (hasRequiredOperationalWebhookEndpointOut) return operationalWebhookEndpointOut;
  hasRequiredOperationalWebhookEndpointOut = 1;
  Object.defineProperty(operationalWebhookEndpointOut, "__esModule", { value: true });
  operationalWebhookEndpointOut.OperationalWebhookEndpointOutSerializer = void 0;
  operationalWebhookEndpointOut.OperationalWebhookEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        createdAt: new Date(object["createdAt"]),
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        id: object["id"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        updatedAt: new Date(object["updatedAt"]),
        url: object["url"]
      };
    },
    _toJsonObject(self) {
      return {
        createdAt: self.createdAt,
        description: self.description,
        disabled: self.disabled,
        filterTypes: self.filterTypes,
        id: self.id,
        metadata: self.metadata,
        rateLimit: self.rateLimit,
        uid: self.uid,
        updatedAt: self.updatedAt,
        url: self.url
      };
    }
  };
  return operationalWebhookEndpointOut;
}
var hasRequiredListResponseOperationalWebhookEndpointOut;
function requireListResponseOperationalWebhookEndpointOut() {
  if (hasRequiredListResponseOperationalWebhookEndpointOut) return listResponseOperationalWebhookEndpointOut;
  hasRequiredListResponseOperationalWebhookEndpointOut = 1;
  Object.defineProperty(listResponseOperationalWebhookEndpointOut, "__esModule", { value: true });
  listResponseOperationalWebhookEndpointOut.ListResponseOperationalWebhookEndpointOutSerializer = void 0;
  const operationalWebhookEndpointOut_1 = requireOperationalWebhookEndpointOut();
  listResponseOperationalWebhookEndpointOut.ListResponseOperationalWebhookEndpointOutSerializer = {
    _fromJsonObject(object) {
      return {
        data: object["data"].map((item) => operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._fromJsonObject(item)),
        done: object["done"],
        iterator: object["iterator"],
        prevIterator: object["prevIterator"]
      };
    },
    _toJsonObject(self) {
      return {
        data: self.data.map((item) => operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._toJsonObject(item)),
        done: self.done,
        iterator: self.iterator,
        prevIterator: self.prevIterator
      };
    }
  };
  return listResponseOperationalWebhookEndpointOut;
}
var operationalWebhookEndpointHeadersIn = {};
var hasRequiredOperationalWebhookEndpointHeadersIn;
function requireOperationalWebhookEndpointHeadersIn() {
  if (hasRequiredOperationalWebhookEndpointHeadersIn) return operationalWebhookEndpointHeadersIn;
  hasRequiredOperationalWebhookEndpointHeadersIn = 1;
  Object.defineProperty(operationalWebhookEndpointHeadersIn, "__esModule", { value: true });
  operationalWebhookEndpointHeadersIn.OperationalWebhookEndpointHeadersInSerializer = void 0;
  operationalWebhookEndpointHeadersIn.OperationalWebhookEndpointHeadersInSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"]
      };
    },
    _toJsonObject(self) {
      return {
        headers: self.headers
      };
    }
  };
  return operationalWebhookEndpointHeadersIn;
}
var operationalWebhookEndpointHeadersOut = {};
var hasRequiredOperationalWebhookEndpointHeadersOut;
function requireOperationalWebhookEndpointHeadersOut() {
  if (hasRequiredOperationalWebhookEndpointHeadersOut) return operationalWebhookEndpointHeadersOut;
  hasRequiredOperationalWebhookEndpointHeadersOut = 1;
  Object.defineProperty(operationalWebhookEndpointHeadersOut, "__esModule", { value: true });
  operationalWebhookEndpointHeadersOut.OperationalWebhookEndpointHeadersOutSerializer = void 0;
  operationalWebhookEndpointHeadersOut.OperationalWebhookEndpointHeadersOutSerializer = {
    _fromJsonObject(object) {
      return {
        headers: object["headers"],
        sensitive: object["sensitive"]
      };
    },
    _toJsonObject(self) {
      return {
        headers: self.headers,
        sensitive: self.sensitive
      };
    }
  };
  return operationalWebhookEndpointHeadersOut;
}
var operationalWebhookEndpointIn = {};
var hasRequiredOperationalWebhookEndpointIn;
function requireOperationalWebhookEndpointIn() {
  if (hasRequiredOperationalWebhookEndpointIn) return operationalWebhookEndpointIn;
  hasRequiredOperationalWebhookEndpointIn = 1;
  Object.defineProperty(operationalWebhookEndpointIn, "__esModule", { value: true });
  operationalWebhookEndpointIn.OperationalWebhookEndpointInSerializer = void 0;
  operationalWebhookEndpointIn.OperationalWebhookEndpointInSerializer = {
    _fromJsonObject(object) {
      return {
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        secret: object["secret"],
        uid: object["uid"],
        url: object["url"]
      };
    },
    _toJsonObject(self) {
      return {
        description: self.description,
        disabled: self.disabled,
        filterTypes: self.filterTypes,
        metadata: self.metadata,
        rateLimit: self.rateLimit,
        secret: self.secret,
        uid: self.uid,
        url: self.url
      };
    }
  };
  return operationalWebhookEndpointIn;
}
var operationalWebhookEndpointSecretIn = {};
var hasRequiredOperationalWebhookEndpointSecretIn;
function requireOperationalWebhookEndpointSecretIn() {
  if (hasRequiredOperationalWebhookEndpointSecretIn) return operationalWebhookEndpointSecretIn;
  hasRequiredOperationalWebhookEndpointSecretIn = 1;
  Object.defineProperty(operationalWebhookEndpointSecretIn, "__esModule", { value: true });
  operationalWebhookEndpointSecretIn.OperationalWebhookEndpointSecretInSerializer = void 0;
  operationalWebhookEndpointSecretIn.OperationalWebhookEndpointSecretInSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self) {
      return {
        key: self.key
      };
    }
  };
  return operationalWebhookEndpointSecretIn;
}
var operationalWebhookEndpointSecretOut = {};
var hasRequiredOperationalWebhookEndpointSecretOut;
function requireOperationalWebhookEndpointSecretOut() {
  if (hasRequiredOperationalWebhookEndpointSecretOut) return operationalWebhookEndpointSecretOut;
  hasRequiredOperationalWebhookEndpointSecretOut = 1;
  Object.defineProperty(operationalWebhookEndpointSecretOut, "__esModule", { value: true });
  operationalWebhookEndpointSecretOut.OperationalWebhookEndpointSecretOutSerializer = void 0;
  operationalWebhookEndpointSecretOut.OperationalWebhookEndpointSecretOutSerializer = {
    _fromJsonObject(object) {
      return {
        key: object["key"]
      };
    },
    _toJsonObject(self) {
      return {
        key: self.key
      };
    }
  };
  return operationalWebhookEndpointSecretOut;
}
var operationalWebhookEndpointUpdate = {};
var hasRequiredOperationalWebhookEndpointUpdate;
function requireOperationalWebhookEndpointUpdate() {
  if (hasRequiredOperationalWebhookEndpointUpdate) return operationalWebhookEndpointUpdate;
  hasRequiredOperationalWebhookEndpointUpdate = 1;
  Object.defineProperty(operationalWebhookEndpointUpdate, "__esModule", { value: true });
  operationalWebhookEndpointUpdate.OperationalWebhookEndpointUpdateSerializer = void 0;
  operationalWebhookEndpointUpdate.OperationalWebhookEndpointUpdateSerializer = {
    _fromJsonObject(object) {
      return {
        description: object["description"],
        disabled: object["disabled"],
        filterTypes: object["filterTypes"],
        metadata: object["metadata"],
        rateLimit: object["rateLimit"],
        uid: object["uid"],
        url: object["url"]
      };
    },
    _toJsonObject(self) {
      return {
        description: self.description,
        disabled: self.disabled,
        filterTypes: self.filterTypes,
        metadata: self.metadata,
        rateLimit: self.rateLimit,
        uid: self.uid,
        url: self.url
      };
    }
  };
  return operationalWebhookEndpointUpdate;
}
var hasRequiredOperationalWebhookEndpoint;
function requireOperationalWebhookEndpoint() {
  if (hasRequiredOperationalWebhookEndpoint) return operationalWebhookEndpoint;
  hasRequiredOperationalWebhookEndpoint = 1;
  Object.defineProperty(operationalWebhookEndpoint, "__esModule", { value: true });
  operationalWebhookEndpoint.OperationalWebhookEndpoint = void 0;
  const listResponseOperationalWebhookEndpointOut_1 = requireListResponseOperationalWebhookEndpointOut();
  const operationalWebhookEndpointHeadersIn_1 = requireOperationalWebhookEndpointHeadersIn();
  const operationalWebhookEndpointHeadersOut_1 = requireOperationalWebhookEndpointHeadersOut();
  const operationalWebhookEndpointIn_1 = requireOperationalWebhookEndpointIn();
  const operationalWebhookEndpointOut_1 = requireOperationalWebhookEndpointOut();
  const operationalWebhookEndpointSecretIn_1 = requireOperationalWebhookEndpointSecretIn();
  const operationalWebhookEndpointSecretOut_1 = requireOperationalWebhookEndpointSecretOut();
  const operationalWebhookEndpointUpdate_1 = requireOperationalWebhookEndpointUpdate();
  const request_1 = requireRequest();
  class OperationalWebhookEndpoint {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/operational-webhook/endpoint");
      request2.setQueryParam("limit", options === null || options === void 0 ? void 0 : options.limit);
      request2.setQueryParam("iterator", options === null || options === void 0 ? void 0 : options.iterator);
      request2.setQueryParam("order", options === null || options === void 0 ? void 0 : options.order);
      return request2.send(this.requestCtx, listResponseOperationalWebhookEndpointOut_1.ListResponseOperationalWebhookEndpointOutSerializer._fromJsonObject);
    }
    create(operationalWebhookEndpointIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/operational-webhook/endpoint");
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(operationalWebhookEndpointIn_1.OperationalWebhookEndpointInSerializer._toJsonObject(operationalWebhookEndpointIn2));
      return request2.send(this.requestCtx, operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._fromJsonObject);
    }
    get(endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/operational-webhook/endpoint/{endpoint_id}");
      request2.setPathParam("endpoint_id", endpointId);
      return request2.send(this.requestCtx, operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._fromJsonObject);
    }
    update(endpointId, operationalWebhookEndpointUpdate2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/operational-webhook/endpoint/{endpoint_id}");
      request2.setPathParam("endpoint_id", endpointId);
      request2.setBody(operationalWebhookEndpointUpdate_1.OperationalWebhookEndpointUpdateSerializer._toJsonObject(operationalWebhookEndpointUpdate2));
      return request2.send(this.requestCtx, operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._fromJsonObject);
    }
    delete(endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/operational-webhook/endpoint/{endpoint_id}");
      request2.setPathParam("endpoint_id", endpointId);
      return request2.sendNoResponseBody(this.requestCtx);
    }
    getHeaders(endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/operational-webhook/endpoint/{endpoint_id}/headers");
      request2.setPathParam("endpoint_id", endpointId);
      return request2.send(this.requestCtx, operationalWebhookEndpointHeadersOut_1.OperationalWebhookEndpointHeadersOutSerializer._fromJsonObject);
    }
    updateHeaders(endpointId, operationalWebhookEndpointHeadersIn2) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/operational-webhook/endpoint/{endpoint_id}/headers");
      request2.setPathParam("endpoint_id", endpointId);
      request2.setBody(operationalWebhookEndpointHeadersIn_1.OperationalWebhookEndpointHeadersInSerializer._toJsonObject(operationalWebhookEndpointHeadersIn2));
      return request2.sendNoResponseBody(this.requestCtx);
    }
    getSecret(endpointId) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/operational-webhook/endpoint/{endpoint_id}/secret");
      request2.setPathParam("endpoint_id", endpointId);
      return request2.send(this.requestCtx, operationalWebhookEndpointSecretOut_1.OperationalWebhookEndpointSecretOutSerializer._fromJsonObject);
    }
    rotateSecret(endpointId, operationalWebhookEndpointSecretIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/operational-webhook/endpoint/{endpoint_id}/secret/rotate");
      request2.setPathParam("endpoint_id", endpointId);
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(operationalWebhookEndpointSecretIn_1.OperationalWebhookEndpointSecretInSerializer._toJsonObject(operationalWebhookEndpointSecretIn2));
      return request2.sendNoResponseBody(this.requestCtx);
    }
  }
  operationalWebhookEndpoint.OperationalWebhookEndpoint = OperationalWebhookEndpoint;
  return operationalWebhookEndpoint;
}
var hasRequiredOperationalWebhook;
function requireOperationalWebhook() {
  if (hasRequiredOperationalWebhook) return operationalWebhook;
  hasRequiredOperationalWebhook = 1;
  Object.defineProperty(operationalWebhook, "__esModule", { value: true });
  operationalWebhook.OperationalWebhook = void 0;
  const operationalWebhookEndpoint_1 = requireOperationalWebhookEndpoint();
  class OperationalWebhook {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    get endpoint() {
      return new operationalWebhookEndpoint_1.OperationalWebhookEndpoint(this.requestCtx);
    }
  }
  operationalWebhook.OperationalWebhook = OperationalWebhook;
  return operationalWebhook;
}
var statistics = {};
var aggregateEventTypesOut = {};
var hasRequiredAggregateEventTypesOut;
function requireAggregateEventTypesOut() {
  if (hasRequiredAggregateEventTypesOut) return aggregateEventTypesOut;
  hasRequiredAggregateEventTypesOut = 1;
  Object.defineProperty(aggregateEventTypesOut, "__esModule", { value: true });
  aggregateEventTypesOut.AggregateEventTypesOutSerializer = void 0;
  const backgroundTaskStatus_1 = requireBackgroundTaskStatus();
  const backgroundTaskType_1 = requireBackgroundTaskType();
  aggregateEventTypesOut.AggregateEventTypesOutSerializer = {
    _fromJsonObject(object) {
      return {
        id: object["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object["task"])
      };
    },
    _toJsonObject(self) {
      return {
        id: self.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self.task)
      };
    }
  };
  return aggregateEventTypesOut;
}
var appUsageStatsIn = {};
var hasRequiredAppUsageStatsIn;
function requireAppUsageStatsIn() {
  if (hasRequiredAppUsageStatsIn) return appUsageStatsIn;
  hasRequiredAppUsageStatsIn = 1;
  Object.defineProperty(appUsageStatsIn, "__esModule", { value: true });
  appUsageStatsIn.AppUsageStatsInSerializer = void 0;
  appUsageStatsIn.AppUsageStatsInSerializer = {
    _fromJsonObject(object) {
      return {
        appIds: object["appIds"],
        since: new Date(object["since"]),
        until: new Date(object["until"])
      };
    },
    _toJsonObject(self) {
      return {
        appIds: self.appIds,
        since: self.since,
        until: self.until
      };
    }
  };
  return appUsageStatsIn;
}
var appUsageStatsOut = {};
var hasRequiredAppUsageStatsOut;
function requireAppUsageStatsOut() {
  if (hasRequiredAppUsageStatsOut) return appUsageStatsOut;
  hasRequiredAppUsageStatsOut = 1;
  Object.defineProperty(appUsageStatsOut, "__esModule", { value: true });
  appUsageStatsOut.AppUsageStatsOutSerializer = void 0;
  const backgroundTaskStatus_1 = requireBackgroundTaskStatus();
  const backgroundTaskType_1 = requireBackgroundTaskType();
  appUsageStatsOut.AppUsageStatsOutSerializer = {
    _fromJsonObject(object) {
      return {
        id: object["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object["task"]),
        unresolvedAppIds: object["unresolvedAppIds"]
      };
    },
    _toJsonObject(self) {
      return {
        id: self.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self.task),
        unresolvedAppIds: self.unresolvedAppIds
      };
    }
  };
  return appUsageStatsOut;
}
var hasRequiredStatistics;
function requireStatistics() {
  if (hasRequiredStatistics) return statistics;
  hasRequiredStatistics = 1;
  Object.defineProperty(statistics, "__esModule", { value: true });
  statistics.Statistics = void 0;
  const aggregateEventTypesOut_1 = requireAggregateEventTypesOut();
  const appUsageStatsIn_1 = requireAppUsageStatsIn();
  const appUsageStatsOut_1 = requireAppUsageStatsOut();
  const request_1 = requireRequest();
  class Statistics {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    aggregateAppStats(appUsageStatsIn2, options) {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/stats/usage/app");
      request2.setHeaderParam("idempotency-key", options === null || options === void 0 ? void 0 : options.idempotencyKey);
      request2.setBody(appUsageStatsIn_1.AppUsageStatsInSerializer._toJsonObject(appUsageStatsIn2));
      return request2.send(this.requestCtx, appUsageStatsOut_1.AppUsageStatsOutSerializer._fromJsonObject);
    }
    aggregateEventTypes() {
      const request2 = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/stats/usage/event-types");
      return request2.send(this.requestCtx, aggregateEventTypesOut_1.AggregateEventTypesOutSerializer._fromJsonObject);
    }
  }
  statistics.Statistics = Statistics;
  return statistics;
}
var HttpErrors = {};
var hasRequiredHttpErrors;
function requireHttpErrors() {
  if (hasRequiredHttpErrors) return HttpErrors;
  hasRequiredHttpErrors = 1;
  Object.defineProperty(HttpErrors, "__esModule", { value: true });
  HttpErrors.HTTPValidationError = HttpErrors.ValidationError = HttpErrors.HttpErrorOut = void 0;
  class HttpErrorOut {
    static getAttributeTypeMap() {
      return HttpErrorOut.attributeTypeMap;
    }
  }
  HttpErrors.HttpErrorOut = HttpErrorOut;
  HttpErrorOut.discriminator = void 0;
  HttpErrorOut.mapping = void 0;
  HttpErrorOut.attributeTypeMap = [
    {
      name: "code",
      baseName: "code",
      type: "string",
      format: ""
    },
    {
      name: "detail",
      baseName: "detail",
      type: "string",
      format: ""
    }
  ];
  class ValidationError {
    static getAttributeTypeMap() {
      return ValidationError.attributeTypeMap;
    }
  }
  HttpErrors.ValidationError = ValidationError;
  ValidationError.discriminator = void 0;
  ValidationError.mapping = void 0;
  ValidationError.attributeTypeMap = [
    {
      name: "loc",
      baseName: "loc",
      type: "Array<string>",
      format: ""
    },
    {
      name: "msg",
      baseName: "msg",
      type: "string",
      format: ""
    },
    {
      name: "type",
      baseName: "type",
      type: "string",
      format: ""
    }
  ];
  class HTTPValidationError {
    static getAttributeTypeMap() {
      return HTTPValidationError.attributeTypeMap;
    }
  }
  HttpErrors.HTTPValidationError = HTTPValidationError;
  HTTPValidationError.discriminator = void 0;
  HTTPValidationError.mapping = void 0;
  HTTPValidationError.attributeTypeMap = [
    {
      name: "detail",
      baseName: "detail",
      type: "Array<ValidationError>",
      format: ""
    }
  ];
  return HttpErrors;
}
var webhook = {};
var timing_safe_equal = {};
var hasRequiredTiming_safe_equal;
function requireTiming_safe_equal() {
  if (hasRequiredTiming_safe_equal) return timing_safe_equal;
  hasRequiredTiming_safe_equal = 1;
  Object.defineProperty(timing_safe_equal, "__esModule", { value: true });
  timing_safe_equal.timingSafeEqual = void 0;
  function assert(expr, msg = "") {
    if (!expr) {
      throw new Error(msg);
    }
  }
  function timingSafeEqual(a, b2) {
    if (a.byteLength !== b2.byteLength) {
      return false;
    }
    if (!(a instanceof DataView)) {
      a = new DataView(ArrayBuffer.isView(a) ? a.buffer : a);
    }
    if (!(b2 instanceof DataView)) {
      b2 = new DataView(ArrayBuffer.isView(b2) ? b2.buffer : b2);
    }
    assert(a instanceof DataView);
    assert(b2 instanceof DataView);
    const length = a.byteLength;
    let out = 0;
    let i = -1;
    while (++i < length) {
      out |= a.getUint8(i) ^ b2.getUint8(i);
    }
    return out === 0;
  }
  timing_safe_equal.timingSafeEqual = timingSafeEqual;
  return timing_safe_equal;
}
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  var __extends = base64 && base64.__extends || /* @__PURE__ */ (function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3) if (b3.hasOwnProperty(p)) d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
  })();
  Object.defineProperty(base64, "__esModule", { value: true });
  var INVALID_BYTE = 256;
  var Coder = (
    /** @class */
    (function() {
      function Coder2(_paddingCharacter) {
        if (_paddingCharacter === void 0) {
          _paddingCharacter = "=";
        }
        this._paddingCharacter = _paddingCharacter;
      }
      Coder2.prototype.encodedLength = function(length) {
        if (!this._paddingCharacter) {
          return (length * 8 + 5) / 6 | 0;
        }
        return (length + 2) / 3 * 4 | 0;
      };
      Coder2.prototype.encode = function(data) {
        var out = "";
        var i = 0;
        for (; i < data.length - 2; i += 3) {
          var c = data[i] << 16 | data[i + 1] << 8 | data[i + 2];
          out += this._encodeByte(c >>> 3 * 6 & 63);
          out += this._encodeByte(c >>> 2 * 6 & 63);
          out += this._encodeByte(c >>> 1 * 6 & 63);
          out += this._encodeByte(c >>> 0 * 6 & 63);
        }
        var left = data.length - i;
        if (left > 0) {
          var c = data[i] << 16 | (left === 2 ? data[i + 1] << 8 : 0);
          out += this._encodeByte(c >>> 3 * 6 & 63);
          out += this._encodeByte(c >>> 2 * 6 & 63);
          if (left === 2) {
            out += this._encodeByte(c >>> 1 * 6 & 63);
          } else {
            out += this._paddingCharacter || "";
          }
          out += this._paddingCharacter || "";
        }
        return out;
      };
      Coder2.prototype.maxDecodedLength = function(length) {
        if (!this._paddingCharacter) {
          return (length * 6 + 7) / 8 | 0;
        }
        return length / 4 * 3 | 0;
      };
      Coder2.prototype.decodedLength = function(s) {
        return this.maxDecodedLength(s.length - this._getPaddingLength(s));
      };
      Coder2.prototype.decode = function(s) {
        if (s.length === 0) {
          return new Uint8Array(0);
        }
        var paddingLength = this._getPaddingLength(s);
        var length = s.length - paddingLength;
        var out = new Uint8Array(this.maxDecodedLength(length));
        var op = 0;
        var i = 0;
        var haveBad = 0;
        var v0 = 0, v12 = 0, v2 = 0, v32 = 0;
        for (; i < length - 4; i += 4) {
          v0 = this._decodeChar(s.charCodeAt(i + 0));
          v12 = this._decodeChar(s.charCodeAt(i + 1));
          v2 = this._decodeChar(s.charCodeAt(i + 2));
          v32 = this._decodeChar(s.charCodeAt(i + 3));
          out[op++] = v0 << 2 | v12 >>> 4;
          out[op++] = v12 << 4 | v2 >>> 2;
          out[op++] = v2 << 6 | v32;
          haveBad |= v0 & INVALID_BYTE;
          haveBad |= v12 & INVALID_BYTE;
          haveBad |= v2 & INVALID_BYTE;
          haveBad |= v32 & INVALID_BYTE;
        }
        if (i < length - 1) {
          v0 = this._decodeChar(s.charCodeAt(i));
          v12 = this._decodeChar(s.charCodeAt(i + 1));
          out[op++] = v0 << 2 | v12 >>> 4;
          haveBad |= v0 & INVALID_BYTE;
          haveBad |= v12 & INVALID_BYTE;
        }
        if (i < length - 2) {
          v2 = this._decodeChar(s.charCodeAt(i + 2));
          out[op++] = v12 << 4 | v2 >>> 2;
          haveBad |= v2 & INVALID_BYTE;
        }
        if (i < length - 3) {
          v32 = this._decodeChar(s.charCodeAt(i + 3));
          out[op++] = v2 << 6 | v32;
          haveBad |= v32 & INVALID_BYTE;
        }
        if (haveBad !== 0) {
          throw new Error("Base64Coder: incorrect characters for decoding");
        }
        return out;
      };
      Coder2.prototype._encodeByte = function(b2) {
        var result = b2;
        result += 65;
        result += 25 - b2 >>> 8 & 0 - 65 - 26 + 97;
        result += 51 - b2 >>> 8 & 26 - 97 - 52 + 48;
        result += 61 - b2 >>> 8 & 52 - 48 - 62 + 43;
        result += 62 - b2 >>> 8 & 62 - 43 - 63 + 47;
        return String.fromCharCode(result);
      };
      Coder2.prototype._decodeChar = function(c) {
        var result = INVALID_BYTE;
        result += (42 - c & c - 44) >>> 8 & -INVALID_BYTE + c - 43 + 62;
        result += (46 - c & c - 48) >>> 8 & -INVALID_BYTE + c - 47 + 63;
        result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
        result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
        result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
        return result;
      };
      Coder2.prototype._getPaddingLength = function(s) {
        var paddingLength = 0;
        if (this._paddingCharacter) {
          for (var i = s.length - 1; i >= 0; i--) {
            if (s[i] !== this._paddingCharacter) {
              break;
            }
            paddingLength++;
          }
          if (s.length < 4 || paddingLength > 2) {
            throw new Error("Base64Coder: incorrect padding");
          }
        }
        return paddingLength;
      };
      return Coder2;
    })()
  );
  base64.Coder = Coder;
  var stdCoder = new Coder();
  function encode2(data) {
    return stdCoder.encode(data);
  }
  base64.encode = encode2;
  function decode2(s) {
    return stdCoder.decode(s);
  }
  base64.decode = decode2;
  var URLSafeCoder = (
    /** @class */
    (function(_super) {
      __extends(URLSafeCoder2, _super);
      function URLSafeCoder2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      URLSafeCoder2.prototype._encodeByte = function(b2) {
        var result = b2;
        result += 65;
        result += 25 - b2 >>> 8 & 0 - 65 - 26 + 97;
        result += 51 - b2 >>> 8 & 26 - 97 - 52 + 48;
        result += 61 - b2 >>> 8 & 52 - 48 - 62 + 45;
        result += 62 - b2 >>> 8 & 62 - 45 - 63 + 95;
        return String.fromCharCode(result);
      };
      URLSafeCoder2.prototype._decodeChar = function(c) {
        var result = INVALID_BYTE;
        result += (44 - c & c - 46) >>> 8 & -INVALID_BYTE + c - 45 + 62;
        result += (94 - c & c - 96) >>> 8 & -INVALID_BYTE + c - 95 + 63;
        result += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52;
        result += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0;
        result += (96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26;
        return result;
      };
      return URLSafeCoder2;
    })(Coder)
  );
  base64.URLSafeCoder = URLSafeCoder;
  var urlSafeCoder = new URLSafeCoder();
  function encodeURLSafe(data) {
    return urlSafeCoder.encode(data);
  }
  base64.encodeURLSafe = encodeURLSafe;
  function decodeURLSafe(s) {
    return urlSafeCoder.decode(s);
  }
  base64.decodeURLSafe = decodeURLSafe;
  base64.encodedLength = function(length) {
    return stdCoder.encodedLength(length);
  };
  base64.maxDecodedLength = function(length) {
    return stdCoder.maxDecodedLength(length);
  };
  base64.decodedLength = function(s) {
    return stdCoder.decodedLength(s);
  };
  return base64;
}
var sha256$1 = { exports: {} };
var sha256 = sha256$1.exports;
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$1.exports;
  hasRequiredSha256 = 1;
  (function(module) {
    (function(root, factory) {
      var exports$1 = {};
      factory(exports$1);
      var sha2562 = exports$1["default"];
      for (var k2 in exports$1) {
        sha2562[k2] = exports$1[k2];
      }
      {
        module.exports = sha2562;
      }
    })(sha256, function(exports$1) {
      exports$1.__esModule = true;
      exports$1.digestLength = 32;
      exports$1.blockSize = 64;
      var K2 = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      function hashBlocks(w2, v2, p, pos, len) {
        var a, b2, c, d, e, f2, g, h2, u, i, j2, t1, t2;
        while (len >= 64) {
          a = v2[0];
          b2 = v2[1];
          c = v2[2];
          d = v2[3];
          e = v2[4];
          f2 = v2[5];
          g = v2[6];
          h2 = v2[7];
          for (i = 0; i < 16; i++) {
            j2 = pos + i * 4;
            w2[i] = (p[j2] & 255) << 24 | (p[j2 + 1] & 255) << 16 | (p[j2 + 2] & 255) << 8 | p[j2 + 3] & 255;
          }
          for (i = 16; i < 64; i++) {
            u = w2[i - 2];
            t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
            u = w2[i - 15];
            t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
            w2[i] = (t1 + w2[i - 7] | 0) + (t2 + w2[i - 16] | 0);
          }
          for (i = 0; i < 64; i++) {
            t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f2 ^ ~e & g) | 0) + (h2 + (K2[i] + w2[i] | 0) | 0) | 0;
            t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b2 ^ a & c ^ b2 & c) | 0;
            h2 = g;
            g = f2;
            f2 = e;
            e = d + t1 | 0;
            d = c;
            c = b2;
            b2 = a;
            a = t1 + t2 | 0;
          }
          v2[0] += a;
          v2[1] += b2;
          v2[2] += c;
          v2[3] += d;
          v2[4] += e;
          v2[5] += f2;
          v2[6] += g;
          v2[7] += h2;
          pos += 64;
          len -= 64;
        }
        return pos;
      }
      var Hash = (
        /** @class */
        (function() {
          function Hash2() {
            this.digestLength = exports$1.digestLength;
            this.blockSize = exports$1.blockSize;
            this.state = new Int32Array(8);
            this.temp = new Int32Array(64);
            this.buffer = new Uint8Array(128);
            this.bufferLength = 0;
            this.bytesHashed = 0;
            this.finished = false;
            this.reset();
          }
          Hash2.prototype.reset = function() {
            this.state[0] = 1779033703;
            this.state[1] = 3144134277;
            this.state[2] = 1013904242;
            this.state[3] = 2773480762;
            this.state[4] = 1359893119;
            this.state[5] = 2600822924;
            this.state[6] = 528734635;
            this.state[7] = 1541459225;
            this.bufferLength = 0;
            this.bytesHashed = 0;
            this.finished = false;
            return this;
          };
          Hash2.prototype.clean = function() {
            for (var i = 0; i < this.buffer.length; i++) {
              this.buffer[i] = 0;
            }
            for (var i = 0; i < this.temp.length; i++) {
              this.temp[i] = 0;
            }
            this.reset();
          };
          Hash2.prototype.update = function(data, dataLength) {
            if (dataLength === void 0) {
              dataLength = data.length;
            }
            if (this.finished) {
              throw new Error("SHA256: can't update because hash was finished.");
            }
            var dataPos = 0;
            this.bytesHashed += dataLength;
            if (this.bufferLength > 0) {
              while (this.bufferLength < 64 && dataLength > 0) {
                this.buffer[this.bufferLength++] = data[dataPos++];
                dataLength--;
              }
              if (this.bufferLength === 64) {
                hashBlocks(this.temp, this.state, this.buffer, 0, 64);
                this.bufferLength = 0;
              }
            }
            if (dataLength >= 64) {
              dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);
              dataLength %= 64;
            }
            while (dataLength > 0) {
              this.buffer[this.bufferLength++] = data[dataPos++];
              dataLength--;
            }
            return this;
          };
          Hash2.prototype.finish = function(out) {
            if (!this.finished) {
              var bytesHashed = this.bytesHashed;
              var left = this.bufferLength;
              var bitLenHi = bytesHashed / 536870912 | 0;
              var bitLenLo = bytesHashed << 3;
              var padLength = bytesHashed % 64 < 56 ? 64 : 128;
              this.buffer[left] = 128;
              for (var i = left + 1; i < padLength - 8; i++) {
                this.buffer[i] = 0;
              }
              this.buffer[padLength - 8] = bitLenHi >>> 24 & 255;
              this.buffer[padLength - 7] = bitLenHi >>> 16 & 255;
              this.buffer[padLength - 6] = bitLenHi >>> 8 & 255;
              this.buffer[padLength - 5] = bitLenHi >>> 0 & 255;
              this.buffer[padLength - 4] = bitLenLo >>> 24 & 255;
              this.buffer[padLength - 3] = bitLenLo >>> 16 & 255;
              this.buffer[padLength - 2] = bitLenLo >>> 8 & 255;
              this.buffer[padLength - 1] = bitLenLo >>> 0 & 255;
              hashBlocks(this.temp, this.state, this.buffer, 0, padLength);
              this.finished = true;
            }
            for (var i = 0; i < 8; i++) {
              out[i * 4 + 0] = this.state[i] >>> 24 & 255;
              out[i * 4 + 1] = this.state[i] >>> 16 & 255;
              out[i * 4 + 2] = this.state[i] >>> 8 & 255;
              out[i * 4 + 3] = this.state[i] >>> 0 & 255;
            }
            return this;
          };
          Hash2.prototype.digest = function() {
            var out = new Uint8Array(this.digestLength);
            this.finish(out);
            return out;
          };
          Hash2.prototype._saveState = function(out) {
            for (var i = 0; i < this.state.length; i++) {
              out[i] = this.state[i];
            }
          };
          Hash2.prototype._restoreState = function(from, bytesHashed) {
            for (var i = 0; i < this.state.length; i++) {
              this.state[i] = from[i];
            }
            this.bytesHashed = bytesHashed;
            this.finished = false;
            this.bufferLength = 0;
          };
          return Hash2;
        })()
      );
      exports$1.Hash = Hash;
      var HMAC = (
        /** @class */
        (function() {
          function HMAC2(key) {
            this.inner = new Hash();
            this.outer = new Hash();
            this.blockSize = this.inner.blockSize;
            this.digestLength = this.inner.digestLength;
            var pad = new Uint8Array(this.blockSize);
            if (key.length > this.blockSize) {
              new Hash().update(key).finish(pad).clean();
            } else {
              for (var i = 0; i < key.length; i++) {
                pad[i] = key[i];
              }
            }
            for (var i = 0; i < pad.length; i++) {
              pad[i] ^= 54;
            }
            this.inner.update(pad);
            for (var i = 0; i < pad.length; i++) {
              pad[i] ^= 54 ^ 92;
            }
            this.outer.update(pad);
            this.istate = new Uint32Array(8);
            this.ostate = new Uint32Array(8);
            this.inner._saveState(this.istate);
            this.outer._saveState(this.ostate);
            for (var i = 0; i < pad.length; i++) {
              pad[i] = 0;
            }
          }
          HMAC2.prototype.reset = function() {
            this.inner._restoreState(this.istate, this.inner.blockSize);
            this.outer._restoreState(this.ostate, this.outer.blockSize);
            return this;
          };
          HMAC2.prototype.clean = function() {
            for (var i = 0; i < this.istate.length; i++) {
              this.ostate[i] = this.istate[i] = 0;
            }
            this.inner.clean();
            this.outer.clean();
          };
          HMAC2.prototype.update = function(data) {
            this.inner.update(data);
            return this;
          };
          HMAC2.prototype.finish = function(out) {
            if (this.outer.finished) {
              this.outer.finish(out);
            } else {
              this.inner.finish(out);
              this.outer.update(out, this.digestLength).finish(out);
            }
            return this;
          };
          HMAC2.prototype.digest = function() {
            var out = new Uint8Array(this.digestLength);
            this.finish(out);
            return out;
          };
          return HMAC2;
        })()
      );
      exports$1.HMAC = HMAC;
      function hash(data) {
        var h2 = new Hash().update(data);
        var digest = h2.digest();
        h2.clean();
        return digest;
      }
      exports$1.hash = hash;
      exports$1["default"] = hash;
      function hmac(key, data) {
        var h2 = new HMAC(key).update(data);
        var digest = h2.digest();
        h2.clean();
        return digest;
      }
      exports$1.hmac = hmac;
      function fillBuffer(buffer, hmac2, info, counter) {
        var num2 = counter[0];
        if (num2 === 0) {
          throw new Error("hkdf: cannot expand more");
        }
        hmac2.reset();
        if (num2 > 1) {
          hmac2.update(buffer);
        }
        if (info) {
          hmac2.update(info);
        }
        hmac2.update(counter);
        hmac2.finish(buffer);
        counter[0]++;
      }
      var hkdfSalt = new Uint8Array(exports$1.digestLength);
      function hkdf(key, salt, info, length) {
        if (salt === void 0) {
          salt = hkdfSalt;
        }
        if (length === void 0) {
          length = 32;
        }
        var counter = new Uint8Array([1]);
        var okm = hmac(salt, key);
        var hmac_ = new HMAC(okm);
        var buffer = new Uint8Array(hmac_.digestLength);
        var bufpos = buffer.length;
        var out = new Uint8Array(length);
        for (var i = 0; i < length; i++) {
          if (bufpos === buffer.length) {
            fillBuffer(buffer, hmac_, info, counter);
            bufpos = 0;
          }
          out[i] = buffer[bufpos++];
        }
        hmac_.clean();
        buffer.fill(0);
        counter.fill(0);
        return out;
      }
      exports$1.hkdf = hkdf;
      function pbkdf2(password, salt, iterations, dkLen) {
        var prf = new HMAC(password);
        var len = prf.digestLength;
        var ctr = new Uint8Array(4);
        var t = new Uint8Array(len);
        var u = new Uint8Array(len);
        var dk = new Uint8Array(dkLen);
        for (var i = 0; i * len < dkLen; i++) {
          var c = i + 1;
          ctr[0] = c >>> 24 & 255;
          ctr[1] = c >>> 16 & 255;
          ctr[2] = c >>> 8 & 255;
          ctr[3] = c >>> 0 & 255;
          prf.reset();
          prf.update(salt);
          prf.update(ctr);
          prf.finish(u);
          for (var j2 = 0; j2 < len; j2++) {
            t[j2] = u[j2];
          }
          for (var j2 = 2; j2 <= iterations; j2++) {
            prf.reset();
            prf.update(u).finish(u);
            for (var k2 = 0; k2 < len; k2++) {
              t[k2] ^= u[k2];
            }
          }
          for (var j2 = 0; j2 < len && i * len + j2 < dkLen; j2++) {
            dk[i * len + j2] = t[j2];
          }
        }
        for (var i = 0; i < len; i++) {
          t[i] = u[i] = 0;
        }
        for (var i = 0; i < 4; i++) {
          ctr[i] = 0;
        }
        prf.clean();
        return dk;
      }
      exports$1.pbkdf2 = pbkdf2;
    });
  })(sha256$1);
  return sha256$1.exports;
}
var hasRequiredWebhook;
function requireWebhook() {
  if (hasRequiredWebhook) return webhook;
  hasRequiredWebhook = 1;
  Object.defineProperty(webhook, "__esModule", { value: true });
  webhook.Webhook = webhook.WebhookVerificationError = void 0;
  const timing_safe_equal_1 = requireTiming_safe_equal();
  const base642 = requireBase64();
  const sha2562 = requireSha256();
  const WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;
  class ExtendableError extends Error {
    constructor(message2) {
      super(message2);
      Object.setPrototypeOf(this, ExtendableError.prototype);
      this.name = "ExtendableError";
      this.stack = new Error(message2).stack;
    }
  }
  class WebhookVerificationError extends ExtendableError {
    constructor(message2) {
      super(message2);
      Object.setPrototypeOf(this, WebhookVerificationError.prototype);
      this.name = "WebhookVerificationError";
    }
  }
  webhook.WebhookVerificationError = WebhookVerificationError;
  class Webhook {
    constructor(secret, options) {
      if (!secret) {
        throw new Error("Secret can't be empty.");
      }
      if ((options === null || options === void 0 ? void 0 : options.format) === "raw") {
        if (secret instanceof Uint8Array) {
          this.key = secret;
        } else {
          this.key = Uint8Array.from(secret, (c) => c.charCodeAt(0));
        }
      } else {
        if (typeof secret !== "string") {
          throw new Error("Expected secret to be of type string");
        }
        if (secret.startsWith(Webhook.prefix)) {
          secret = secret.substring(Webhook.prefix.length);
        }
        this.key = base642.decode(secret);
      }
    }
    verify(payload, headers_) {
      const headers = {};
      for (const key of Object.keys(headers_)) {
        headers[key.toLowerCase()] = headers_[key];
      }
      let msgId = headers["svix-id"];
      let msgSignature = headers["svix-signature"];
      let msgTimestamp = headers["svix-timestamp"];
      if (!msgSignature || !msgId || !msgTimestamp) {
        msgId = headers["webhook-id"];
        msgSignature = headers["webhook-signature"];
        msgTimestamp = headers["webhook-timestamp"];
        if (!msgSignature || !msgId || !msgTimestamp) {
          throw new WebhookVerificationError("Missing required headers");
        }
      }
      const timestamp = this.verifyTimestamp(msgTimestamp);
      const computedSignature = this.sign(msgId, timestamp, payload);
      const expectedSignature = computedSignature.split(",")[1];
      const passedSignatures = msgSignature.split(" ");
      const encoder = new globalThis.TextEncoder();
      for (const versionedSignature of passedSignatures) {
        const [version2, signature] = versionedSignature.split(",");
        if (version2 !== "v1") {
          continue;
        }
        if ((0, timing_safe_equal_1.timingSafeEqual)(encoder.encode(signature), encoder.encode(expectedSignature))) {
          return JSON.parse(payload.toString());
        }
      }
      throw new WebhookVerificationError("No matching signature found");
    }
    sign(msgId, timestamp, payload) {
      if (typeof payload === "string") ;
      else if (payload.constructor.name === "Buffer") {
        payload = payload.toString();
      } else {
        throw new Error("Expected payload to be of type string or Buffer. Please refer to https://docs.svix.com/receiving/verifying-payloads/how for more information.");
      }
      const encoder = new TextEncoder();
      const timestampNumber = Math.floor(timestamp.getTime() / 1e3);
      const toSign = encoder.encode(`${msgId}.${timestampNumber}.${payload}`);
      const expectedSignature = base642.encode(sha2562.hmac(this.key, toSign));
      return `v1,${expectedSignature}`;
    }
    verifyTimestamp(timestampHeader) {
      const now = Math.floor(Date.now() / 1e3);
      const timestamp = parseInt(timestampHeader, 10);
      if (isNaN(timestamp)) {
        throw new WebhookVerificationError("Invalid Signature Headers");
      }
      if (now - timestamp > WEBHOOK_TOLERANCE_IN_SECONDS) {
        throw new WebhookVerificationError("Message timestamp too old");
      }
      if (timestamp > now + WEBHOOK_TOLERANCE_IN_SECONDS) {
        throw new WebhookVerificationError("Message timestamp too new");
      }
      return new Date(timestamp * 1e3);
    }
  }
  webhook.Webhook = Webhook;
  Webhook.prefix = "whsec_";
  return webhook;
}
var models = {};
var endpointDisabledTrigger = {};
var hasRequiredEndpointDisabledTrigger;
function requireEndpointDisabledTrigger() {
  if (hasRequiredEndpointDisabledTrigger) return endpointDisabledTrigger;
  hasRequiredEndpointDisabledTrigger = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.EndpointDisabledTriggerSerializer = exports$1.EndpointDisabledTrigger = void 0;
    (function(EndpointDisabledTrigger) {
      EndpointDisabledTrigger["Manual"] = "manual";
      EndpointDisabledTrigger["Automatic"] = "automatic";
    })(exports$1.EndpointDisabledTrigger || (exports$1.EndpointDisabledTrigger = {}));
    exports$1.EndpointDisabledTriggerSerializer = {
      _fromJsonObject(object) {
        return object;
      },
      _toJsonObject(self) {
        return self;
      }
    };
  })(endpointDisabledTrigger);
  return endpointDisabledTrigger;
}
var ordering = {};
var hasRequiredOrdering;
function requireOrdering() {
  if (hasRequiredOrdering) return ordering;
  hasRequiredOrdering = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.OrderingSerializer = exports$1.Ordering = void 0;
    (function(Ordering) {
      Ordering["Ascending"] = "ascending";
      Ordering["Descending"] = "descending";
    })(exports$1.Ordering || (exports$1.Ordering = {}));
    exports$1.OrderingSerializer = {
      _fromJsonObject(object) {
        return object;
      },
      _toJsonObject(self) {
        return self;
      }
    };
  })(ordering);
  return ordering;
}
var statusCodeClass = {};
var hasRequiredStatusCodeClass;
function requireStatusCodeClass() {
  if (hasRequiredStatusCodeClass) return statusCodeClass;
  hasRequiredStatusCodeClass = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.StatusCodeClassSerializer = exports$1.StatusCodeClass = void 0;
    (function(StatusCodeClass) {
      StatusCodeClass[StatusCodeClass["CodeNone"] = 0] = "CodeNone";
      StatusCodeClass[StatusCodeClass["Code1xx"] = 100] = "Code1xx";
      StatusCodeClass[StatusCodeClass["Code2xx"] = 200] = "Code2xx";
      StatusCodeClass[StatusCodeClass["Code3xx"] = 300] = "Code3xx";
      StatusCodeClass[StatusCodeClass["Code4xx"] = 400] = "Code4xx";
      StatusCodeClass[StatusCodeClass["Code5xx"] = 500] = "Code5xx";
    })(exports$1.StatusCodeClass || (exports$1.StatusCodeClass = {}));
    exports$1.StatusCodeClassSerializer = {
      _fromJsonObject(object) {
        return object;
      },
      _toJsonObject(self) {
        return self;
      }
    };
  })(statusCodeClass);
  return statusCodeClass;
}
var hasRequiredModels;
function requireModels() {
  if (hasRequiredModels) return models;
  hasRequiredModels = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.StatusCodeClass = exports$1.Ordering = exports$1.MessageStatusText = exports$1.MessageStatus = exports$1.MessageAttemptTriggerType = exports$1.EndpointDisabledTrigger = exports$1.ConnectorKind = exports$1.BackgroundTaskType = exports$1.BackgroundTaskStatus = exports$1.AppPortalCapability = void 0;
    var appPortalCapability_1 = requireAppPortalCapability();
    Object.defineProperty(exports$1, "AppPortalCapability", { enumerable: true, get: function() {
      return appPortalCapability_1.AppPortalCapability;
    } });
    var backgroundTaskStatus_1 = requireBackgroundTaskStatus();
    Object.defineProperty(exports$1, "BackgroundTaskStatus", { enumerable: true, get: function() {
      return backgroundTaskStatus_1.BackgroundTaskStatus;
    } });
    var backgroundTaskType_1 = requireBackgroundTaskType();
    Object.defineProperty(exports$1, "BackgroundTaskType", { enumerable: true, get: function() {
      return backgroundTaskType_1.BackgroundTaskType;
    } });
    var connectorKind_1 = requireConnectorKind();
    Object.defineProperty(exports$1, "ConnectorKind", { enumerable: true, get: function() {
      return connectorKind_1.ConnectorKind;
    } });
    var endpointDisabledTrigger_1 = requireEndpointDisabledTrigger();
    Object.defineProperty(exports$1, "EndpointDisabledTrigger", { enumerable: true, get: function() {
      return endpointDisabledTrigger_1.EndpointDisabledTrigger;
    } });
    var messageAttemptTriggerType_1 = requireMessageAttemptTriggerType();
    Object.defineProperty(exports$1, "MessageAttemptTriggerType", { enumerable: true, get: function() {
      return messageAttemptTriggerType_1.MessageAttemptTriggerType;
    } });
    var messageStatus_1 = requireMessageStatus();
    Object.defineProperty(exports$1, "MessageStatus", { enumerable: true, get: function() {
      return messageStatus_1.MessageStatus;
    } });
    var messageStatusText_1 = requireMessageStatusText();
    Object.defineProperty(exports$1, "MessageStatusText", { enumerable: true, get: function() {
      return messageStatusText_1.MessageStatusText;
    } });
    var ordering_1 = requireOrdering();
    Object.defineProperty(exports$1, "Ordering", { enumerable: true, get: function() {
      return ordering_1.Ordering;
    } });
    var statusCodeClass_1 = requireStatusCodeClass();
    Object.defineProperty(exports$1, "StatusCodeClass", { enumerable: true, get: function() {
      return statusCodeClass_1.StatusCodeClass;
    } });
  })(models);
  return models;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist$1;
  hasRequiredDist = 1;
  (function(exports$1) {
    var __createBinding = dist$1 && dist$1.__createBinding || (Object.create ? (function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    }) : (function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    }));
    var __exportStar = dist$1 && dist$1.__exportStar || function(m, exports$12) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
    };
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.Svix = exports$1.messageInRaw = exports$1.ValidationError = exports$1.HttpErrorOut = exports$1.HTTPValidationError = exports$1.ApiException = void 0;
    const application_1 = requireApplication();
    const authentication_1 = requireAuthentication();
    const backgroundTask_1 = requireBackgroundTask();
    const endpoint_1 = requireEndpoint();
    const environment_1 = requireEnvironment();
    const eventType_1 = requireEventType();
    const health_1 = requireHealth();
    const ingest_1 = requireIngest();
    const integration_1 = requireIntegration();
    const message_1 = requireMessage();
    const messageAttempt_1 = requireMessageAttempt();
    const operationalWebhook_1 = requireOperationalWebhook();
    const statistics_1 = requireStatistics();
    const operationalWebhookEndpoint_1 = requireOperationalWebhookEndpoint();
    var util_1 = requireUtil();
    Object.defineProperty(exports$1, "ApiException", { enumerable: true, get: function() {
      return util_1.ApiException;
    } });
    var HttpErrors_1 = requireHttpErrors();
    Object.defineProperty(exports$1, "HTTPValidationError", { enumerable: true, get: function() {
      return HttpErrors_1.HTTPValidationError;
    } });
    Object.defineProperty(exports$1, "HttpErrorOut", { enumerable: true, get: function() {
      return HttpErrors_1.HttpErrorOut;
    } });
    Object.defineProperty(exports$1, "ValidationError", { enumerable: true, get: function() {
      return HttpErrors_1.ValidationError;
    } });
    __exportStar(requireWebhook(), exports$1);
    __exportStar(requireModels(), exports$1);
    var message_2 = requireMessage();
    Object.defineProperty(exports$1, "messageInRaw", { enumerable: true, get: function() {
      return message_2.messageInRaw;
    } });
    const REGIONS = [
      { region: "us", url: "https://api.us.svix.com" },
      { region: "eu", url: "https://api.eu.svix.com" },
      { region: "in", url: "https://api.in.svix.com" },
      { region: "ca", url: "https://api.ca.svix.com" },
      { region: "au", url: "https://api.au.svix.com" }
    ];
    class Svix {
      constructor(token, options = {}) {
        var _a2, _b, _c;
        const regionalUrl = (_a2 = REGIONS.find((x2) => x2.region === token.split(".")[1])) === null || _a2 === void 0 ? void 0 : _a2.url;
        const baseUrl2 = (_c = (_b = options.serverUrl) !== null && _b !== void 0 ? _b : regionalUrl) !== null && _c !== void 0 ? _c : "https://api.svix.com";
        if (options.retryScheduleInMs) {
          this.requestCtx = {
            baseUrl: baseUrl2,
            token,
            timeout: options.requestTimeout,
            retryScheduleInMs: options.retryScheduleInMs
          };
          return;
        }
        if (options.numRetries) {
          this.requestCtx = {
            baseUrl: baseUrl2,
            token,
            timeout: options.requestTimeout,
            numRetries: options.numRetries
          };
          return;
        }
        this.requestCtx = {
          baseUrl: baseUrl2,
          token,
          timeout: options.requestTimeout
        };
      }
      get application() {
        return new application_1.Application(this.requestCtx);
      }
      get authentication() {
        return new authentication_1.Authentication(this.requestCtx);
      }
      get backgroundTask() {
        return new backgroundTask_1.BackgroundTask(this.requestCtx);
      }
      get endpoint() {
        return new endpoint_1.Endpoint(this.requestCtx);
      }
      get environment() {
        return new environment_1.Environment(this.requestCtx);
      }
      get eventType() {
        return new eventType_1.EventType(this.requestCtx);
      }
      get health() {
        return new health_1.Health(this.requestCtx);
      }
      get ingest() {
        return new ingest_1.Ingest(this.requestCtx);
      }
      get integration() {
        return new integration_1.Integration(this.requestCtx);
      }
      get message() {
        return new message_1.Message(this.requestCtx);
      }
      get messageAttempt() {
        return new messageAttempt_1.MessageAttempt(this.requestCtx);
      }
      get operationalWebhook() {
        return new operationalWebhook_1.OperationalWebhook(this.requestCtx);
      }
      get statistics() {
        return new statistics_1.Statistics(this.requestCtx);
      }
      get operationalWebhookEndpoint() {
        return new operationalWebhookEndpoint_1.OperationalWebhookEndpoint(this.requestCtx);
      }
    }
    exports$1.Svix = Svix;
  })(dist$1);
  return dist$1;
}
var distExports = requireDist();
var version = "6.6.0";
function buildPaginationQuery(options) {
  const searchParams = new URLSearchParams();
  if (options.limit !== void 0) searchParams.set("limit", options.limit.toString());
  if ("after" in options && options.after !== void 0) searchParams.set("after", options.after);
  if ("before" in options && options.before !== void 0) searchParams.set("before", options.before);
  return searchParams.toString();
}
var ApiKeys = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    return await this.resend.post("/api-keys", payload, options);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/api-keys?${queryString}` : "/api-keys";
    return await this.resend.get(url);
  }
  async remove(id2) {
    return await this.resend.delete(`/api-keys/${id2}`);
  }
};
function parseAttachments(attachments) {
  return attachments?.map((attachment) => ({
    content: attachment.content,
    filename: attachment.filename,
    path: attachment.path,
    content_type: attachment.contentType,
    content_id: attachment.contentId
  }));
}
function parseEmailToApiOptions(email) {
  return {
    attachments: parseAttachments(email.attachments),
    bcc: email.bcc,
    cc: email.cc,
    from: email.from,
    headers: email.headers,
    html: email.html,
    reply_to: email.replyTo,
    scheduled_at: email.scheduledAt,
    subject: email.subject,
    tags: email.tags,
    text: email.text,
    to: email.to,
    template: email.template ? {
      id: email.template.id,
      variables: email.template.variables
    } : void 0,
    topic_id: email.topicId
  };
}
async function render(node2) {
  let render$12;
  try {
    ({ render: render$12 } = await Promise.resolve().then(() => index));
  } catch {
    throw new Error("Failed to render React component. Make sure to install `@react-email/render` or `@react-email/components`.");
  }
  return render$12(node2);
}
var Batch = class {
  constructor(resend) {
    this.resend = resend;
  }
  async send(payload, options) {
    return this.create(payload, options);
  }
  async create(payload, options) {
    const emails = [];
    for (const email of payload) {
      if (email.react) {
        email.html = await render(email.react);
        email.react = void 0;
      }
      emails.push(parseEmailToApiOptions(email));
    }
    return await this.resend.post("/emails/batch", emails, {
      ...options,
      headers: {
        "x-batch-validation": options?.batchValidation ?? "strict",
        ...options?.headers
      }
    });
  }
};
var Broadcasts = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    if (payload.react) payload.html = await render(payload.react);
    return await this.resend.post("/broadcasts", {
      name: payload.name,
      segment_id: payload.segmentId,
      audience_id: payload.audienceId,
      preview_text: payload.previewText,
      from: payload.from,
      html: payload.html,
      reply_to: payload.replyTo,
      subject: payload.subject,
      text: payload.text,
      topic_id: payload.topicId
    }, options);
  }
  async send(id2, payload) {
    return await this.resend.post(`/broadcasts/${id2}/send`, { scheduled_at: payload?.scheduledAt });
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/broadcasts?${queryString}` : "/broadcasts";
    return await this.resend.get(url);
  }
  async get(id2) {
    return await this.resend.get(`/broadcasts/${id2}`);
  }
  async remove(id2) {
    return await this.resend.delete(`/broadcasts/${id2}`);
  }
  async update(id2, payload) {
    if (payload.react) payload.html = await render(payload.react);
    return await this.resend.patch(`/broadcasts/${id2}`, {
      name: payload.name,
      segment_id: payload.segmentId,
      audience_id: payload.audienceId,
      from: payload.from,
      html: payload.html,
      text: payload.text,
      subject: payload.subject,
      reply_to: payload.replyTo,
      preview_text: payload.previewText,
      topic_id: payload.topicId
    });
  }
};
function parseContactPropertyFromApi(contactProperty) {
  return {
    id: contactProperty.id,
    key: contactProperty.key,
    createdAt: contactProperty.created_at,
    type: contactProperty.type,
    fallbackValue: contactProperty.fallback_value
  };
}
function parseContactPropertyToApiOptions(contactProperty) {
  if ("key" in contactProperty) return {
    key: contactProperty.key,
    type: contactProperty.type,
    fallback_value: contactProperty.fallbackValue
  };
  return { fallback_value: contactProperty.fallbackValue };
}
var ContactProperties = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(options) {
    const apiOptions = parseContactPropertyToApiOptions(options);
    return await this.resend.post("/contact-properties", apiOptions);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/contact-properties?${queryString}` : "/contact-properties";
    const response = await this.resend.get(url);
    if (response.data) return {
      data: {
        ...response.data,
        data: response.data.data.map((apiContactProperty) => parseContactPropertyFromApi(apiContactProperty))
      },
      headers: response.headers,
      error: null
    };
    return response;
  }
  async get(id2) {
    if (!id2) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    const response = await this.resend.get(`/contact-properties/${id2}`);
    if (response.data) return {
      data: {
        object: "contact_property",
        ...parseContactPropertyFromApi(response.data)
      },
      headers: response.headers,
      error: null
    };
    return response;
  }
  async update(payload) {
    if (!payload.id) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    const apiOptions = parseContactPropertyToApiOptions(payload);
    return await this.resend.patch(`/contact-properties/${payload.id}`, apiOptions);
  }
  async remove(id2) {
    if (!id2) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    return await this.resend.delete(`/contact-properties/${id2}`);
  }
};
var ContactSegments = class {
  constructor(resend) {
    this.resend = resend;
  }
  async list(options) {
    if (!options.contactId && !options.email) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` or `email` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    const identifier = options.email ? options.email : options.contactId;
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/contacts/${identifier}/segments?${queryString}` : `/contacts/${identifier}/segments`;
    return await this.resend.get(url);
  }
  async add(options) {
    if (!options.contactId && !options.email) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` or `email` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    const identifier = options.email ? options.email : options.contactId;
    return this.resend.post(`/contacts/${identifier}/segments/${options.segmentId}`);
  }
  async remove(options) {
    if (!options.contactId && !options.email) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` or `email` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    const identifier = options.email ? options.email : options.contactId;
    return this.resend.delete(`/contacts/${identifier}/segments/${options.segmentId}`);
  }
};
var ContactTopics = class {
  constructor(resend) {
    this.resend = resend;
  }
  async update(payload) {
    if (!payload.id && !payload.email) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` or `email` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    const identifier = payload.email ? payload.email : payload.id;
    return this.resend.patch(`/contacts/${identifier}/topics`, payload.topics);
  }
  async list(options) {
    if (!options.id && !options.email) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` or `email` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    const identifier = options.email ? options.email : options.id;
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/contacts/${identifier}/topics?${queryString}` : `/contacts/${identifier}/topics`;
    return this.resend.get(url);
  }
};
var Contacts = class {
  constructor(resend) {
    this.resend = resend;
    this.topics = new ContactTopics(this.resend);
    this.segments = new ContactSegments(this.resend);
  }
  async create(payload, options = {}) {
    if (!payload.audienceId) return await this.resend.post("/contacts", {
      unsubscribed: payload.unsubscribed,
      email: payload.email,
      first_name: payload.firstName,
      last_name: payload.lastName,
      properties: payload.properties
    }, options);
    return await this.resend.post(`/audiences/${payload.audienceId}/contacts`, {
      unsubscribed: payload.unsubscribed,
      email: payload.email,
      first_name: payload.firstName,
      last_name: payload.lastName,
      properties: payload.properties
    }, options);
  }
  async list(options = {}) {
    const segmentId = options.segmentId ?? options.audienceId;
    if (!segmentId) {
      const queryString$1 = buildPaginationQuery(options);
      const url$1 = queryString$1 ? `/contacts?${queryString$1}` : "/contacts";
      return await this.resend.get(url$1);
    }
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/segments/${segmentId}/contacts?${queryString}` : `/segments/${segmentId}/contacts`;
    return await this.resend.get(url);
  }
  async get(options) {
    if (typeof options === "string") return this.resend.get(`/contacts/${options}`);
    if (!options.id && !options.email) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` or `email` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    if (!options.audienceId) return this.resend.get(`/contacts/${options?.email ? options?.email : options?.id}`);
    return this.resend.get(`/audiences/${options.audienceId}/contacts/${options?.email ? options?.email : options?.id}`);
  }
  async update(options) {
    if (!options.id && !options.email) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` or `email` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    if (!options.audienceId) return await this.resend.patch(`/contacts/${options?.email ? options?.email : options?.id}`, {
      unsubscribed: options.unsubscribed,
      first_name: options.firstName,
      last_name: options.lastName,
      properties: options.properties
    });
    return await this.resend.patch(`/audiences/${options.audienceId}/contacts/${options?.email ? options?.email : options?.id}`, {
      unsubscribed: options.unsubscribed,
      first_name: options.firstName,
      last_name: options.lastName,
      properties: options.properties
    });
  }
  async remove(payload) {
    if (typeof payload === "string") return this.resend.delete(`/contacts/${payload}`);
    if (!payload.id && !payload.email) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` or `email` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    if (!payload.audienceId) return this.resend.delete(`/contacts/${payload?.email ? payload?.email : payload?.id}`);
    return this.resend.delete(`/audiences/${payload.audienceId}/contacts/${payload?.email ? payload?.email : payload?.id}`);
  }
};
function parseDomainToApiOptions(domain) {
  return {
    name: domain.name,
    region: domain.region,
    custom_return_path: domain.customReturnPath,
    capabilities: domain.capabilities,
    open_tracking: domain.openTracking,
    click_tracking: domain.clickTracking,
    tls: domain.tls
  };
}
var Domains = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    return await this.resend.post("/domains", parseDomainToApiOptions(payload), options);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/domains?${queryString}` : "/domains";
    return await this.resend.get(url);
  }
  async get(id2) {
    return await this.resend.get(`/domains/${id2}`);
  }
  async update(payload) {
    return await this.resend.patch(`/domains/${payload.id}`, {
      click_tracking: payload.clickTracking,
      open_tracking: payload.openTracking,
      tls: payload.tls,
      capabilities: payload.capabilities
    });
  }
  async remove(id2) {
    return await this.resend.delete(`/domains/${id2}`);
  }
  async verify(id2) {
    return await this.resend.post(`/domains/${id2}/verify`);
  }
};
var Attachments = class {
  constructor(resend) {
    this.resend = resend;
  }
  async get(options) {
    const { emailId, id: id2 } = options;
    return await this.resend.get(`/emails/${emailId}/attachments/${id2}`);
  }
  async list(options) {
    const { emailId } = options;
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/emails/${emailId}/attachments?${queryString}` : `/emails/${emailId}/attachments`;
    return await this.resend.get(url);
  }
};
var Attachments$1 = class {
  constructor(resend) {
    this.resend = resend;
  }
  async get(options) {
    const { emailId, id: id2 } = options;
    return await this.resend.get(`/emails/receiving/${emailId}/attachments/${id2}`);
  }
  async list(options) {
    const { emailId } = options;
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/emails/receiving/${emailId}/attachments?${queryString}` : `/emails/receiving/${emailId}/attachments`;
    return await this.resend.get(url);
  }
};
var Receiving = class {
  constructor(resend) {
    this.resend = resend;
    this.attachments = new Attachments$1(resend);
  }
  async get(id2) {
    return await this.resend.get(`/emails/receiving/${id2}`);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/emails/receiving?${queryString}` : "/emails/receiving";
    return await this.resend.get(url);
  }
};
var Emails = class {
  constructor(resend) {
    this.resend = resend;
    this.attachments = new Attachments(resend);
    this.receiving = new Receiving(resend);
  }
  async send(payload, options = {}) {
    return this.create(payload, options);
  }
  async create(payload, options = {}) {
    if (payload.react) payload.html = await render(payload.react);
    return await this.resend.post("/emails", parseEmailToApiOptions(payload), options);
  }
  async get(id2) {
    return await this.resend.get(`/emails/${id2}`);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/emails?${queryString}` : "/emails";
    return await this.resend.get(url);
  }
  async update(payload) {
    return await this.resend.patch(`/emails/${payload.id}`, { scheduled_at: payload.scheduledAt });
  }
  async cancel(id2) {
    return await this.resend.post(`/emails/${id2}/cancel`);
  }
};
var Segments = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    return await this.resend.post("/segments", payload, options);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/segments?${queryString}` : "/segments";
    return await this.resend.get(url);
  }
  async get(id2) {
    return await this.resend.get(`/segments/${id2}`);
  }
  async remove(id2) {
    return await this.resend.delete(`/segments/${id2}`);
  }
};
function getPaginationQueryProperties(options = {}) {
  const query = new URLSearchParams();
  if (options.before) query.set("before", options.before);
  if (options.after) query.set("after", options.after);
  if (options.limit) query.set("limit", options.limit.toString());
  return query.size > 0 ? `?${query.toString()}` : "";
}
function parseVariables(variables) {
  return variables?.map((variable) => ({
    key: variable.key,
    type: variable.type,
    fallback_value: variable.fallbackValue
  }));
}
function parseTemplateToApiOptions(template) {
  return {
    name: "name" in template ? template.name : void 0,
    subject: template.subject,
    html: template.html,
    text: template.text,
    alias: template.alias,
    from: template.from,
    reply_to: template.replyTo,
    variables: parseVariables(template.variables)
  };
}
var ChainableTemplateResult = class {
  constructor(promise, publishFn) {
    this.promise = promise;
    this.publishFn = publishFn;
  }
  then(onfulfilled, onrejected) {
    return this.promise.then(onfulfilled, onrejected);
  }
  async publish() {
    const { data, error } = await this.promise;
    if (error) return {
      data: null,
      headers: null,
      error
    };
    return this.publishFn(data.id);
  }
};
var Templates = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(payload) {
    return new ChainableTemplateResult(this.performCreate(payload), this.publish.bind(this));
  }
  async performCreate(payload) {
    if (payload.react) {
      if (!this.renderAsync) try {
        const { renderAsync } = await Promise.resolve().then(() => index);
        this.renderAsync = renderAsync;
      } catch {
        throw new Error("Failed to render React component. Make sure to install `@react-email/render`");
      }
      payload.html = await this.renderAsync(payload.react);
    }
    return this.resend.post("/templates", parseTemplateToApiOptions(payload));
  }
  async remove(identifier) {
    return await this.resend.delete(`/templates/${identifier}`);
  }
  async get(identifier) {
    return await this.resend.get(`/templates/${identifier}`);
  }
  async list(options = {}) {
    return this.resend.get(`/templates${getPaginationQueryProperties(options)}`);
  }
  duplicate(identifier) {
    return new ChainableTemplateResult(this.resend.post(`/templates/${identifier}/duplicate`), this.publish.bind(this));
  }
  async publish(identifier) {
    return await this.resend.post(`/templates/${identifier}/publish`);
  }
  async update(identifier, payload) {
    return await this.resend.patch(`/templates/${identifier}`, parseTemplateToApiOptions(payload));
  }
};
var Topics = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload) {
    const { defaultSubscription, ...body } = payload;
    return await this.resend.post("/topics", {
      ...body,
      default_subscription: defaultSubscription
    });
  }
  async list() {
    return await this.resend.get("/topics");
  }
  async get(id2) {
    if (!id2) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    return await this.resend.get(`/topics/${id2}`);
  }
  async update(payload) {
    if (!payload.id) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    return await this.resend.patch(`/topics/${payload.id}`, payload);
  }
  async remove(id2) {
    if (!id2) return {
      data: null,
      headers: null,
      error: {
        message: "Missing `id` field.",
        statusCode: null,
        name: "missing_required_field"
      }
    };
    return await this.resend.delete(`/topics/${id2}`);
  }
};
var Webhooks = class {
  constructor(resend) {
    this.resend = resend;
  }
  async create(payload, options = {}) {
    return await this.resend.post("/webhooks", payload, options);
  }
  async get(id2) {
    return await this.resend.get(`/webhooks/${id2}`);
  }
  async list(options = {}) {
    const queryString = buildPaginationQuery(options);
    const url = queryString ? `/webhooks?${queryString}` : "/webhooks";
    return await this.resend.get(url);
  }
  async update(id2, payload) {
    return await this.resend.patch(`/webhooks/${id2}`, payload);
  }
  async remove(id2) {
    return await this.resend.delete(`/webhooks/${id2}`);
  }
  verify(payload) {
    return new distExports.Webhook(payload.webhookSecret).verify(payload.payload, {
      "svix-id": payload.headers.id,
      "svix-timestamp": payload.headers.timestamp,
      "svix-signature": payload.headers.signature
    });
  }
};
const defaultBaseUrl = "https://api.resend.com";
const defaultUserAgent = `resend-node:${version}`;
const baseUrl$2 = typeof process !== "undefined" && process.env ? process.env.RESEND_BASE_URL || defaultBaseUrl : defaultBaseUrl;
const userAgent = typeof process !== "undefined" && process.env ? process.env.RESEND_USER_AGENT || defaultUserAgent : defaultUserAgent;
var Resend = class {
  constructor(key) {
    this.key = key;
    this.apiKeys = new ApiKeys(this);
    this.segments = new Segments(this);
    this.audiences = this.segments;
    this.batch = new Batch(this);
    this.broadcasts = new Broadcasts(this);
    this.contacts = new Contacts(this);
    this.contactProperties = new ContactProperties(this);
    this.domains = new Domains(this);
    this.emails = new Emails(this);
    this.webhooks = new Webhooks(this);
    this.templates = new Templates(this);
    this.topics = new Topics(this);
    if (!key) {
      if (typeof process !== "undefined" && process.env) this.key = process.env.RESEND_API_KEY;
      if (!this.key) throw new Error('Missing API key. Pass it to the constructor `new Resend("re_123")`');
    }
    this.headers = new Headers({
      Authorization: `Bearer ${this.key}`,
      "User-Agent": userAgent,
      "Content-Type": "application/json"
    });
  }
  async fetchRequest(path, options = {}) {
    try {
      const response = await fetch(`${baseUrl$2}${path}`, options);
      if (!response.ok) try {
        const rawError = await response.text();
        return {
          data: null,
          error: JSON.parse(rawError),
          headers: Object.fromEntries(response.headers.entries())
        };
      } catch (err) {
        if (err instanceof SyntaxError) return {
          data: null,
          error: {
            name: "application_error",
            statusCode: response.status,
            message: "Internal server error. We are unable to process your request right now, please try again later."
          },
          headers: Object.fromEntries(response.headers.entries())
        };
        const error = {
          message: response.statusText,
          statusCode: response.status,
          name: "application_error"
        };
        if (err instanceof Error) return {
          data: null,
          error: {
            ...error,
            message: err.message
          },
          headers: Object.fromEntries(response.headers.entries())
        };
        return {
          data: null,
          error,
          headers: Object.fromEntries(response.headers.entries())
        };
      }
      return {
        data: await response.json(),
        error: null,
        headers: Object.fromEntries(response.headers.entries())
      };
    } catch {
      return {
        data: null,
        error: {
          name: "application_error",
          statusCode: null,
          message: "Unable to fetch data. The request could not be resolved."
        },
        headers: null
      };
    }
  }
  async post(path, entity, options = {}) {
    const headers = new Headers(this.headers);
    if (options.headers) for (const [key, value] of new Headers(options.headers).entries()) headers.set(key, value);
    if (options.idempotencyKey) headers.set("Idempotency-Key", options.idempotencyKey);
    const requestOptions = {
      method: "POST",
      body: JSON.stringify(entity),
      ...options,
      headers
    };
    return this.fetchRequest(path, requestOptions);
  }
  async get(path, options = {}) {
    const headers = new Headers(this.headers);
    if (options.headers) for (const [key, value] of new Headers(options.headers).entries()) headers.set(key, value);
    const requestOptions = {
      method: "GET",
      ...options,
      headers
    };
    return this.fetchRequest(path, requestOptions);
  }
  async put(path, entity, options = {}) {
    const headers = new Headers(this.headers);
    if (options.headers) for (const [key, value] of new Headers(options.headers).entries()) headers.set(key, value);
    const requestOptions = {
      method: "PUT",
      body: JSON.stringify(entity),
      ...options,
      headers
    };
    return this.fetchRequest(path, requestOptions);
  }
  async patch(path, entity, options = {}) {
    const headers = new Headers(this.headers);
    if (options.headers) for (const [key, value] of new Headers(options.headers).entries()) headers.set(key, value);
    const requestOptions = {
      method: "PATCH",
      body: JSON.stringify(entity),
      ...options,
      headers
    };
    return this.fetchRequest(path, requestOptions);
  }
  async delete(path, query) {
    const requestOptions = {
      method: "DELETE",
      body: JSON.stringify(query),
      headers: this.headers
    };
    return this.fetchRequest(path, requestOptions);
  }
};
const baseUrl$1 = process.env.VITE_SITE_URL || "https://renoz.energy";
const styles$3 = {
  body: {
    backgroundColor: "#ffffff",
    fontFamily: "Inter, system-ui, -apple-system, sans-serif",
    color: "#1A1A1A",
    WebkitFontSmoothing: "antialiased"
  },
  container: {
    margin: "0 auto",
    padding: "32px",
    maxWidth: "600px",
    borderRadius: "8px",
    border: "1px solid #E5E5E5"
  },
  logoSection: {
    marginBottom: "32px",
    textAlign: "center"
  },
  hr: {
    borderColor: "#E5E5E5",
    marginTop: "32px",
    marginBottom: "32px"
  },
  footer: {
    textAlign: "center",
    fontSize: "12px",
    color: "#666666"
  },
  footerText: {
    marginBottom: "16px"
  },
  footerLinks: {
    textAlign: "center"
  },
  footerLink: {
    color: "#00B140",
    textDecoration: "underline",
    textUnderlineOffset: "4px",
    marginLeft: "8px",
    marginRight: "8px"
  }
};
const EmailLayout = ({ preview, children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Html, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Head, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Preview, { children: preview }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Body, { style: styles$3.body, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { style: styles$3.container, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { style: styles$3.logoSection, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Img,
        {
          src: `${baseUrl$1}/images/optimized/logo-renoz.webp`,
          width: "180",
          height: "auto",
          alt: "RENOZ Energy",
          style: { margin: "0 auto" }
        }
      ) }),
      children,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Hr$1, { style: styles$3.hr }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles$3.footer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: styles$3.footerText, children: [
          "© ",
          (/* @__PURE__ */ new Date()).getFullYear(),
          " RENOZ Energy. All rights reserved.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          "Unit 4, 8 Murphy Street, O'Connor WA 6163"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles$3.footerLinks, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: `${baseUrl$1}`, style: styles$3.footerLink, children: "Website" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: `${baseUrl$1}/contact`, style: styles$3.footerLink, children: "Contact Support" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: `${baseUrl$1}/privacy`, style: styles$3.footerLink, children: "Privacy Policy" })
        ] })
      ] })
    ] }) })
  ] });
};
const baseUrl = process.env.VITE_SITE_URL || "https://renoz.energy";
const styles$2 = {
  // Main Container
  mainSection: {
    maxWidth: "600px",
    backgroundColor: "#ffffff",
    border: "1px solid #e5e7eb",
    borderRadius: "8px",
    overflow: "hidden",
    fontFamily: "Inter, Helvetica, Arial, sans-serif",
    margin: "0 auto"
  },
  // Hero Section
  heroSection: {
    backgroundColor: "#166534",
    // Dark green
    padding: "40px 32px",
    textAlign: "center"
  },
  heroHeading: {
    margin: "0 0 16px 0",
    fontSize: "28px",
    fontWeight: "bold",
    color: "#ffffff",
    lineHeight: "1.2"
  },
  heroText: {
    margin: "0",
    fontSize: "16px",
    color: "rgba(255, 255, 255, 0.9)",
    lineHeight: "1.5"
  },
  // Status Card (Overlapping hero slightly in concept, but kept simple here)
  statusSection: {
    padding: "32px 24px",
    backgroundColor: "#ffffff",
    borderBottom: "1px solid #e5e7eb"
  },
  statusLabel: {
    margin: "0 0 8px 0",
    fontSize: "12px",
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: "0.1em",
    color: "#166534",
    textAlign: "center"
  },
  warrantyId: {
    margin: "0 auto",
    fontSize: "24px",
    fontFamily: "monospace",
    fontWeight: "bold",
    color: "#111827",
    backgroundColor: "#f3f4f6",
    padding: "8px 16px",
    borderRadius: "4px",
    display: "inline-block"
  },
  centerContainer: {
    textAlign: "center"
  },
  // Content
  contentSection: {
    padding: "32px 24px"
  },
  sectionTitle: {
    margin: "0 0 20px 0",
    fontSize: "16px",
    fontWeight: "bold",
    color: "#111827",
    borderBottom: "2px solid #22c55e",
    paddingBottom: "8px"
  },
  // Data Rows
  row: {
    marginBottom: "12px",
    borderBottom: "1px solid #f3f4f6",
    paddingBottom: "12px"
  },
  labelCol: {
    width: "40%"
  },
  valueCol: {
    width: "60%",
    textAlign: "right"
  },
  labelText: {
    margin: "0",
    fontSize: "14px",
    color: "#6b7280",
    fontWeight: "500"
  },
  valueText: {
    margin: "0",
    fontSize: "14px",
    color: "#111827",
    fontWeight: "600"
  },
  // CTA Box
  ctaBox: {
    marginTop: "32px",
    backgroundColor: "#f9fafb",
    borderRadius: "8px",
    padding: "24px",
    textAlign: "center",
    border: "1px solid #e5e7eb"
  },
  ctaHeading: {
    margin: "0 0 12px 0",
    fontSize: "16px",
    fontWeight: "bold",
    color: "#111827"
  },
  ctaText: {
    margin: "0 0 20px 0",
    fontSize: "14px",
    color: "#4b5563",
    lineHeight: "1.5"
  },
  button: {
    backgroundColor: "#166534",
    color: "#ffffff",
    fontWeight: "bold",
    fontSize: "14px",
    padding: "12px 24px",
    borderRadius: "9999px",
    textDecoration: "none",
    display: "inline-block"
  },
  // Footer
  footerSection: {
    backgroundColor: "#f3f4f6",
    padding: "24px",
    textAlign: "center",
    borderTop: "1px solid #e5e7eb"
  },
  footerText: {
    margin: "0",
    fontSize: "12px",
    color: "#6b7280",
    lineHeight: "1.5"
  },
  link: {
    color: "#166534",
    textDecoration: "underline",
    fontWeight: "600"
  }
};
const DataRow$2 = ({
  label,
  value
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { style: styles$2.row, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { style: styles$2.labelCol, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles$2.labelText, children: label }) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { style: styles$2.valueCol, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles$2.valueText, children: value || "—" }) })
] });
const WarrantyHomeownerConfirmationEmail = ({
  warrantyId,
  homeownerName,
  installerName,
  installerCompany,
  batteryModel,
  serialNumbers,
  installDate
}) => {
  const batteryCount = serialNumbers.filter((s) => s.trim()).length;
  const nominalCapacity = batteryCount * 5.12;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EmailLayout, { preview: `Welcome to the Family - Warranty ${warrantyId}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles$2.mainSection, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles$2.heroSection, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { style: styles$2.heroHeading, children: "Welcome to the Family." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: styles$2.heroText, children: [
        "Hi ",
        homeownerName,
        ", your new RENOZ energy storage system is officially protected."
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { style: styles$2.statusSection, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { style: styles$2.centerContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles$2.statusLabel, children: "Warranty Active" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles$2.warrantyId, children: warrantyId })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles$2.contentSection, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { as: "h3", style: styles$2.sectionTitle, children: "System Snapshot" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow$2,
        {
          label: "System Capacity",
          value: `${nominalCapacity.toFixed(1)} kWh`
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow$2,
        {
          label: "Battery Model",
          value: `${batteryModel} (${batteryCount}x)`
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow$2,
        {
          label: "Installed By",
          value: installerCompany || installerName
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow$2, { label: "Installation Date", value: installDate }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles$2.ctaBox, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { as: "h4", style: styles$2.ctaHeading, children: "Maximize Your System" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles$2.ctaText, children: "Access user manuals, safety guides, and tips for maintaining your battery health in our resource center." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { href: `${baseUrl}/resources`, style: styles$2.button, children: "View Owner Resources" })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { style: styles$2.footerSection, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: styles$2.footerText, children: [
      "Please keep this email for your records. If you ever need support, just reply to this email or call us at",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: "tel:1800736693", style: styles$2.link, children: "1800 736 693" }),
      "."
    ] }) })
  ] }) });
};
const styles$1 = {
  // Main Container
  mainSection: {
    maxWidth: "600px",
    backgroundColor: "#ffffff",
    border: "1px solid #e5e7eb",
    borderRadius: "8px",
    overflow: "hidden",
    fontFamily: "Inter, Helvetica, Arial, sans-serif",
    margin: "0 auto"
  },
  // Header
  headerSection: {
    padding: "32px 24px",
    backgroundColor: "#f9fafb",
    borderBottom: "1px solid #e5e7eb",
    textAlign: "center"
  },
  successIcon: {
    fontSize: "48px",
    marginBottom: "16px",
    display: "block"
  },
  mainHeading: {
    margin: "0 0 12px 0",
    fontSize: "24px",
    fontWeight: "bold",
    color: "#111827"
  },
  introText: {
    margin: "0",
    fontSize: "16px",
    color: "#6b7280",
    lineHeight: "1.5"
  },
  // Reference Card
  referenceCard: {
    margin: "24px",
    padding: "24px",
    backgroundColor: "#f0fdf4",
    // Light green bg
    border: "1px solid #bbf7d0",
    borderRadius: "8px",
    textAlign: "center"
  },
  referenceLabel: {
    margin: "0 0 8px 0",
    fontSize: "13px",
    fontWeight: "600",
    textTransform: "uppercase",
    letterSpacing: "0.05em",
    color: "#15803d"
  },
  referenceId: {
    margin: "0",
    fontFamily: "monospace",
    fontSize: "24px",
    fontWeight: "bold",
    letterSpacing: "0.05em",
    color: "#166534"
  },
  // Sections
  section: {
    padding: "0 24px 24px 24px"
  },
  sectionHeading: {
    margin: "0 0 16px 0",
    fontSize: "14px",
    fontWeight: "bold",
    color: "#111827",
    textTransform: "uppercase",
    letterSpacing: "0.025em",
    borderBottom: "2px solid #6366f1",
    // Indigo accent
    paddingBottom: "8px"
  },
  // Data Rows
  row: {
    marginBottom: "8px"
  },
  labelCol: {
    width: "40%",
    verticalAlign: "top"
  },
  valueCol: {
    width: "60%",
    verticalAlign: "top"
  },
  labelText: {
    margin: "0",
    fontSize: "13px",
    color: "#6b7280",
    fontWeight: "500"
  },
  valueText: {
    margin: "0",
    fontSize: "13px",
    color: "#111827",
    fontWeight: "600"
  },
  // Next Steps
  stepsSection: {
    margin: "0 24px 24px 24px",
    padding: "24px",
    backgroundColor: "#f9fafb",
    border: "1px dashed #d1d5db",
    borderRadius: "8px"
  },
  stepsHeading: {
    margin: "0 0 16px 0",
    fontSize: "14px",
    fontWeight: "bold",
    color: "#374151",
    textTransform: "uppercase"
  },
  stepRow: {
    marginBottom: "12px"
  },
  stepIcon: {
    width: "24px",
    fontSize: "18px",
    verticalAlign: "top"
  },
  stepText: {
    margin: "0",
    fontSize: "13px",
    color: "#4b5563",
    lineHeight: "1.4"
  },
  // Footer
  footerSection: {
    backgroundColor: "#f3f4f6",
    padding: "24px",
    borderTop: "1px solid #e5e7eb",
    textAlign: "center"
  },
  footerText: {
    margin: "0",
    fontSize: "12px",
    color: "#6b7280"
  },
  link: {
    color: "#059669",
    fontWeight: "600",
    textDecoration: "none"
  }
};
const DataRow$1 = ({
  label,
  value
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { style: styles$1.row, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { style: styles$1.labelCol, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles$1.labelText, children: label }) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { style: styles$1.valueCol, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles$1.valueText, children: value || "—" }) })
] });
const WarrantyInstallerConfirmationEmail = ({
  warrantyId,
  installerName,
  installerEmail,
  installerPhone,
  companyName,
  batteryModel,
  serialNumbers,
  installDate
}) => {
  const batteryCount = serialNumbers.filter((s) => s.trim()).length;
  const nominalCapacity = batteryCount * 5.12;
  const usableCapacity = nominalCapacity * 0.9;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EmailLayout, { preview: `Registration Received - ${warrantyId}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles$1.mainSection, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles$1.headerSection, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles$1.successIcon, children: "✅" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { style: styles$1.mainHeading, children: "Registration Received" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: styles$1.introText, children: [
        "Thanks, ",
        installerName,
        ". We've received your submission."
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles$1.referenceCard, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles$1.referenceLabel, children: "Warranty Reference ID" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles$1.referenceId, children: warrantyId })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles$1.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { as: "h3", style: styles$1.sectionHeading, children: "⚡ System Configuration" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow$1, { label: "Battery Model", value: batteryModel }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow$1,
        {
          label: "Total Capacity",
          value: `${nominalCapacity.toFixed(2)} kWh (${usableCapacity.toFixed(2)} kWh usable)`
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow$1, { label: "Battery Count", value: `${batteryCount}x Units` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow$1, { label: "Install Date", value: installDate })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles$1.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Heading,
        {
          as: "h3",
          style: { ...styles$1.sectionHeading, borderColor: "#10b981" },
          children: "👷 Installer Record"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow$1, { label: "Name", value: installerName }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow$1, { label: "Company", value: companyName }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow$1, { label: "Email", value: installerEmail }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow$1, { label: "Phone", value: installerPhone })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles$1.stepsSection, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { as: "h4", style: styles$1.stepsHeading, children: "What happens next?" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { style: styles$1.stepRow, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { style: styles$1.stepIcon, children: "📝" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: styles$1.stepText, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Review:" }),
          " Our engineering team verifies the installation details (24-48 hrs)."
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { style: styles$1.stepRow, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { style: styles$1.stepIcon, children: "✨" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: styles$1.stepText, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Activation:" }),
          " Once approved, the 10-year warranty is officially active."
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { style: styles$1.stepIcon, children: "📧" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: styles$1.stepText, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Certificate:" }),
          " We'll email the official warranty certificate to you."
        ] }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { style: styles$1.footerSection, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: styles$1.footerText, children: [
      "Questions? Contact Support at",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: "tel:1800736693", style: styles$1.link, children: "1800 736 693" })
    ] }) })
  ] }) });
};
const styles = {
  // Main Container
  mainSection: {
    maxWidth: "600px",
    backgroundColor: "#ffffff",
    border: "1px solid #e5e7eb",
    borderRadius: "8px",
    overflow: "hidden",
    fontFamily: "Inter, Helvetica, Arial, sans-serif",
    margin: "0 auto"
  },
  // Header
  headerSection: {
    padding: "24px 24px 16px",
    backgroundColor: "#f9fafb",
    borderBottom: "1px solid #e5e7eb"
  },
  headerTitle: {
    margin: "0",
    fontSize: "18px",
    fontWeight: "bold",
    color: "#111827"
  },
  idBadge: {
    backgroundColor: "#e5e7eb",
    color: "#374151",
    fontSize: "12px",
    fontWeight: "600",
    padding: "4px 8px",
    borderRadius: "4px",
    marginLeft: "12px",
    fontFamily: "monospace",
    display: "inline-block"
  },
  // Content Sections
  contentSection: {
    padding: "20px 24px 8px"
  },
  sectionTitle: {
    margin: "0 0 16px 0",
    fontSize: "14px",
    fontWeight: "bold",
    color: "#111827",
    textTransform: "uppercase",
    letterSpacing: "0.025em",
    borderBottom: "2px solid #6366f1",
    // Default accent
    paddingBottom: "8px"
  },
  // Data Rows
  row: {
    marginBottom: "8px"
  },
  labelCol: {
    width: "40%",
    verticalAlign: "top"
  },
  valueCol: {
    width: "60%",
    verticalAlign: "top"
  },
  labelText: {
    margin: "0",
    fontSize: "13px",
    color: "#6b7280",
    fontWeight: "500"
  },
  valueText: {
    margin: "0",
    fontSize: "13px",
    color: "#111827",
    fontWeight: "600"
  },
  link: {
    color: "#059669",
    textDecoration: "underline"
  },
  // Notes
  notesContainer: {
    backgroundColor: "#f9fafb",
    border: "1px solid #e5e7eb",
    borderRadius: "6px",
    padding: "16px",
    marginTop: "8px"
  },
  notesText: {
    margin: "0",
    fontSize: "13px",
    color: "#374151",
    lineHeight: "1.5"
  },
  // Storage Box
  storageContainer: {
    backgroundColor: "#f8fafc",
    border: "1px solid #e2e8f0",
    borderRadius: "6px",
    padding: "16px",
    marginTop: "16px"
  },
  storageText: {
    margin: "0 0 8px 0",
    fontSize: "13px",
    color: "#1e293b"
  },
  storageValue: {
    fontFamily: "monospace",
    color: "#334155",
    backgroundColor: "#e2e8f0",
    padding: "2px 6px",
    borderRadius: "4px",
    fontSize: "12px"
  },
  storageHint: {
    margin: "8px 0 0 0",
    fontSize: "11px",
    color: "#64748b",
    fontStyle: "italic"
  },
  // Footer
  footerSection: {
    backgroundColor: "#f3f4f6",
    padding: "24px",
    borderTop: "1px solid #e5e7eb",
    marginTop: "24px"
  },
  footerText: {
    margin: "0 0 8px 0",
    fontSize: "11px",
    color: "#6b7280",
    lineHeight: "1.5"
  }
};
const DataRow = ({
  label,
  value
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { style: styles.row, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { style: styles.labelCol, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles.labelText, children: label }) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { style: styles.valueCol, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles.valueText, children: value || "—" }) })
] });
const WarrantySupportEmail = ({
  payload
}) => {
  const p = payload || {};
  const batteryCount = p.system?.serials?.length || 0;
  const formatDate = (dateString) => {
    if (!dateString) return "—";
    return new Date(dateString).toLocaleDateString("en-AU", {
      year: "numeric",
      month: "long",
      day: "numeric"
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EmailLayout, { preview: `Warranty: ${p.warrantyId} - ${p.customer?.name}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles.mainSection, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { style: styles.headerSection, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: styles.headerTitle, children: [
      "🔋 RENOZ Warranty Registration",
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: styles.idBadge, children: [
        "ID: ",
        p.warrantyId
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles.contentSection, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { as: "h3", style: styles.sectionTitle, children: "👷 Installer Details" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow,
        {
          label: "Technician Name",
          value: p.installer?.technicianName
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow, { label: "Company", value: p.installer?.company }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow, { label: "Electrical Licence", value: p.installer?.licence }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow,
        {
          label: "Email",
          value: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: `mailto:${p.installer?.email}`, style: styles.link, children: p.installer?.email })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow, { label: "Phone", value: p.installer?.phone })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles.contentSection, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Heading,
        {
          as: "h3",
          style: { ...styles.sectionTitle, borderColor: "#10b981" },
          children: "🏠 Customer & Installation Site"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow, { label: "Customer Name", value: p.customer?.name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow,
        {
          label: "Customer Email",
          value: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: `mailto:${p.customer?.email}`, style: styles.link, children: p.customer?.email })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow, { label: "Customer Phone", value: p.customer?.phone }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow,
        {
          label: "Installation Address",
          value: p.customer?.address && `${p.customer.address.street}, ${p.customer.address.suburb}, ${p.customer.address.state} ${p.customer.address.postcode}`
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles.contentSection, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Heading,
        {
          as: "h3",
          style: { ...styles.sectionTitle, borderColor: "#6366f1" },
          children: "⚡ Battery System Configuration"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow, { label: "Battery Model", value: p.system?.model }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow, { label: "Battery Count", value: `${batteryCount} batteries` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow, { label: "System Capacity", value: p.system?.capacity }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow,
        {
          label: "Power Type",
          value: p.system?.phases ? `${p.system.phases} Phase` : "—"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DataRow, { label: "Grid Connection", value: p.system?.gridStatus }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow,
        {
          label: "PV System Connected",
          value: p.system?.pvSystem ? "Yes" : "No"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow,
        {
          label: "Backup Generator",
          value: p.system?.backupGenset ? "Yes" : "No"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow,
        {
          label: "Inverter",
          value: `${p.system?.inverter?.brand || ""} ${p.system?.inverter?.model || ""}`.trim() || "Not Specified"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles.contentSection, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Heading,
        {
          as: "h3",
          style: { ...styles.sectionTitle, borderColor: "#f59e0b" },
          children: "📅 Installation Details"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow,
        {
          label: "Installation Date",
          value: formatDate(p.system?.installDate)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataRow,
        {
          label: "Commissioning Date",
          value: formatDate(p.system?.commissioningDate)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { style: styles.row, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { style: styles.labelCol, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles.labelText, children: "Serial Numbers" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { style: styles.valueCol, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Text,
          {
            style: {
              ...styles.valueText,
              fontFamily: "monospace",
              fontSize: "11px",
              lineHeight: "1.4"
            },
            children: p.system?.serials?.join(", ")
          }
        ) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles.contentSection, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Heading,
        {
          as: "h3",
          style: { ...styles.sectionTitle, borderColor: "#6b7280" },
          children: "📝 Additional Information"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { style: styles.notesContainer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: styles.notesText, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Installation Notes:" }),
          " ",
          p.installationNotes || "None provided."
        ] }),
        p.retailer && /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: { ...styles.notesText, marginTop: "4px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Purchased From:" }),
          " ",
          p.retailer
        ] }),
        p.purchaseDate && /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: { ...styles.notesText, marginTop: "4px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Purchase Date:" }),
          " ",
          formatDate(p.purchaseDate)
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles.contentSection, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Heading,
        {
          as: "h3",
          style: { ...styles.sectionTitle, borderColor: "#3b82f6" },
          children: "📁 File Storage Location"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { style: styles.storageContainer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: styles.storageText, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Supabase Bucket:" }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: styles.storageValue, children: "warranty-uploads" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: { ...styles.storageText, marginBottom: 0 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Folder Path:" }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: styles.storageValue, children: [
            "warranty-files/",
            p.warrantyId
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { style: styles.storageHint, children: "💡 All files for this warranty are organized in the above folder for easy access and management." })
      ] }),
      p.thumbnails && p.thumbnails.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { style: { marginTop: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Row, { children: p.thumbnails.map((thumb, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        Column,
        {
          style: { paddingRight: "8px", width: "60px" },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: thumb.dataUrl, target: "_blank", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Img,
            {
              src: thumb.dataUrl,
              style: {
                width: "50px",
                height: "50px",
                objectFit: "cover",
                borderRadius: "4px",
                border: "1px solid #ddd"
              }
            }
          ) })
        },
        i
      )) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { style: styles.footerSection, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: styles.footerText, children: [
        "📧 ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Email Recipients:" }),
        " Support team, installer, and homeowner (if applicable) have all received copies of this warranty registration."
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: styles.footerText, children: [
        "🔍 For warranty terms and your Australian Consumer Law rights, visit",
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: "https://renoz.energy/resources", style: styles.link, children: "renoz.energy/resources" }),
        "."
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: { ...styles.footerText, marginBottom: 0 }, children: [
        "🛠️ ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "For Support Team:" }),
        " Access files via direct links above or through the Supabase Storage dashboard."
      ] })
    ] })
  ] }) });
};
const submissionsCache = /* @__PURE__ */ new Map();
const submitWarrantySchema = objectType({
  warrantyId: stringType(),
  submissionId: stringType().optional(),
  // For deduplication
  turnstileToken: stringType(),
  // Installer
  installerName: stringType(),
  installerEmail: stringType(),
  installerPhone: stringType(),
  companyName: stringType().optional(),
  electricalLicence: stringType().optional(),
  // Installation Address
  installStreet: stringType(),
  installSuburb: stringType(),
  installPostcode: stringType(),
  // Homeowner (optional)
  onBehalfOfHomeowner: booleanType(),
  homeownerName: stringType().optional(),
  homeownerEmail: stringType().optional(),
  homeownerPhone: stringType().optional(),
  homeownerAddress: stringType().optional(),
  // System
  batteryModel: stringType(),
  serialNumbers: arrayType(stringType()),
  phases: stringType(),
  gridStatus: stringType(),
  pvSystem: booleanType(),
  backupGenset: booleanType(),
  inverterBrand: stringType().optional(),
  inverterModel: stringType().optional(),
  inverterSerial: stringType().optional(),
  // Dates
  installDate: stringType(),
  // ISO date string
  commissioningDate: stringType(),
  // ISO date string
  // Purchase Info
  retailer: stringType().optional(),
  purchaseDate: stringType().optional(),
  // ISO date string
  // Notes
  installationNotes: stringType().optional(),
  // Files
  evidenceFiles: arrayType(objectType({
    url: stringType(),
    name: stringType(),
    type: stringType()
  })),
  // Declarations
  installationDeclaration: booleanType(),
  marketingPermission: booleanType()
});
const submitWarranty_createServerFn_handler = createServerRpc("e668dc8b9b007de076ba6b2b95484a4584a4c72e8cf4a28d131c8736c7d552a7", (opts, signal) => submitWarranty.__executeServer(opts, signal));
const submitWarranty = createServerFn({
  method: "POST"
}).inputValidator(submitWarrantySchema).handler(submitWarranty_createServerFn_handler, async ({
  data
}) => {
  const {
    warrantyId,
    turnstileToken,
    installerName,
    installerEmail,
    installerPhone,
    companyName,
    electricalLicence,
    installStreet,
    installSuburb,
    installPostcode,
    onBehalfOfHomeowner,
    homeownerName,
    homeownerEmail,
    homeownerPhone,
    homeownerAddress,
    batteryModel,
    serialNumbers,
    phases,
    gridStatus,
    pvSystem,
    backupGenset,
    inverterBrand,
    inverterModel,
    inverterSerial,
    installDate,
    commissioningDate,
    retailer,
    purchaseDate,
    installationNotes,
    evidenceFiles,
    installationDeclaration,
    marketingPermission
  } = data;
  if (evidenceFiles.length > 20) {
    return {
      success: false,
      error: "Too many files uploaded (maximum 20)"
    };
  }
  const totalFileSize = evidenceFiles.reduce((total, file) => {
    const base64Size = file.url ? file.url.length * 0.75 : 0;
    return total + base64Size;
  }, 0);
  if (totalFileSize > 100 * 1024 * 1024) {
    return {
      success: false,
      error: "Total file size too large (maximum 100MB)"
    };
  }
  const sanitizeText = (text) => {
    if (!text) return text;
    return text.replace(/[<>]/g, "").replace(/javascript:/gi, "").replace(/on\w+=/gi, "").trim();
  };
  const sanitizedData = {
    installerName: sanitizeText(installerName),
    installerEmail: installerEmail?.toLowerCase().trim(),
    installerPhone: sanitizeText(installerPhone),
    companyName: sanitizeText(companyName),
    electricalLicence: sanitizeText(electricalLicence),
    installStreet: sanitizeText(installStreet),
    installSuburb: sanitizeText(installSuburb),
    installPostcode,
    homeownerName: sanitizeText(homeownerName),
    homeownerEmail: homeownerEmail?.toLowerCase().trim(),
    homeownerPhone: sanitizeText(homeownerPhone),
    homeownerAddress: sanitizeText(homeownerAddress),
    serialNumbers: serialNumbers.map((s) => sanitizeText(s) || ""),
    inverterBrand: sanitizeText(inverterBrand),
    inverterModel: sanitizeText(inverterModel),
    inverterSerial: sanitizeText(inverterSerial),
    retailer: sanitizeText(retailer),
    installationNotes: sanitizeText(installationNotes)
  };
  if (!turnstileToken) {
    return {
      success: false,
      error: "Turnstile verification required"
    };
  }
  const rateLimitKey = `warranty-submit-${installerEmail}`;
  const now = Date.now();
  const windowMs = 15 * 60 * 1e3;
  const maxAttempts = 3;
  const recentSubmissions = submissionsCache.get(rateLimitKey) || [];
  const validSubmissions = recentSubmissions.filter((time) => now - time < windowMs);
  if (validSubmissions.length >= maxAttempts) {
    return {
      success: false,
      error: "Too many submissions. Please wait 15 minutes before trying again."
    };
  }
  validSubmissions.push(now);
  submissionsCache.set(rateLimitKey, validSubmissions);
  if (turnstileToken === "mock-token") {
    console$1.warn("⚠️ Skipping Turnstile verification (mock token provided)");
  } else {
    const turnstileSecret = process.env.TURNSTILE_SECRET_KEY || void 0;
    if (!turnstileSecret) {
      console$1.error("TURNSTILE_SECRET_KEY not configured");
      return {
        success: false,
        error: "Server configuration error"
      };
    }
    const turnstileResponse = await fetch("https://challenges.cloudflare.com/turnstile/v0/siteverify", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        secret: turnstileSecret,
        response: turnstileToken
      })
    });
    const turnstileResult = await turnstileResponse.json();
    if (!turnstileResult.success) {
      return {
        success: false,
        error: "Spam verification failed. Please try again."
      };
    }
  }
  const supabaseUrl = process.env.VITE_SUPABASE_URL || "https://tcrpfwxfsbkrwqielhfg.supabase.co";
  const supabaseAnonKey = process.env.VITE_SUPABASE_ANON_KEY || "sb_publishable_y8Vro117yYqQIMCBHvffVA_rDCXg4Sz";
  const supabase = createClient(supabaseUrl, supabaseAnonKey);
  const resend = new Resend(process.env.RESEND_API_KEY || void 0);
  const batteryCount = serialNumbers.filter((s) => s.trim()).length;
  const nominalCapacity = batteryCount * 5.12;
  const usableCapacity = nominalCapacity * 0.9;
  const {
    error: dbError,
    data: warrantyData
  } = await supabase.from("warranty_registrations").insert([{
    warranty_id: warrantyId,
    installer_name: sanitizedData.installerName,
    installer_email: sanitizedData.installerEmail,
    installer_phone: sanitizedData.installerPhone,
    company_name: sanitizedData.companyName || null,
    electrical_licence: sanitizedData.electricalLicence || null,
    install_street: sanitizedData.installStreet,
    install_suburb: sanitizedData.installSuburb,
    install_postcode: sanitizedData.installPostcode,
    on_behalf_of_homeowner: onBehalfOfHomeowner,
    homeowner_name: sanitizedData.homeownerName || null,
    homeowner_email: sanitizedData.homeownerEmail || null,
    homeowner_phone: sanitizedData.homeownerPhone || null,
    homeowner_address: sanitizedData.homeownerAddress || null,
    battery_model: batteryModel,
    serial_numbers: sanitizedData.serialNumbers.filter((s) => s.trim()),
    phases,
    grid_status: gridStatus,
    pv_system: pvSystem,
    backup_genset: backupGenset,
    inverter_brand: sanitizedData.inverterBrand || null,
    inverter_model: sanitizedData.inverterModel || null,
    inverter_serial: sanitizedData.inverterSerial || null,
    install_date: installDate,
    commissioning_date: commissioningDate,
    retailer: sanitizedData.retailer || null,
    purchase_date: purchaseDate || null,
    installation_notes: sanitizedData.installationNotes || null,
    evidence_files: evidenceFiles,
    installation_declaration: installationDeclaration,
    marketing_permission: marketingPermission
  }]);
  if (dbError) {
    console$1.error("Database error:", dbError);
    return {
      success: false,
      error: "Failed to save warranty registration. Please try again."
    };
  }
  const emailPayload = {
    warrantyId,
    installer: {
      technicianName: sanitizedData.installerName,
      company: sanitizedData.companyName,
      licence: sanitizedData.electricalLicence,
      email: sanitizedData.installerEmail,
      phone: sanitizedData.installerPhone
    },
    customer: {
      name: onBehalfOfHomeowner && sanitizedData.homeownerName ? sanitizedData.homeownerName : sanitizedData.installerName,
      email: onBehalfOfHomeowner && sanitizedData.homeownerEmail ? sanitizedData.homeownerEmail : sanitizedData.installerEmail,
      phone: onBehalfOfHomeowner && sanitizedData.homeownerPhone ? sanitizedData.homeownerPhone : sanitizedData.installerPhone,
      address: {
        street: sanitizedData.installStreet,
        suburb: sanitizedData.installSuburb,
        state: "WA",
        postcode: sanitizedData.installPostcode
      }
    },
    system: {
      model: batteryModel,
      installDate,
      commissioningDate,
      serials: serialNumbers.filter((s) => s.trim()),
      capacity: `${nominalCapacity.toFixed(2)} kWh nominal / ${usableCapacity.toFixed(2)} kWh usable`,
      phases,
      gridStatus,
      pvSystem,
      backupGenset,
      inverter: {
        brand: inverterBrand || "Not specified",
        model: inverterModel || "Not specified",
        serial: inverterSerial || "Not specified"
      },
      retailer,
      purchaseDate
    },
    notes: `Installation Notes: ${onBehalfOfHomeowner ? "Registration on behalf of homeowner. " : ""}System Details: ${batteryModel} - Nominal: ${nominalCapacity.toFixed(2)} kWh, Usable: ${usableCapacity.toFixed(2)} kWh - ${phases} phase${pvSystem ? " with PV system" : ""}${backupGenset ? " with backup generator" : ""}. Purchase: ${retailer || "Not specified"}${purchaseDate ? ` on ${new Date(purchaseDate).toLocaleDateString()}` : ""}`,
    installationNotes,
    thumbnails: evidenceFiles.map((file) => ({
      dataUrl: file.url,
      name: file.name
    }))
  };
  const warrantyToEmail = process.env.WARRANTY_TO_EMAIL || void 0 || "support@renoz.energy";
  const warrantyFromEmail = process.env.WARRANTY_FROM_EMAIL || void 0 || "RENOZ Energy <noreply@renoz.energy>";
  const resendApiKey = process.env.RESEND_API_KEY || void 0;
  if (resendApiKey) {
    try {
      const supportEmailHtml = await render$1(reactExports.createElement(WarrantySupportEmail, {
        payload: emailPayload
      }));
      console$1.log(`📧 Generating Support Email for ${warrantyId}`);
      console$1.log(`Email HTML length: ${supportEmailHtml.length}`);
      if (supportEmailHtml.length < 100) {
        console$1.error("⚠️ Generated HTML is suspiciously short:", supportEmailHtml);
      }
      await resend.emails.send({
        from: warrantyFromEmail,
        to: [warrantyToEmail],
        replyTo: installerEmail,
        subject: `New Warranty Registration: ${warrantyId}`,
        html: supportEmailHtml
      });
      const installerEmailHtml = await render$1(reactExports.createElement(WarrantyInstallerConfirmationEmail, {
        warrantyId,
        installerName,
        installerEmail,
        installerPhone,
        companyName,
        batteryModel,
        serialNumbers: serialNumbers.filter((s) => s.trim()),
        installDate
      }));
      await resend.emails.send({
        from: warrantyFromEmail,
        to: [installerEmail],
        replyTo: warrantyToEmail,
        subject: `Warranty Registration Confirmed - ${warrantyId}`,
        html: installerEmailHtml
      });
      if (onBehalfOfHomeowner && homeownerEmail && homeownerName) {
        const homeownerEmailHtml = await render$1(reactExports.createElement(WarrantyHomeownerConfirmationEmail, {
          warrantyId,
          homeownerName,
          homeownerEmail,
          installerName,
          installerCompany: companyName,
          batteryModel,
          serialNumbers: serialNumbers.filter((s) => s.trim()),
          installDate
        }));
        await resend.emails.send({
          from: warrantyFromEmail,
          to: [homeownerEmail],
          replyTo: warrantyToEmail,
          subject: `Your RENOZ Battery Warranty Has Been Registered - ${warrantyId}`,
          html: homeownerEmailHtml
        });
      }
    } catch (emailError) {
      console$1.error("Email error:", emailError);
    }
  } else {
    console$1.warn("RESEND_API_KEY not configured - skipping email notifications");
  }
  return {
    success: true,
    data: warrantyData
  };
});
export {
  submitWarranty_createServerFn_handler
};
